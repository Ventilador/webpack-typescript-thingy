const ts = require('typescript');
const SymbolFlags = ts.SymbolFlags;
const TypeFlags = ts.TypeFlags;
const SyntaxKind = ts.SyntaxKind;
const CheckFlags = {
    Instantiated: 1,
    SyntheticProperty: 2,
    SyntheticMethod: 4,
    Readonly: 8,
    Partial: 16,
    HasNonUniformType: 32,
    ContainsPublic: 64,
    ContainsProtected: 128,
    ContainsPrivate: 256,
    ContainsStatic: 512,
    Synthetic: 6
};
const ModifierFlags = ts.ModifierFlags;

module.exports = function createTypeChecker(thing, produceDiagnostics) {
    // Cancellation that controls whether or not we can cancel in the middle of type checking.
    // In general cancelling is *not* safe for the type checker.  We might be in the middle of
    // computing something, and we will leave our internals in an inconsistent state.  Callers
    // who set the cancellation token should catch if a cancellation exception occurs, and
    // should throw away and create a new TypeChecker.
    //
    // Currently we only support setting the cancellation token when getting diagnostics.  This
    // is because diagnostics can be quite expensive, and we want to allow hosts to bail out if
    // they no longer need the information (for example, if the user started editing again).
    let cancellationToken;
    let requestedExternalEmitHelpers;
    let externalHelpersModule;
    let Symbol = ts.objectAllocator.getSymbolConstructor();
    let Type = ts.objectAllocator.getTypeConstructor();
    let Signature = ts.objectAllocator.getSignatureConstructor();
    let typeCount = 0;
    let symbolCount = 0;
    let enumCount = 0;
    let symbolInstantiationDepth = 0;
    let emptySymbols = ts.createSymbolTable();
    let identityMapper = ts.identity;
    let compilerOptions = thing.getCompilerOptions();
    let languageVersion = ts.getEmitScriptTarget(compilerOptions);
    let modulekind = ts.getEmitModuleKind(compilerOptions);
    let noUnusedIdentifiers = !!compilerOptions.noUnusedLocals || !!compilerOptions.noUnusedParameters;
    let allowSyntheticDefaultImports = typeof compilerOptions.allowSyntheticDefaultImports !== "undefined" ? compilerOptions.allowSyntheticDefaultImports : modulekind === ts.ModuleKind.System;
    let strictNullChecks = compilerOptions.strictNullChecks === undefined ? compilerOptions.strict : compilerOptions.strictNullChecks;
    let strictFunctionTypes = compilerOptions.strictFunctionTypes === undefined ? compilerOptions.strict : compilerOptions.strictFunctionTypes;
    let noImplicitAny = compilerOptions.noImplicitAny === undefined ? compilerOptions.strict : compilerOptions.noImplicitAny;
    let noImplicitThis = compilerOptions.noImplicitThis === undefined ? compilerOptions.strict : compilerOptions.noImplicitThis;
    let emitResolver = createResolver();
    let nodeBuilder = createNodeBuilder();
    let undefinedSymbol = createSymbol(SymbolFlags.Property, "undefined");
    undefinedSymbol.declarations = [];
    let argumentsSymbol = createSymbol(SymbolFlags.Property, "arguments");
    /** This will be set during calls to `getResolvedSignature` where services determines an apparent number of arguments greater than what is actually provided. */
    let apparentArgumentCount;
    // for public members that accept a Node or one of its subtypes, we must guard against
    // synthetic nodes created during transformations by calling `getParseTreeNode`.
    // for most of these, we perform the guard only on `checker` to avoid any possible
    // extra cost of calling `getParseTreeNode` when calling these functions from inside the
    // checker.
    let checker = {
        getNodeCount: function () { return ts.sum(thing.getSourceFiles(), "nodeCount"); },
        getIdentifierCount: function () { return ts.sum(thing.getSourceFiles(), "identifierCount"); },
        getSymbolCount: function () { return ts.sum(thing.getSourceFiles(), "symbolCount") + symbolCount; },
        getTypeCount: function () { return typeCount; },
        isUndefinedSymbol: function (symbol) { return symbol === undefinedSymbol; },
        isArgumentsSymbol: function (symbol) { return symbol === argumentsSymbol; },
        isUnknownSymbol: function (symbol) { return symbol === unknownSymbol; },
        getMergedSymbol: getMergedSymbol,
        getDiagnostics: getDiagnostics,
        getGlobalDiagnostics: getGlobalDiagnostics,
        getTypeOfSymbolAtLocation: function (symbol, location) {
            location = ts.getParseTreeNode(location);
            return location ? getTypeOfSymbolAtLocation(symbol, location) : unknownType;
        },
        getSymbolsOfParameterPropertyDeclaration: function (parameter, parameterName) {
            parameter = ts.getParseTreeNode(parameter, ts.isParameter);
            ts.Debug.assert(parameter !== undefined, "Cannot get symbols of a synthetic parameter that cannot be resolved to a parse-tree node.");
            return getSymbolsOfParameterPropertyDeclaration(parameter, ts.escapeLeadingUnderscores(parameterName));
        },
        getDeclaredTypeOfSymbol: getDeclaredTypeOfSymbol,
        getPropertiesOfType: getPropertiesOfType,
        getPropertyOfType: function (type, name) { return getPropertyOfType(type, ts.escapeLeadingUnderscores(name)); },
        getIndexInfoOfType: getIndexInfoOfType,
        getSignaturesOfType: getSignaturesOfType,
        getIndexTypeOfType: getIndexTypeOfType,
        getBaseTypes: getBaseTypes,
        getBaseTypeOfLiteralType: getBaseTypeOfLiteralType,
        getWidenedType: getWidenedType,
        getTypeFromTypeNode: function (node) {
            node = ts.getParseTreeNode(node, ts.isTypeNode);
            return node ? getTypeFromTypeNode(node) : unknownType;
        },
        getParameterType: getTypeAtPosition,
        getReturnTypeOfSignature: getReturnTypeOfSignature,
        getNullableType: getNullableType,
        getNonNullableType: getNonNullableType,
        typeToTypeNode: nodeBuilder.typeToTypeNode,
        indexInfoToIndexSignatureDeclaration: nodeBuilder.indexInfoToIndexSignatureDeclaration,
        signatureToSignatureDeclaration: nodeBuilder.signatureToSignatureDeclaration,
        getSymbolsInScope: function (location, meaning) {
            location = ts.getParseTreeNode(location);
            return location ? getSymbolsInScope(location, meaning) : [];
        },
        getSymbolAtLocation: function (node) {
            node = ts.getParseTreeNode(node);
            return node ? getSymbolAtLocation(node) : undefined;
        },
        getShorthandAssignmentValueSymbol: function (node) {
            node = ts.getParseTreeNode(node);
            return node ? getShorthandAssignmentValueSymbol(node) : undefined;
        },
        getExportSpecifierLocalTargetSymbol: function (node) {
            node = ts.getParseTreeNode(node, ts.isExportSpecifier);
            return node ? getExportSpecifierLocalTargetSymbol(node) : undefined;
        },
        getExportSymbolOfSymbol: function (symbol) {
            return getMergedSymbol(symbol.exportSymbol || symbol);
        },
        getTypeAtLocation: function (node) {
            node = ts.getParseTreeNode(node);
            return node ? getTypeOfNode(node) : unknownType;
        },
        getPropertySymbolOfDestructuringAssignment: function (location) {
            location = ts.getParseTreeNode(location, ts.isIdentifier);
            return location ? getPropertySymbolOfDestructuringAssignment(location) : undefined;
        },
        signatureToString: function (signature, enclosingDeclaration, flags, kind) {
            return signatureToString(signature, ts.getParseTreeNode(enclosingDeclaration), flags, kind);
        },
        typeToString: function (type, enclosingDeclaration, flags) {
            return typeToString(type, ts.getParseTreeNode(enclosingDeclaration), flags);
        },
        getSymbolDisplayBuilder: getSymbolDisplayBuilder,
        symbolToString: function (symbol, enclosingDeclaration, meaning) {
            return symbolToString(symbol, ts.getParseTreeNode(enclosingDeclaration), meaning);
        },
        getAugmentedPropertiesOfType: getAugmentedPropertiesOfType,
        getRootSymbols: getRootSymbols,
        getContextualType: function (node) {
            node = ts.getParseTreeNode(node, ts.isExpression);
            return node ? getContextualType(node) : undefined;
        },
        getFullyQualifiedName: getFullyQualifiedName,
        getResolvedSignature: function (node, candidatesOutArray, theArgumentCount) {
            node = ts.getParseTreeNode(node, ts.isCallLikeExpression);
            apparentArgumentCount = theArgumentCount;
            let res = node ? getResolvedSignature(node, candidatesOutArray) : undefined;
            apparentArgumentCount = undefined;
            return res;
        },
        getConstantValue: function (node) {
            node = ts.getParseTreeNode(node, canHaveConstantValue);
            return node ? getConstantValue(node) : undefined;
        },
        isValidPropertyAccess: function (node, propertyName) {
            node = ts.getParseTreeNode(node, ts.isPropertyAccessOrQualifiedName);
            return node ? isValidPropertyAccess(node, ts.escapeLeadingUnderscores(propertyName)) : false;
        },
        getSignatureFromDeclaration: function (declaration) {
            declaration = ts.getParseTreeNode(declaration, ts.isFunctionLike);
            return declaration ? getSignatureFromDeclaration(declaration) : undefined;
        },
        isImplementationOfOverload: function (node) {
            let parsed = ts.getParseTreeNode(node, ts.isFunctionLike);
            return parsed ? isImplementationOfOverload(parsed) : undefined;
        },
        getImmediateAliasedSymbol: function (symbol) {
            ts.Debug.assert((symbol.flags & SymbolFlags.Alias) !== 0, "Should only get Alias here.");
            let links = getSymbolLinks(symbol);
            if (!links.immediateTarget) {
                let node = getDeclarationOfAliasSymbol(symbol);
                ts.Debug.assert(!!node);
                links.immediateTarget = getTargetOfAliasDeclaration(node, /*dontRecursivelyResolve*/ true);
            }
            return links.immediateTarget;
        },
        getAliasedSymbol: resolveAlias,
        getEmitResolver: getEmitResolver,
        getExportsOfModule: getExportsOfModuleAsArray,
        getExportsAndPropertiesOfModule: getExportsAndPropertiesOfModule,
        getSymbolWalker: ts.createGetSymbolWalker(getRestTypeOfSignature, getReturnTypeOfSignature, getBaseTypes, resolveStructuredTypeMembers, getTypeOfSymbol, getResolvedSymbol, getIndexTypeOfStructuredType, getConstraintFromTypeParameter, getFirstIdentifier),
        getAmbientModules: getAmbientModules,
        getAllAttributesTypeFromJsxOpeningLikeElement: function (node) {
            node = ts.getParseTreeNode(node, ts.isJsxOpeningLikeElement);
            return node ? getAllAttributesTypeFromJsxOpeningLikeElement(node) : undefined;
        },
        getJsxIntrinsicTagNames: getJsxIntrinsicTagNames,
        isOptionalParameter: function (node) {
            node = ts.getParseTreeNode(node, ts.isParameter);
            return node ? isOptionalParameter(node) : false;
        },
        tryGetMemberInModuleExports: function (name, symbol) { return tryGetMemberInModuleExports(ts.escapeLeadingUnderscores(name), symbol); },
        tryGetMemberInModuleExportsAndProperties: function (name, symbol) { return tryGetMemberInModuleExportsAndProperties(ts.escapeLeadingUnderscores(name), symbol); },
        tryFindAmbientModuleWithoutAugmentations: function (moduleName) {
            // we deliberately exclude augmentations
            // since we are only interested in declarations of the module itself
            return tryFindAmbientModule(moduleName, /*withAugmentations*/ false);
        },
        getApparentType: getApparentType,
        getUnionType: getUnionType,
        createAnonymousType: createAnonymousType,
        createSignature: createSignature,
        createSymbol: createSymbol,
        createIndexInfo: createIndexInfo,
        getAnyType: function () { return anyType; },
        getStringType: function () { return stringType; },
        getNumberType: function () { return numberType; },
        createPromiseType: createPromiseType,
        createArrayType: createArrayType,
        getBooleanType: function () { return booleanType; },
        getVoidType: function () { return voidType; },
        getUndefinedType: function () { return undefinedType; },
        getNullType: function () { return nullType; },
        getESSymbolType: function () { return esSymbolType; },
        getNeverType: function () { return neverType; },
        isSymbolAccessible: isSymbolAccessible,
        isArrayLikeType: isArrayLikeType,
        getAllPossiblePropertiesOfTypes: getAllPossiblePropertiesOfTypes,
        getSuggestionForNonexistentProperty: function (node, type) { return getSuggestionForNonexistentProperty(node, type); },
        getSuggestionForNonexistentSymbol: function (location, name, meaning) { return getSuggestionForNonexistentSymbol(location, ts.escapeLeadingUnderscores(name), meaning); },
        getBaseConstraintOfType: getBaseConstraintOfType,
        resolveName: function (name, location, meaning) {
            return resolveName(location, ts.escapeLeadingUnderscores(name), meaning, /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ false);
        },
        getJsxNamespace: function () { return ts.unescapeLeadingUnderscores(getJsxNamespace()); },
    };
    let tupleTypes = [];
    let unionTypes = ts.createMap();
    let intersectionTypes = ts.createMap();
    let literalTypes = ts.createMap();
    let indexedAccessTypes = ts.createMap();
    let evolvingArrayTypes = [];
    let unknownSymbol = createSymbol(SymbolFlags.Property, "unknown");
    let resolvingSymbol = createSymbol(0, "__resolving__" /* Resolving */);
    let anyType = createIntrinsicType(1 /* Any */, "any");
    let autoType = createIntrinsicType(1 /* Any */, "any");
    let unknownType = createIntrinsicType(1 /* Any */, "unknown");
    let undefinedType = createIntrinsicType(2048 /* Undefined */, "undefined");
    let undefinedWideningType = strictNullChecks ? undefinedType : createIntrinsicType(2048 /* Undefined */ | 2097152 /* ContainsWideningType */, "undefined");
    let nullType = createIntrinsicType(4096 /* Null */, "null");
    let nullWideningType = strictNullChecks ? nullType : createIntrinsicType(4096 /* Null */ | 2097152 /* ContainsWideningType */, "null");
    let stringType = createIntrinsicType(2 /* String */, "string");
    let numberType = createIntrinsicType(4 /* Number */, "number");
    let trueType = createIntrinsicType(128 /* BooleanLiteral */, "true");
    let falseType = createIntrinsicType(128 /* BooleanLiteral */, "false");
    let booleanType = createBooleanType([trueType, falseType]);
    let esSymbolType = createIntrinsicType(512 /* ESSymbol */, "symbol");
    let voidType = createIntrinsicType(1024 /* Void */, "void");
    let neverType = createIntrinsicType(8192 /* Never */, "never");
    let silentNeverType = createIntrinsicType(8192 /* Never */, "never");
    let nonPrimitiveType = createIntrinsicType(16777216 /* NonPrimitive */, "object");
    let emptyObjectType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, undefined, undefined);
    let emptyTypeLiteralSymbol = createSymbol(2048 /* TypeLiteral */, "__type" /* Type */);
    emptyTypeLiteralSymbol.members = ts.createSymbolTable();
    let emptyTypeLiteralType = createAnonymousType(emptyTypeLiteralSymbol, emptySymbols, ts.emptyArray, ts.emptyArray, undefined, undefined);
    let emptyGenericType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, undefined, undefined);
    emptyGenericType.instantiations = ts.createMap();
    let anyFunctionType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, undefined, undefined);
    // The anyFunctionType contains the anyFunctionType by definition. The flag is further propagated
    // in getPropagatingFlagsOfTypes, and it is checked in inferFromTypes.
    anyFunctionType.flags |= 8388608 /* ContainsAnyFunctionType */;
    let noConstraintType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, undefined, undefined);
    let circularConstraintType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, undefined, undefined);
    let resolvingDefaultType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, undefined, undefined);
    let markerSuperType = createType(16384 /* TypeParameter */);
    let markerSubType = createType(16384 /* TypeParameter */);
    markerSubType.constraint = markerSuperType;
    let markerOtherType = createType(16384 /* TypeParameter */);
    let anySignature = createSignature(undefined, undefined, undefined, ts.emptyArray, anyType, /*typePredicate*/ undefined, 0, /*hasRestParameter*/ false, /*hasLiteralTypes*/ false);
    let unknownSignature = createSignature(undefined, undefined, undefined, ts.emptyArray, unknownType, /*typePredicate*/ undefined, 0, /*hasRestParameter*/ false, /*hasLiteralTypes*/ false);
    let resolvingSignature = createSignature(undefined, undefined, undefined, ts.emptyArray, anyType, /*typePredicate*/ undefined, 0, /*hasRestParameter*/ false, /*hasLiteralTypes*/ false);
    let silentNeverSignature = createSignature(undefined, undefined, undefined, ts.emptyArray, silentNeverType, /*typePredicate*/ undefined, 0, /*hasRestParameter*/ false, /*hasLiteralTypes*/ false);
    let enumNumberIndexInfo = createIndexInfo(stringType, /*isReadonly*/ true);
    let jsObjectLiteralIndexInfo = createIndexInfo(anyType, /*isReadonly*/ false);
    let globals = ts.createSymbolTable();
    let ambientModulesCache;
    /**
     * List of every ambient module with a "*" wildcard.
     * Unlike other ambient modules, these can't be stored in `globals` because symbol tables only deal with exact matches.
     * This is only used if there is no exact match.
     */
    let patternAmbientModules;
    let globalObjectType;
    let globalFunctionType;
    let globalArrayType;
    let globalReadonlyArrayType;
    let globalStringType;
    let globalNumberType;
    let globalBooleanType;
    let globalRegExpType;
    let globalThisType;
    let anyArrayType;
    let autoArrayType;
    let anyReadonlyArrayType;
    // The library files are only loaded when the feature is used.
    // This allows users to just specify library files they want to used through --lib
    // and they will not get an error from not having unrelated library files
    let deferredGlobalESSymbolConstructorSymbol;
    let deferredGlobalESSymbolType;
    let deferredGlobalTypedPropertyDescriptorType;
    let deferredGlobalPromiseType;
    let deferredGlobalPromiseConstructorSymbol;
    let deferredGlobalPromiseConstructorLikeType;
    let deferredGlobalIterableType;
    let deferredGlobalIteratorType;
    let deferredGlobalIterableIteratorType;
    let deferredGlobalAsyncIterableType;
    let deferredGlobalAsyncIteratorType;
    let deferredGlobalAsyncIterableIteratorType;
    let deferredGlobalTemplateStringsArrayType;
    let deferredJsxElementClassType;
    let deferredJsxElementType;
    let deferredJsxStatelessElementType;
    let deferredNodes;
    let deferredUnusedIdentifierNodes;
    let flowLoopStart = 0;
    let flowLoopCount = 0;
    let sharedFlowCount = 0;
    let flowAnalysisDisabled = false;
    let emptyStringType = getLiteralType("");
    let zeroType = getLiteralType(0);
    let resolutionTargets = [];
    let resolutionResults = [];
    let resolutionPropertyNames = [];
    let suggestionCount = 0;
    let maximumSuggestionCount = 10;
    let mergedSymbols = [];
    let symbolLinks = [];
    let nodeLinks = [];
    let flowLoopCaches = [];
    let flowLoopNodes = [];
    let flowLoopKeys = [];
    let flowLoopTypes = [];
    let sharedFlowNodes = [];
    let sharedFlowTypes = [];
    let potentialThisCollisions = [];
    let potentialNewTargetCollisions = [];
    let awaitedTypeStack = [];
    let diagnostics = ts.createDiagnosticCollection();
    let TypeFacts;
    (function (TypeFacts) {
        TypeFacts[TypeFacts["None"] = 0] = "None";
        TypeFacts[TypeFacts["TypeofEQString"] = 1] = "TypeofEQString";
        TypeFacts[TypeFacts["TypeofEQNumber"] = 2] = "TypeofEQNumber";
        TypeFacts[TypeFacts["TypeofEQBoolean"] = 4] = "TypeofEQBoolean";
        TypeFacts[TypeFacts["TypeofEQSymbol"] = 8] = "TypeofEQSymbol";
        TypeFacts[TypeFacts["TypeofEQObject"] = 16] = "TypeofEQObject";
        TypeFacts[TypeFacts["TypeofEQFunction"] = 32] = "TypeofEQFunction";
        TypeFacts[TypeFacts["TypeofEQHostObject"] = 64] = "TypeofEQHostObject";
        TypeFacts[TypeFacts["TypeofNEString"] = 128] = "TypeofNEString";
        TypeFacts[TypeFacts["TypeofNENumber"] = 256] = "TypeofNENumber";
        TypeFacts[TypeFacts["TypeofNEBoolean"] = 512] = "TypeofNEBoolean";
        TypeFacts[TypeFacts["TypeofNESymbol"] = 1024] = "TypeofNESymbol";
        TypeFacts[TypeFacts["TypeofNEObject"] = 2048] = "TypeofNEObject";
        TypeFacts[TypeFacts["TypeofNEFunction"] = 4096] = "TypeofNEFunction";
        TypeFacts[TypeFacts["TypeofNEHostObject"] = 8192] = "TypeofNEHostObject";
        TypeFacts[TypeFacts["EQUndefined"] = 16384] = "EQUndefined";
        TypeFacts[TypeFacts["EQNull"] = 32768] = "EQNull";
        TypeFacts[TypeFacts["EQUndefinedOrNull"] = 65536] = "EQUndefinedOrNull";
        TypeFacts[TypeFacts["NEUndefined"] = 131072] = "NEUndefined";
        TypeFacts[TypeFacts["NENull"] = 262144] = "NENull";
        TypeFacts[TypeFacts["NEUndefinedOrNull"] = 524288] = "NEUndefinedOrNull";
        TypeFacts[TypeFacts["Truthy"] = 1048576] = "Truthy";
        TypeFacts[TypeFacts["Falsy"] = 2097152] = "Falsy";
        TypeFacts[TypeFacts["Discriminatable"] = 4194304] = "Discriminatable";
        TypeFacts[TypeFacts["All"] = 8388607] = "All";
        // The following members encode facts about particular kinds of types for use in the getTypeFacts function.
        // The presence of a particular fact means that the given test is true for some (and possibly all) values
        // of that kind of type.
        TypeFacts[TypeFacts["BaseStringStrictFacts"] = 933633] = "BaseStringStrictFacts";
        TypeFacts[TypeFacts["BaseStringFacts"] = 3145473] = "BaseStringFacts";
        TypeFacts[TypeFacts["StringStrictFacts"] = 4079361] = "StringStrictFacts";
        TypeFacts[TypeFacts["StringFacts"] = 4194049] = "StringFacts";
        TypeFacts[TypeFacts["EmptyStringStrictFacts"] = 3030785] = "EmptyStringStrictFacts";
        TypeFacts[TypeFacts["EmptyStringFacts"] = 3145473] = "EmptyStringFacts";
        TypeFacts[TypeFacts["NonEmptyStringStrictFacts"] = 1982209] = "NonEmptyStringStrictFacts";
        TypeFacts[TypeFacts["NonEmptyStringFacts"] = 4194049] = "NonEmptyStringFacts";
        TypeFacts[TypeFacts["BaseNumberStrictFacts"] = 933506] = "BaseNumberStrictFacts";
        TypeFacts[TypeFacts["BaseNumberFacts"] = 3145346] = "BaseNumberFacts";
        TypeFacts[TypeFacts["NumberStrictFacts"] = 4079234] = "NumberStrictFacts";
        TypeFacts[TypeFacts["NumberFacts"] = 4193922] = "NumberFacts";
        TypeFacts[TypeFacts["ZeroStrictFacts"] = 3030658] = "ZeroStrictFacts";
        TypeFacts[TypeFacts["ZeroFacts"] = 3145346] = "ZeroFacts";
        TypeFacts[TypeFacts["NonZeroStrictFacts"] = 1982082] = "NonZeroStrictFacts";
        TypeFacts[TypeFacts["NonZeroFacts"] = 4193922] = "NonZeroFacts";
        TypeFacts[TypeFacts["BaseBooleanStrictFacts"] = 933252] = "BaseBooleanStrictFacts";
        TypeFacts[TypeFacts["BaseBooleanFacts"] = 3145092] = "BaseBooleanFacts";
        TypeFacts[TypeFacts["BooleanStrictFacts"] = 4078980] = "BooleanStrictFacts";
        TypeFacts[TypeFacts["BooleanFacts"] = 4193668] = "BooleanFacts";
        TypeFacts[TypeFacts["FalseStrictFacts"] = 3030404] = "FalseStrictFacts";
        TypeFacts[TypeFacts["FalseFacts"] = 3145092] = "FalseFacts";
        TypeFacts[TypeFacts["TrueStrictFacts"] = 1981828] = "TrueStrictFacts";
        TypeFacts[TypeFacts["TrueFacts"] = 4193668] = "TrueFacts";
        TypeFacts[TypeFacts["SymbolStrictFacts"] = 1981320] = "SymbolStrictFacts";
        TypeFacts[TypeFacts["SymbolFacts"] = 4193160] = "SymbolFacts";
        TypeFacts[TypeFacts["ObjectStrictFacts"] = 6166480] = "ObjectStrictFacts";
        TypeFacts[TypeFacts["ObjectFacts"] = 8378320] = "ObjectFacts";
        TypeFacts[TypeFacts["FunctionStrictFacts"] = 6164448] = "FunctionStrictFacts";
        TypeFacts[TypeFacts["FunctionFacts"] = 8376288] = "FunctionFacts";
        TypeFacts[TypeFacts["UndefinedFacts"] = 2457472] = "UndefinedFacts";
        TypeFacts[TypeFacts["NullFacts"] = 2340752] = "NullFacts";
    })(TypeFacts || (TypeFacts = {}));
    let typeofEQFacts = ts.createMapFromTemplate({
        "string": TypeFacts.TypeofEQString,
        "number": TypeFacts.TypeofEQNumber,
        "boolean": TypeFacts.TypeofEQBoolean,
        "symbol": TypeFacts.TypeofEQSymbol,
        "undefined": TypeFacts.EQUndefined,
        "object": TypeFacts.TypeofEQObject,
        "function": TypeFacts.TypeofEQFunction
    });
    let typeofNEFacts = ts.createMapFromTemplate({
        "string": TypeFacts.TypeofNEString,
        "number": TypeFacts.TypeofNENumber,
        "boolean": TypeFacts.TypeofNEBoolean,
        "symbol": TypeFacts.TypeofNESymbol,
        "undefined": TypeFacts.NEUndefined,
        "object": TypeFacts.TypeofNEObject,
        "function": TypeFacts.TypeofNEFunction
    });
    let typeofTypesByName = ts.createMapFromTemplate({
        "string": stringType,
        "number": numberType,
        "boolean": booleanType,
        "symbol": esSymbolType,
        "undefined": undefinedType
    });
    let typeofType = createTypeofType();
    let _jsxNamespace;
    let _jsxFactoryEntity;
    let _jsxElementPropertiesName;
    let _hasComputedJsxElementPropertiesName = false;
    let _jsxElementChildrenPropertyName;
    let _hasComputedJsxElementChildrenPropertyName = false;
    /** Things we lazy load from the JSX namespace */
    let jsxTypes = ts.createUnderscoreEscapedMap();
    let JsxNames = {
        JSX: "JSX",
        IntrinsicElements: "IntrinsicElements",
        ElementClass: "ElementClass",
        ElementAttributesPropertyNameContainer: "ElementAttributesProperty",
        ElementChildrenAttributeNameContainer: "ElementChildrenAttribute",
        Element: "Element",
        IntrinsicAttributes: "IntrinsicAttributes",
        IntrinsicClassAttributes: "IntrinsicClassAttributes"
    };
    let subtypeRelation = ts.createMap();
    let assignableRelation = ts.createMap();
    let comparableRelation = ts.createMap();
    let identityRelation = ts.createMap();
    let enumRelation = ts.createMap();
    // This is for caching the result of getSymbolDisplayBuilder. Do not access directly.
    let _displayBuilder;
    let TypeSystemPropertyName;
    (function (TypeSystemPropertyName) {
        TypeSystemPropertyName[TypeSystemPropertyName["Type"] = 0] = "Type";
        TypeSystemPropertyName[TypeSystemPropertyName["ResolvedBaseConstructorType"] = 1] = "ResolvedBaseConstructorType";
        TypeSystemPropertyName[TypeSystemPropertyName["DeclaredType"] = 2] = "DeclaredType";
        TypeSystemPropertyName[TypeSystemPropertyName["ResolvedReturnType"] = 3] = "ResolvedReturnType";
    })(TypeSystemPropertyName || (TypeSystemPropertyName = {}));
    let CheckMode;
    (function (CheckMode) {
        CheckMode[CheckMode["Normal"] = 0] = "Normal";
        CheckMode[CheckMode["SkipContextSensitive"] = 1] = "SkipContextSensitive";
        CheckMode[CheckMode["Inferential"] = 2] = "Inferential";
    })(CheckMode || (CheckMode = {}));
    let CallbackCheck;
    (function (CallbackCheck) {
        CallbackCheck[CallbackCheck["None"] = 0] = "None";
        CallbackCheck[CallbackCheck["Bivariant"] = 1] = "Bivariant";
        CallbackCheck[CallbackCheck["Strict"] = 2] = "Strict";
    })(CallbackCheck || (CallbackCheck = {}));
    let builtinGlobals = ts.createSymbolTable();
    builtinGlobals.set(undefinedSymbol.escapedName, undefinedSymbol);
    let isNotOverloadAndNotAccessor = ts.and(isNotOverload, isNotAccessor);
    initializeTypeChecker();
    return checker;
    function getJsxNamespace() {
        if (!_jsxNamespace) {
            _jsxNamespace = "React";
            if (compilerOptions.jsxFactory) {
                _jsxFactoryEntity = ts.parseIsolatedEntityName(compilerOptions.jsxFactory, languageVersion);
                if (_jsxFactoryEntity) {
                    _jsxNamespace = getFirstIdentifier(_jsxFactoryEntity).escapedText;
                }
            }
            else if (compilerOptions.reactNamespace) {
                _jsxNamespace = ts.escapeLeadingUnderscores(compilerOptions.reactNamespace);
            }
        }
        return _jsxNamespace;
    }
    function getEmitResolver(sourceFile, cancellationToken) {
        // Ensure we have all the type information in place for this file so that all the
        // emitter questions of this resolver will return the right information.
        getDiagnostics(sourceFile, cancellationToken);
        return emitResolver;
    }
    function error(location, message, arg0, arg1, arg2) {
        let diagnostic = location
            ? ts.createDiagnosticForNode(location, message, arg0, arg1, arg2)
            : ts.createCompilerDiagnostic(message, arg0, arg1, arg2);
        diagnostics.add(diagnostic);
    }
    function createSymbol(flags, name) {
        symbolCount++;
        let symbol = (new Symbol(flags | SymbolFlags.Transient, name));
        symbol.checkFlags = 0;
        return symbol;
    }
    function isTransientSymbol(symbol) {
        return (symbol.flags & SymbolFlags.Transient) !== 0;
    }
    function getExcludedSymbolFlags(flags) {
        let result = 0;
        if (flags & SymbolFlags.BlockScopedVariable)
            result |= SymbolFlags.BlockScopedVariableExcludes;
        if (flags & SymbolFlags.FunctionScopedVariable)
            result |= SymbolFlags.FunctionScopedVariableExcludes;
        if (flags & SymbolFlags.Property)
            result |= SymbolFlags.PropertyExcludes;
        if (flags & SymbolFlags.EnumMember)
            result |= SymbolFlags.EnumMemberExcludes;
        if (flags & SymbolFlags.Function)
            result |= SymbolFlags.FunctionExcludes;
        if (flags & SymbolFlags.Class)
            result |= SymbolFlags.ClassExcludes;
        if (flags & SymbolFlags.Interface)
            result |= SymbolFlags.InterfaceExcludes;
        if (flags & SymbolFlags.RegularEnum)
            result |= SymbolFlags.RegularEnumExcludes;
        if (flags & SymbolFlags.ConstEnum)
            result |= SymbolFlags.ConstEnumExcludes;
        if (flags & SymbolFlags.ValueModule)
            result |= SymbolFlags.ValueModuleExcludes;
        if (flags & SymbolFlags.Method)
            result |= SymbolFlags.MethodExcludes;
        if (flags & SymbolFlags.GetAccessor)
            result |= SymbolFlags.GetAccessorExcludes;
        if (flags & SymbolFlags.SetAccessor)
            result |= SymbolFlags.SetAccessorExcludes;
        if (flags & SymbolFlags.TypeParameter)
            result |= SymbolFlags.TypeParameterExcludes;
        if (flags & SymbolFlags.TypeAlias)
            result |= SymbolFlags.TypeAliasExcludes;
        if (flags & SymbolFlags.Alias)
            result |= SymbolFlags.AliasExcludes;
        return result;
    }
    function recordMergedSymbol(target, source) {
        if (!source.mergeId) {
            source.mergeId = nextMergeId;
            nextMergeId++;
        }
        mergedSymbols[source.mergeId] = target;
    }
    function cloneSymbol(symbol) {
        let result = createSymbol(symbol.flags, symbol.escapedName);
        result.declarations = symbol.declarations ? symbol.declarations.slice() : [];
        result.parent = symbol.parent;
        if (symbol.valueDeclaration)
            result.valueDeclaration = symbol.valueDeclaration;
        if (symbol.constEnumOnlyModule)
            result.constEnumOnlyModule = true;
        if (symbol.members)
            result.members = ts.cloneMap(symbol.members);
        if (symbol.exports)
            result.exports = ts.cloneMap(symbol.exports);
        recordMergedSymbol(result, symbol);
        return result;
    }
    function mergeSymbol(target, source) {
        if (!(target.flags & getExcludedSymbolFlags(source.flags))) {
            if (source.flags & SymbolFlags.ValueModule && target.flags & SymbolFlags.ValueModule && target.constEnumOnlyModule && !source.constEnumOnlyModule) {
                // reset flag when merging instantiated module into value module that has only const enums
                target.constEnumOnlyModule = false;
            }
            target.flags |= source.flags;
            if (source.valueDeclaration &&
                (!target.valueDeclaration ||
                    (target.valueDeclaration.kind === SymbolFlags.ModuleDeclaration && source.valueDeclaration.kind !== SymbolFlags.ModuleDeclaration))) {
                // other kinds of value declarations take precedence over modules
                target.valueDeclaration = source.valueDeclaration;
            }
            ts.addRange(target.declarations, source.declarations);
            if (source.members) {
                if (!target.members)
                    target.members = ts.createSymbolTable();
                mergeSymbolTable(target.members, source.members);
            }
            if (source.exports) {
                if (!target.exports)
                    target.exports = ts.createSymbolTable();
                mergeSymbolTable(target.exports, source.exports);
            }
            recordMergedSymbol(target, source);
        }
        else if (target.flags & SymbolFlags.NamespaceModule) {
            error(ts.getNameOfDeclaration(source.declarations[0]), ts.Diagnostics.Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity, symbolToString(target));
        }
        else {
            let message_2 = target.flags & SymbolFlags.BlockScopedVariable || source.flags & SymbolFlags.BlockScopedVariable
                ? ts.Diagnostics.Cannot_redeclare_block_scoped_variable_0 : ts.Diagnostics.Duplicate_identifier_0;
            ts.forEach(source.declarations, function (node) {
                error(ts.getNameOfDeclaration(node) || node, message_2, symbolToString(source));
            });
            ts.forEach(target.declarations, function (node) {
                error(ts.getNameOfDeclaration(node) || node, message_2, symbolToString(source));
            });
        }
    }
    function mergeSymbolTable(target, source) {
        source.forEach(function (sourceSymbol, id) {
            let targetSymbol = target.get(id);
            if (!targetSymbol) {
                target.set(id, sourceSymbol);
            }
            else {
                if (!(targetSymbol.flags & SymbolFlags.Transient)) {
                    targetSymbol = cloneSymbol(targetSymbol);
                    target.set(id, targetSymbol);
                }
                mergeSymbol(targetSymbol, sourceSymbol);
            }
        });
    }
    function mergeModuleAugmentation(moduleName) {
        let moduleAugmentation = moduleName.parent;
        if (moduleAugmentation.symbol.declarations[0] !== moduleAugmentation) {
            // this is a combined symbol for multiple augmentations within the same file.
            // its symbol already has accumulated information for all declarations
            // so we need to add it just once - do the work only for first declaration
            ts.Debug.assert(moduleAugmentation.symbol.declarations.length > 1);
            return;
        }
        if (ts.isGlobalScopeAugmentation(moduleAugmentation)) {
            mergeSymbolTable(globals, moduleAugmentation.symbol.exports);
        }
        else {
            // find a module that about to be augmented
            // do not validate names of augmentations that are defined in ambient context
            let moduleNotFoundError = !ts.isInAmbientContext(moduleName.parent.parent)
                ? ts.Diagnostics.Invalid_module_name_in_augmentation_module_0_cannot_be_found
                : undefined;
            let mainModule = resolveExternalModuleNameWorker(moduleName, moduleName, moduleNotFoundError, /*isForAugmentation*/ true);
            if (!mainModule) {
                return;
            }
            // obtain item referenced by 'export='
            mainModule = resolveExternalModuleSymbol(mainModule);
            if (mainModule.flags & SymbolFlags.Namespace) {
                // if module symbol has already been merged - it is safe to use it.
                // otherwise clone it
                mainModule = mainModule.flags & SymbolFlags.Transient ? mainModule : cloneSymbol(mainModule);
                mergeSymbol(mainModule, moduleAugmentation.symbol);
            }
            else {
                // moduleName will be a StringLiteral since this is not `declare global`.
                error(moduleName, ts.Diagnostics.Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity, moduleName.text);
            }
        }
    }
    function addToSymbolTable(target, source, message) {
        source.forEach(function (sourceSymbol, id) {
            let targetSymbol = target.get(id);
            if (targetSymbol) {
                // Error on redeclarations
                ts.forEach(targetSymbol.declarations, addDeclarationDiagnostic(ts.unescapeLeadingUnderscores(id), message));
            }
            else {
                target.set(id, sourceSymbol);
            }
        });
        function addDeclarationDiagnostic(id, message) {
            return function (declaration) { return diagnostics.add(ts.createDiagnosticForNode(declaration, message, id)); };
        }
    }
    function getSymbolLinks(symbol) {
        if (symbol.flags & SymbolFlags.Transient)
            return symbol;
        let id = getSymbolId(symbol);
        return symbolLinks[id] || (symbolLinks[id] = {});
    }
    function getNodeLinks(node) {
        let nodeId = getNodeId(node);
        return nodeLinks[nodeId] || (nodeLinks[nodeId] = { flags: 0 });
    }
    function getObjectFlags(type) {
        return type.flags & TypeFlags.Object ? type.objectFlags : 0;
    }
    function isGlobalSourceFile(node) {
        return node.kind === SyntaxKind.SourceFile && !ts.isExternalOrCommonJsModule(node);
    }
    function getSymbol(symbols, name, meaning) {
        if (meaning) {
            let symbol = symbols.get(name);
            if (symbol) {
                ts.Debug.assert((ts.getCheckFlags(symbol) & CheckFlags.Instantiated) === 0, "Should never get an instantiated symbol here.");
                if (symbol.flags & meaning) {
                    return symbol;
                }
                if (symbol.flags & SymbolFlags.Alias) {
                    let target = resolveAlias(symbol);
                    // Unknown symbol means an error occurred in alias resolution, treat it as positive answer to avoid cascading errors
                    if (target === unknownSymbol || target.flags & meaning) {
                        return symbol;
                    }
                }
            }
        }
        // return undefined if we can't find a symbol.
    }
    /**
     * Get symbols that represent parameter-property-declaration as parameter and as property declaration
     * @param parameter a parameterDeclaration node
     * @param parameterName a name of the parameter to get the symbols for.
     * @return a tuple of two symbols
     */
    function getSymbolsOfParameterPropertyDeclaration(parameter, parameterName) {
        let constructorDeclaration = parameter.parent;
        let classDeclaration = parameter.parent.parent;
        let parameterSymbol = getSymbol(constructorDeclaration.locals, parameterName, SymbolFlags.Value);
        let propertySymbol = getSymbol(classDeclaration.symbol.members, parameterName, SymbolFlags.Value);
        if (parameterSymbol && propertySymbol) {
            return [parameterSymbol, propertySymbol];
        }
        ts.Debug.fail("There should exist two symbols, one as property declaration and one as parameter declaration");
    }
    function isBlockScopedNameDeclaredBeforeUse(declaration, usage) {
        let declarationFile = ts.getSourceFileOfNode(declaration);
        let useFile = ts.getSourceFileOfNode(usage);
        if (declarationFile !== useFile) {
            if ((modulekind && (declarationFile.externalModuleIndicator || useFile.externalModuleIndicator)) ||
                (!compilerOptions.outFile && !compilerOptions.out) ||
                isInTypeQuery(usage) ||
                ts.isInAmbientContext(declaration)) {
                // nodes are in different files and order cannot be determined
                return true;
            }
            // declaration is after usage
            // can be legal if usage is deferred (i.e. inside function or in initializer of instance property)
            if (isUsedInFunctionOrInstanceProperty(usage, declaration)) {
                return true;
            }
            let sourceFiles = thing.getSourceFiles();
            return ts.indexOf(sourceFiles, declarationFile) <= ts.indexOf(sourceFiles, useFile);
        }
        if (declaration.pos <= usage.pos) {
            // declaration is before usage
            if (declaration.kind === 176 /* BindingElement */) {
                // still might be illegal if declaration and usage are both binding elements (eg let [a = b, b = b] = [1, 2])
                let errorBindingElement = ts.getAncestor(usage, 176 /* BindingElement */);
                if (errorBindingElement) {
                    return ts.findAncestor(errorBindingElement, ts.isBindingElement) !== ts.findAncestor(declaration, ts.isBindingElement) ||
                        declaration.pos < errorBindingElement.pos;
                }
                // or it might be illegal if usage happens before parent variable is declared (eg let [a] = a)
                return isBlockScopedNameDeclaredBeforeUse(ts.getAncestor(declaration, SyntaxKind.VariableDeclaration), usage);
            }
            else if (declaration.kind === SyntaxKind.VariableDeclaration) {
                // still might be illegal if usage is in the initializer of the variable declaration (eg let a = a)
                return !isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration, usage);
            }
            return true;
        }
        // declaration is after usage, but it can still be legal if usage is deferred:
        // 1. inside an export specifier
        // 2. inside a function
        // 3. inside an instance property initializer, a reference to a non-instance property
        // 4. inside a static property initializer, a reference to a static method in the same class
        // 5. inside a TS export= declaration (since we will move the export statement during emit to avoid TDZ)
        // or if usage is in a type context:
        // 1. inside a type query (typeof in type position)
        if (usage.parent.kind === SyntaxKind.ExportSpecifier || (usage.parent.kind === SyntaxKind.ExportAssignment && usage.parent.isExportEquals)) {
            // export specifiers do not use the variable, they only make it available for use
            return true;
        }
        // When resolving symbols for exports, the `usage` location passed in can be the export site directly
        if (usage.kind === SyntaxKind.ExportAssignment && usage.isExportEquals) {
            return true;
        }
        let container = ts.getEnclosingBlockScopeContainer(declaration);
        return isInTypeQuery(usage) || isUsedInFunctionOrInstanceProperty(usage, declaration, container);
        function isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration, usage) {
            let container = ts.getEnclosingBlockScopeContainer(declaration);
            switch (declaration.parent.parent.kind) {
                case SyntaxKind.VariableStatement:
                case SyntaxKind.ForStatement:
                case SyntaxKind.ForOfStatement:
                    // variable statement/for/for-of statement case,
                    // use site should not be inside variable declaration (initializer of declaration or binding element)
                    if (isSameScopeDescendentOf(usage, declaration, container)) {
                        return true;
                    }
                    break;
            }
            // ForIn/ForOf case - use site should not be used in expression part
            return ts.isForInOrOfStatement(declaration.parent.parent) && isSameScopeDescendentOf(usage, declaration.parent.parent.expression, container);
        }
        function isUsedInFunctionOrInstanceProperty(usage, declaration, container) {
            return !!ts.findAncestor(usage, function (current) {
                if (current === container) {
                    return "quit";
                }
                if (ts.isFunctionLike(current)) {
                    return true;
                }
                
                let initializerOfProperty = current.parent &&
                    current.parent.kind === SyntaxKind.PropertyDeclaration &&
                    current.parent.initializer === current;
                if (initializerOfProperty) {
                    if (ts.hasModifier(current.parent, ModifierFlags.Static)) {
                        if (declaration.kind === SyntaxKind.MethodDeclaration) {
                            return true;
                        }
                    }
                    else {
                        let isDeclarationInstanceProperty = declaration.kind === SyntaxKind.PropertyDeclaration && !ts.hasModifier(declaration, ModifierFlags.Static);
                        if (!isDeclarationInstanceProperty || ts.getContainingClass(usage) !== ts.getContainingClass(declaration)) {
                            return true;
                        }
                    }
                }
            });
        }
    }
    /**
     * Resolve a given name for a given meaning at a given location. An error is reported if the name was not found and
     * the nameNotFoundMessage argument is not undefined. Returns the resolved symbol, or undefined if no symbol with
     * the given name can be found.
     *
     * @param isUse If true, this will count towards --noUnusedLocals / --noUnusedParameters.
     */
    function resolveName(location, name, meaning, nameNotFoundMessage, nameArg, isUse, suggestedNameNotFoundMessage) {
        return resolveNameHelper(location, name, meaning, nameNotFoundMessage, nameArg, isUse, getSymbol, suggestedNameNotFoundMessage);
    }
    function resolveNameHelper(location, name, meaning, nameNotFoundMessage, nameArg, isUse, lookup, suggestedNameNotFoundMessage) {
        let originalLocation = location; // needed for did-you-mean error reporting, which gathers candidates starting from the original location
        let result;
        let lastLocation;
        let lastNonBlockLocation;
        let propertyWithInvalidInitializer;
        let errorLocation = location;
        let grandparent;
        let isInExternalModule = false;
        loop: while (location) {
            // Locals of a source file are not in scope (because they get merged into the global symbol table)
            if (location.locals && !isGlobalSourceFile(location)) {
                if (result = lookup(location.locals, name, meaning)) {
                    let useResult = true;
                    if (ts.isFunctionLike(location) && lastLocation && lastLocation !== location.body) {
                        // symbol lookup restrictions for function-like declarations
                        // - Type parameters of a function are in scope in the entire function declaration, including the parameter
                        //   list and return type. However, local types are only in scope in the function body.
                        // - parameters are only in the scope of function body
                        // This restriction does not apply to JSDoc comment types because they are parented
                        // at a higher level than type parameters would normally be
                        
                        if (meaning & result.flags & SymbolFlags.Type && lastLocation.kind !== SyntaxKind.JSDocComment) {
                            useResult = result.flags & SymbolFlags.TypeParameter
                                // type parameters are visible in parameter list, return type and type parameter list
                                ? lastLocation === location.type ||
                                lastLocation.kind === SyntaxKind.Parameter ||
                                lastLocation.kind === SyntaxKind.TypeParameter
                                // local types not visible outside the function body
                                : false;
                        }
                        if (meaning & SymbolFlags.Value && result.flags & 1 /* FunctionScopedVariable */) {
                            // parameters are visible only inside function body, parameter list and return type
                            // technically for parameter list case here we might mix parameters and variables declared in function,
                            // however it is detected separately when checking initializers of parameters
                            // to make sure that they reference no variables declared after them.
                            useResult =
                                lastLocation.kind === SyntaxKind.Parameter ||
                                (lastLocation === location.type &&
                                    result.valueDeclaration.kind === SyntaxKind.Parameter);
                        }
                    }
                    if (useResult) {
                        break loop;
                    }
                    else {
                        result = undefined;
                    }
                }
            }
            
            switch (location.kind) {
                case SyntaxKind.SourceFile:
                    if (!ts.isExternalOrCommonJsModule(location))
                        break;
                    isInExternalModule = true;
                // falls through
                case SyntaxKind.ModuleDeclaration:
                    let moduleExports = getSymbolOfNode(location).exports;
                    if (location.kind === SyntaxKind.SourceFile || ts.isAmbientModule(location)) {
                        // It's an external module. First see if the module has an export default and if the local
                        // name of that export default matches.
                        if (result = moduleExports.get("default")) {
                            let localSymbol = ts.getLocalSymbolForExportDefault(result);
                            if (localSymbol && (result.flags & meaning) && localSymbol.escapedName === name) {
                                break loop;
                            }
                            result = undefined;
                        }
                        // Because of module/namespace merging, a module's exports are in scope,
                        // yet we never want to treat an export specifier as putting a member in scope.
                        // Therefore, if the name we find is purely an export specifier, it is not actually considered in scope.
                        // Two things to note about this:
                        //     1. We have to check this without calling getSymbol. The problem with calling getSymbol
                        //        on an export specifier is that it might find the export specifier itself, and try to
                        //        resolve it as an alias. This will cause the checker to consider the export specifier
                        //        a circular alias reference when it might not be.
                        //     2. We check === SymbolFlags.Alias in order to check that the symbol is *purely*
                        //        an alias. If we used &, we'd be throwing out symbols that have non alias aspects,
                        //        which is not the desired behavior.
                        let moduleExport = moduleExports.get(name);
                        if (moduleExport &&
                            moduleExport.flags === SymbolFlags.Alias &&
                            ts.getDeclarationOfKind(moduleExport, SyntaxKind.ExportSpecifier)) {
                            break;
                        }
                    }
                    if (result = lookup(moduleExports, name, meaning & 2623475 /* ModuleMember */)) {
                        break loop;
                    }
                    
                    break;
                case SyntaxKind.EnumDeclaration:
                    if (result = lookup(getSymbolOfNode(location).exports, name, meaning & 8 /* EnumMember */)) {
                        break loop;
                    }
                    
                    break;
                case SyntaxKind.PropertyDeclaration:
                case SyntaxKind.PropertySignature:
                    // TypeScript 1.0 spec (April 2014): 8.4.1
                    // Initializer expressions for instance member variables are evaluated in the scope
                    // of the class constructor body but are not permitted to reference parameters or
                    // local variables of the constructor. This effectively means that entities from outer scopes
                    // by the same name as a constructor parameter or local variable are inaccessible
                    // in initializer expressions for instance member variables.
                    if (ts.isClassLike(location.parent) && !ts.hasModifier(location, ModifierFlags.Static)) {
                        let ctor = findConstructorDeclaration(location.parent);
                        if (ctor && ctor.locals) {
                            if (lookup(ctor.locals, name, meaning & SymbolFlags.Value)) {
                                // Remember the property node, it will be used later to report appropriate error
                                propertyWithInvalidInitializer = location;
                            }
                        }
                    }
                    break;
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.ClassExpression:
                case SyntaxKind.InterfaceDeclaration:
                    if (result = lookup(getSymbolOfNode(location).members, name, meaning & SymbolFlags.Type)) {
                        if (!isTypeParameterSymbolDeclaredInContainer(result, location)) {
                            // ignore type parameters not declared in this container
                            result = undefined;
                            break;
                        }
                        if (lastLocation && ts.hasModifier(lastLocation, ModifierFlags.Static)) {
                            // TypeScript 1.0 spec (April 2014): 3.4.1
                            // The scope of a type parameter extends over the entire declaration with which the type
                            // parameter list is associated, with the exception of static member declarations in classes.
                            error(errorLocation, ts.Diagnostics.Static_members_cannot_reference_class_type_parameters);
                            return undefined;
                        }
                        break loop;
                    }
                    if (location.kind === SyntaxKind.ClassExpression && meaning & 32 /* Class */) {
                        let className = location.name;
                        if (className && name === className.escapedText) {
                            result = location.symbol;
                            break loop;
                        }
                    }
                    break;
                case 201 /* ExpressionWithTypeArguments */:
                    // The type parameters of a class are not in scope in the base class expression.
                    if (lastLocation === location.expression && location.parent.token === 85 /* ExtendsKeyword */) {
                        let container = location.parent.parent;
                        if (ts.isClassLike(container) && (result = lookup(getSymbolOfNode(container).members, name, meaning & SymbolFlags.Type))) {
                            if (nameNotFoundMessage) {
                                error(errorLocation, ts.Diagnostics.Base_class_expressions_cannot_reference_class_type_parameters);
                            }
                            return undefined;
                        }
                    }
                    break;
                // It is not legal to reference a class's own type parameters from a computed property name that
                // belongs to the class. For example:
                //
                //   function foo<T>() { return '' }
                //   class C<T> { // <-- Class's own type parameter T
                //       [foo<T>()]() { } // <-- Reference to T from class's own computed property
                //   }
                //
                case 144 /* ComputedPropertyName */:
                    grandparent = location.parent.parent;
                    if (ts.isClassLike(grandparent) || grandparent.kind === SyntaxKind.InterfaceDeclaration) {
                        // A reference to this grandparent's type parameters would be an error
                        if (result = lookup(getSymbolOfNode(grandparent).members, name, meaning & SymbolFlags.Type)) {
                            error(errorLocation, ts.Diagnostics.A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type);
                            return undefined;
                        }
                    }
                    break;
                case SyntaxKind.MethodDeclaration:
                case 150 /* MethodSignature */:
                case 152 /* Constructor */:
                case 153 /* GetAccessor */:
                case 154 /* SetAccessor */:
                case 228 /* FunctionDeclaration */:
                case 187 /* ArrowFunction */:
                    if (meaning & 3 /* Variable */ && name === "arguments") {
                        result = argumentsSymbol;
                        break loop;
                    }
                    break;
                case 186 /* FunctionExpression */:
                    if (meaning & 3 /* Variable */ && name === "arguments") {
                        result = argumentsSymbol;
                        break loop;
                    }
                    if (meaning & 16 /* Function */) {
                        let functionName = location.name;
                        if (functionName && name === functionName.escapedText) {
                            result = location.symbol;
                            break loop;
                        }
                    }
                    break;
                case 147 /* Decorator */:
                    // Decorators are resolved at the class declaration. Resolving at the parameter
                    // or member would result in looking up locals in the method.
                    //
                    //   function y() {}
                    //   class C {
                    //       method(@y x, y) {} // <-- decorator y should be resolved at the class declaration, not the parameter.
                    //   }
                    //
                    if (location.parent && location.parent.kind === SyntaxKind.Parameter) {
                        location = location.parent;
                    }
                    //
                    //   function y() {}
                    //   class C {
                    //       @y method(x, y) {} // <-- decorator y should be resolved at the class declaration, not the method.
                    //   }
                    //
                    if (location.parent && ts.isClassElement(location.parent)) {
                        location = location.parent;
                    }
                    break;
            }
            if (location.kind !== 207 /* Block */) {
                lastNonBlockLocation = location;
            }
            lastLocation = location;
            location = location.parent;
        }
        // We just climbed up parents looking for the name, meaning that we started in a descendant node of `lastLocation`.
        // If `result === lastLocation.symbol`, that means that we are somewhere inside `lastLocation` looking up a name, and resolving to `lastLocation` itself.
        // That means that this is a self-reference of `lastLocation`, and shouldn't count this when considering whether `lastLocation` is used.
        if (isUse && result && nameNotFoundMessage && noUnusedIdentifiers && result !== lastNonBlockLocation.symbol) {
            result.isReferenced = true;
        }
        if (!result) {
            if (lastLocation) {
                ts.Debug.assert(lastLocation.kind === SyntaxKind.SourceFile);
                if (lastLocation.commonJsModuleIndicator && name === "exports") {
                    return lastLocation.symbol;
                }
            }
            result = lookup(globals, name, meaning);
        }
        if (!result) {
            if (nameNotFoundMessage) {
                if (!errorLocation ||
                    !checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) &&
                    !checkAndReportErrorForExtendingInterface(errorLocation) &&
                    !checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) &&
                    !checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) &&
                    !checkAndReportErrorForUsingNamespaceModuleAsValue(errorLocation, name, meaning)) {
                    let suggestion = void 0;
                    if (suggestedNameNotFoundMessage && suggestionCount < maximumSuggestionCount) {
                        suggestion = getSuggestionForNonexistentSymbol(originalLocation, name, meaning);
                        if (suggestion) {
                            error(errorLocation, suggestedNameNotFoundMessage, diagnosticName(nameArg), suggestion);
                        }
                    }
                    if (!suggestion) {
                        error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg));
                    }
                    suggestionCount++;
                }
            }
            return undefined;
        }
        // Perform extra checks only if error reporting was requested
        if (nameNotFoundMessage) {
            if (propertyWithInvalidInitializer) {
                // We have a match, but the reference occurred within a property initializer and the identifier also binds
                // to a local variable in the constructor where the code will be emitted.
                let propertyName = propertyWithInvalidInitializer.name;
                error(errorLocation, ts.Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor, ts.declarationNameToString(propertyName), diagnosticName(nameArg));
                return undefined;
            }
            // Only check for block-scoped variable if we have an error location and are looking for the
            // name with variable meaning
            //      For example,
            //          declare module foo {
            //              interface bar {}
            //          }
            //      const foo/*1*/: foo/*2*/.bar;
            // The foo at /*1*/ and /*2*/ will share same symbol with two meanings:
            // block-scoped variable and namespace module. However, only when we
            // try to resolve name in /*1*/ which is used in variable position,
            // we want to check for block-scoped
            if (errorLocation &&
                (meaning & SymbolFlags.BlockScopedVariable ||
                    ((meaning & 32 /* Class */ || meaning & 384 /* Enum */) && (meaning & SymbolFlags.Value) === SymbolFlags.Value))) {
                let exportOrLocalSymbol = getExportSymbolOfValueSymbolIfExported(result);
                if (exportOrLocalSymbol.flags & SymbolFlags.BlockScopedVariable || exportOrLocalSymbol.flags & 32 /* Class */ || exportOrLocalSymbol.flags & 384 /* Enum */) {
                    checkResolvedBlockScopedVariable(exportOrLocalSymbol, errorLocation);
                }
            }
            // If we're in an external module, we can't reference value symbols created from UMD export declarations
            if (result && isInExternalModule && (meaning & SymbolFlags.Value) === SymbolFlags.Value) {
                let decls = result.declarations;
                if (decls && decls.length === 1 && decls[0].kind === 236 /* NamespaceExportDeclaration */) {
                    error(errorLocation, ts.Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead, ts.unescapeLeadingUnderscores(name));
                }
            }
        }
        return result;
    }
    function diagnosticName(nameArg) {
        return ts.isString(nameArg) ? ts.unescapeLeadingUnderscores(nameArg) : ts.declarationNameToString(nameArg);
    }
    function isTypeParameterSymbolDeclaredInContainer(symbol, container) {
        for (let _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
            let decl = _a[_i];
            if (decl.kind === SyntaxKind.TypeParameter && decl.parent === container) {
                return true;
            }
        }
        return false;
    }
    function checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) {
        if ((errorLocation.kind === 71 /* Identifier */ && (isTypeReferenceIdentifier(errorLocation)) || isInTypeQuery(errorLocation))) {
            return false;
        }
        let container = ts.getThisContainer(errorLocation, /*includeArrowFunctions*/ true);
        let location = container;
        while (location) {
            if (ts.isClassLike(location.parent)) {
                let classSymbol = getSymbolOfNode(location.parent);
                if (!classSymbol) {
                    break;
                }
                // Check to see if a static member exists.
                let constructorType = getTypeOfSymbol(classSymbol);
                if (getPropertyOfType(constructorType, name)) {
                    error(errorLocation, ts.Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0, diagnosticName(nameArg), symbolToString(classSymbol));
                    return true;
                }
                // No static member is present.
                // Check if we're in an instance method and look for a relevant instance member.
                if (location === container && !ts.hasModifier(location, ModifierFlags.Static)) {
                    let instanceType = getDeclaredTypeOfSymbol(classSymbol).thisType;
                    if (getPropertyOfType(instanceType, name)) {
                        error(errorLocation, ts.Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0, diagnosticName(nameArg));
                        return true;
                    }
                }
            }
            location = location.parent;
        }
        return false;
    }
    function checkAndReportErrorForExtendingInterface(errorLocation) {
        let expression = getEntityNameForExtendingInterface(errorLocation);
        let isError = !!(expression && resolveEntityName(expression, 64 /* Interface */, /*ignoreErrors*/ true));
        if (isError) {
            error(errorLocation, ts.Diagnostics.Cannot_extend_an_interface_0_Did_you_mean_implements, ts.getTextOfNode(expression));
        }
        return isError;
    }
    /**
     * Climbs up parents to an ExpressionWithTypeArguments, and returns its expression,
     * but returns undefined if that expression is not an EntityNameExpression.
     */
    function getEntityNameForExtendingInterface(node) {
        switch (node.kind) {
            case 71 /* Identifier */:
            case 179 /* PropertyAccessExpression */:
                return node.parent ? getEntityNameForExtendingInterface(node.parent) : undefined;
            case 201 /* ExpressionWithTypeArguments */:
                if (ts.isEntityNameExpression(node.expression)) {
                    return node.expression;
                }
            // falls through
            default:
                return undefined;
        }
    }
    function checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) {
        if (meaning === SymbolFlags.Namespace) {
            let symbol = resolveSymbol(resolveName(errorLocation, name, SymbolFlags.Type & ~SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ false));
            let parent = errorLocation.parent;
            if (symbol) {
                if (ts.isQualifiedName(parent)) {
                    ts.Debug.assert(parent.left === errorLocation, "Should only be resolving left side of qualified name as a namespace");
                    let propName = parent.right.escapedText;
                    let propType = getPropertyOfType(getDeclaredTypeOfSymbol(symbol), propName);
                    if (propType) {
                        error(parent, ts.Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, ts.unescapeLeadingUnderscores(name), ts.unescapeLeadingUnderscores(propName));
                        return true;
                    }
                }
                error(errorLocation, ts.Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here, ts.unescapeLeadingUnderscores(name));
                return true;
            }
        }
        return false;
    }
    function checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) {
        if (meaning & (SymbolFlags.Value & ~SymbolFlags.NamespaceModule)) {
            if (name === "any" || name === "string" || name === "number" || name === "boolean" || name === "never") {
                error(errorLocation, ts.Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, ts.unescapeLeadingUnderscores(name));
                return true;
            }
            let symbol = resolveSymbol(resolveName(errorLocation, name, SymbolFlags.Type & ~SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ false));
            if (symbol && !(symbol.flags & SymbolFlags.NamespaceModule)) {
                error(errorLocation, ts.Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, ts.unescapeLeadingUnderscores(name));
                return true;
            }
        }
        return false;
    }
    function checkAndReportErrorForUsingNamespaceModuleAsValue(errorLocation, name, meaning) {
        if (meaning & (SymbolFlags.Value & ~SymbolFlags.NamespaceModule & ~SymbolFlags.Type)) {
            let symbol = resolveSymbol(resolveName(errorLocation, name, SymbolFlags.NamespaceModule & ~SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ false));
            if (symbol) {
                error(errorLocation, ts.Diagnostics.Cannot_use_namespace_0_as_a_value, ts.unescapeLeadingUnderscores(name));
                return true;
            }
        }
        else if (meaning & (SymbolFlags.Type & ~SymbolFlags.NamespaceModule & ~SymbolFlags.Value)) {
            let symbol = resolveSymbol(resolveName(errorLocation, name, SymbolFlags.NamespaceModule & ~SymbolFlags.Type, /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ false));
            if (symbol) {
                error(errorLocation, ts.Diagnostics.Cannot_use_namespace_0_as_a_type, ts.unescapeLeadingUnderscores(name));
                return true;
            }
        }
        return false;
    }
    function checkResolvedBlockScopedVariable(result, errorLocation) {
        ts.Debug.assert(!!(result.flags & SymbolFlags.BlockScopedVariable || result.flags & 32 /* Class */ || result.flags & 384 /* Enum */));
        // Block-scoped variables cannot be used before their definition
        let declaration = ts.forEach(result.declarations, function (d) { return ts.isBlockOrCatchScoped(d) || ts.isClassLike(d) || (d.kind === SyntaxKind.EnumDeclaration) ? d : undefined; });
        ts.Debug.assert(declaration !== undefined, "Declaration to checkResolvedBlockScopedVariable is undefined");
        if (!ts.isInAmbientContext(declaration) && !isBlockScopedNameDeclaredBeforeUse(declaration, errorLocation)) {
            if (result.flags & SymbolFlags.BlockScopedVariable) {
                error(errorLocation, ts.Diagnostics.Block_scoped_variable_0_used_before_its_declaration, ts.declarationNameToString(ts.getNameOfDeclaration(declaration)));
            }
            else if (result.flags & 32 /* Class */) {
                error(errorLocation, ts.Diagnostics.Class_0_used_before_its_declaration, ts.declarationNameToString(ts.getNameOfDeclaration(declaration)));
            }
            else if (result.flags & 256 /* RegularEnum */) {
                error(errorLocation, ts.Diagnostics.Enum_0_used_before_its_declaration, ts.declarationNameToString(ts.getNameOfDeclaration(declaration)));
            }
        }
    }
    /* Starting from 'initial' node walk up the parent chain until 'stopAt' node is reached.
     * If at any point current node is equal to 'parent' node - return true.
     * Return false if 'stopAt' node is reached or isFunctionLike(current) === true.
     */
    function isSameScopeDescendentOf(initial, parent, stopAt) {
        return parent && !!ts.findAncestor(initial, function (n) { return n === stopAt || ts.isFunctionLike(n) ? "quit" : n === parent; });
    }
    function getAnyImportSyntax(node) {
        switch (node.kind) {
            case 237 /* ImportEqualsDeclaration */:
                return node;
            case 239 /* ImportClause */:
                return node.parent;
            case 240 /* NamespaceImport */:
                return node.parent.parent;
            case 242 /* ImportSpecifier */:
                return node.parent.parent.parent;
            default:
                return undefined;
        }
    }
    function getDeclarationOfAliasSymbol(symbol) {
        return ts.find(symbol.declarations, ts.isAliasSymbolDeclaration);
    }
    function getTargetOfImportEqualsDeclaration(node, dontResolveAlias) {
        if (node.moduleReference.kind === 248 /* ExternalModuleReference */) {
            return resolveExternalModuleSymbol(resolveExternalModuleName(node, ts.getExternalModuleImportEqualsDeclarationExpression(node)));
        }
        return getSymbolOfPartOfRightHandSideOfImportEquals(node.moduleReference, dontResolveAlias);
    }
    function getTargetOfImportClause(node, dontResolveAlias) {
        let moduleSymbol = resolveExternalModuleName(node, node.parent.moduleSpecifier);
        if (moduleSymbol) {
            let exportDefaultSymbol = void 0;
            if (ts.isShorthandAmbientModuleSymbol(moduleSymbol)) {
                exportDefaultSymbol = moduleSymbol;
            }
            else {
                let exportValue = moduleSymbol.exports.get("export=");
                exportDefaultSymbol = exportValue
                    ? getPropertyOfType(getTypeOfSymbol(exportValue), "default")
                    : resolveSymbol(moduleSymbol.exports.get("default"), dontResolveAlias);
            }
            if (!exportDefaultSymbol && !allowSyntheticDefaultImports) {
                error(node.name, ts.Diagnostics.Module_0_has_no_default_export, symbolToString(moduleSymbol));
            }
            else if (!exportDefaultSymbol && allowSyntheticDefaultImports) {
                return resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias);
            }
            return exportDefaultSymbol;
        }
    }
    function getTargetOfNamespaceImport(node, dontResolveAlias) {
        let moduleSpecifier = node.parent.parent.moduleSpecifier;
        return resolveESModuleSymbol(resolveExternalModuleName(node, moduleSpecifier), moduleSpecifier, dontResolveAlias);
    }
    // This function creates a synthetic symbol that combines the value side of one symbol with the
    // type/namespace side of another symbol. Consider this example:
    //
    //   declare module graphics {
    //       interface Point {
    //           x: number;
    //           y: number;
    //       }
    //   }
    //   declare let graphics: {
    //       Point: new (x: number, y: number) => graphics.Point;
    //   }
    //   declare module "graphics" {
    //       export = graphics;
    //   }
    //
    // An 'import { Point } from "graphics"' needs to create a symbol that combines the value side 'Point'
    // property with the type/namespace side interface 'Point'.
    function combineValueAndTypeSymbols(valueSymbol, typeSymbol) {
        if (valueSymbol === unknownSymbol && typeSymbol === unknownSymbol) {
            return unknownSymbol;
        }
        if (valueSymbol.flags & (SymbolFlags.Type | SymbolFlags.Namespace)) {
            return valueSymbol;
        }
        let result = createSymbol(valueSymbol.flags | typeSymbol.flags, valueSymbol.escapedName);
        result.declarations = ts.concatenate(valueSymbol.declarations, typeSymbol.declarations);
        result.parent = valueSymbol.parent || typeSymbol.parent;
        if (valueSymbol.valueDeclaration)
            result.valueDeclaration = valueSymbol.valueDeclaration;
        if (typeSymbol.members)
            result.members = typeSymbol.members;
        if (valueSymbol.exports)
            result.exports = valueSymbol.exports;
        return result;
    }
    function getExportOfModule(symbol, name, dontResolveAlias) {
        if (symbol.flags & 1536 /* Module */) {
            return resolveSymbol(getExportsOfSymbol(symbol).get(name), dontResolveAlias);
        }
    }
    function getPropertyOfVariable(symbol, name) {
        if (symbol.flags & 3 /* Variable */) {
            let typeAnnotation = symbol.valueDeclaration.type;
            if (typeAnnotation) {
                return resolveSymbol(getPropertyOfType(getTypeFromTypeNode(typeAnnotation), name));
            }
        }
    }
    function getExternalModuleMember(node, specifier, dontResolveAlias) {
        let moduleSymbol = resolveExternalModuleName(node, node.moduleSpecifier);
        let targetSymbol = resolveESModuleSymbol(moduleSymbol, node.moduleSpecifier, dontResolveAlias);
        if (targetSymbol) {
            let name = specifier.propertyName || specifier.name;
            if (name.escapedText) {
                if (ts.isShorthandAmbientModuleSymbol(moduleSymbol)) {
                    return moduleSymbol;
                }
                let symbolFromVariable = void 0;
                // First check if module was specified with "export=". If so, get the member from the resolved type
                if (moduleSymbol && moduleSymbol.exports && moduleSymbol.exports.get("export=")) {
                    symbolFromVariable = getPropertyOfType(getTypeOfSymbol(targetSymbol), name.escapedText);
                }
                else {
                    symbolFromVariable = getPropertyOfVariable(targetSymbol, name.escapedText);
                }
                // if symbolFromVariable is export - get its final target
                symbolFromVariable = resolveSymbol(symbolFromVariable, dontResolveAlias);
                let symbolFromModule = getExportOfModule(targetSymbol, name.escapedText, dontResolveAlias);
                // If the export member we're looking for is default, and there is no real default but allowSyntheticDefaultImports is on, return the entire module as the default
                if (!symbolFromModule && allowSyntheticDefaultImports && name.escapedText === "default") {
                    symbolFromModule = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias);
                }
                let symbol = symbolFromModule && symbolFromVariable ?
                    combineValueAndTypeSymbols(symbolFromVariable, symbolFromModule) :
                    symbolFromModule || symbolFromVariable;
                if (!symbol) {
                    error(name, ts.Diagnostics.Module_0_has_no_exported_member_1, getFullyQualifiedName(moduleSymbol), ts.declarationNameToString(name));
                }
                return symbol;
            }
        }
    }
    function getTargetOfImportSpecifier(node, dontResolveAlias) {
        return getExternalModuleMember(node.parent.parent.parent, node, dontResolveAlias);
    }
    function getTargetOfNamespaceExportDeclaration(node, dontResolveAlias) {
        return resolveExternalModuleSymbol(node.parent.symbol, dontResolveAlias);
    }
    function getTargetOfExportSpecifier(node, meaning, dontResolveAlias) {
        return node.parent.parent.moduleSpecifier ?
            getExternalModuleMember(node.parent.parent, node, dontResolveAlias) :
            resolveEntityName(node.propertyName || node.name, meaning, /*ignoreErrors*/ false, dontResolveAlias);
    }
    function getTargetOfExportAssignment(node, dontResolveAlias) {
        return resolveEntityName(node.expression, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, /*ignoreErrors*/ false, dontResolveAlias);
    }
    function getTargetOfAliasDeclaration(node, dontRecursivelyResolve) {
        switch (node.kind) {
            case 237 /* ImportEqualsDeclaration */:
                return getTargetOfImportEqualsDeclaration(node, dontRecursivelyResolve);
            case 239 /* ImportClause */:
                return getTargetOfImportClause(node, dontRecursivelyResolve);
            case 240 /* NamespaceImport */:
                return getTargetOfNamespaceImport(node, dontRecursivelyResolve);
            case 242 /* ImportSpecifier */:
                return getTargetOfImportSpecifier(node, dontRecursivelyResolve);
            case SyntaxKind.ExportSpecifier:
                return getTargetOfExportSpecifier(node, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, dontRecursivelyResolve);
            case SyntaxKind.ExportAssignment:
                return getTargetOfExportAssignment(node, dontRecursivelyResolve);
            case 236 /* NamespaceExportDeclaration */:
                return getTargetOfNamespaceExportDeclaration(node, dontRecursivelyResolve);
        }
    }
    /**
     * Indicates that a symbol is an alias that does not merge with a local declaration.
     */
    function isNonLocalAlias(symbol, excludes) {
        if (excludes === void 0) { excludes = SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace; }
        return symbol && (symbol.flags & (SymbolFlags.Alias | excludes)) === SymbolFlags.Alias;
    }
    function resolveSymbol(symbol, dontResolveAlias) {
        let shouldResolve = !dontResolveAlias && isNonLocalAlias(symbol);
        return shouldResolve ? resolveAlias(symbol) : symbol;
    }
    function resolveAlias(symbol) {
        ts.Debug.assert((symbol.flags & SymbolFlags.Alias) !== 0, "Should only get Alias here.");
        let links = getSymbolLinks(symbol);
        if (!links.target) {
            links.target = resolvingSymbol;
            let node = getDeclarationOfAliasSymbol(symbol);
            ts.Debug.assert(!!node);
            let target = getTargetOfAliasDeclaration(node);
            if (links.target === resolvingSymbol) {
                links.target = target || unknownSymbol;
            }
            else {
                error(node, ts.Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol));
            }
        }
        else if (links.target === resolvingSymbol) {
            links.target = unknownSymbol;
        }
        return links.target;
    }
    function markExportAsReferenced(node) {
        let symbol = getSymbolOfNode(node);
        let target = resolveAlias(symbol);
        if (target) {
            let markAlias = target === unknownSymbol ||
                ((target.flags & SymbolFlags.Value) && !isConstEnumOrConstEnumOnlyModule(target));
            if (markAlias) {
                markAliasSymbolAsReferenced(symbol);
            }
        }
    }
    // When an alias symbol is referenced, we need to mark the entity it references as referenced and in turn repeat that until
    // we reach a non-alias or an exported entity (which is always considered referenced). We do this by checking the target of
    // the alias as an expression (which recursively takes us back here if the target references another alias).
    function markAliasSymbolAsReferenced(symbol) {
        let links = getSymbolLinks(symbol);
        if (!links.referenced) {
            links.referenced = true;
            let node = getDeclarationOfAliasSymbol(symbol);
            ts.Debug.assert(!!node);
            if (node.kind === SyntaxKind.ExportAssignment) {
                // export default <symbol>
                checkExpressionCached(node.expression);
            }
            else if (node.kind === SyntaxKind.ExportSpecifier) {
                // export { <symbol> } or export { <symbol> as foo }
                checkExpressionCached(node.propertyName || node.name);
            }
            else if (ts.isInternalModuleImportEqualsDeclaration(node)) {
                // import foo = <symbol>
                checkExpressionCached(node.moduleReference);
            }
        }
    }
    // This function is only for imports with entity names
    function getSymbolOfPartOfRightHandSideOfImportEquals(entityName, dontResolveAlias) {
        // There are three things we might try to look for. In the following examples,
        // the search term is enclosed in |...|:
        //
        //     import a = |b|; // Namespace
        //     import a = |b.c|; // Value, type, namespace
        //     import a = |b.c|.d; // Namespace
        if (entityName.kind === 71 /* Identifier */ && ts.isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {
            entityName = entityName.parent;
        }
        // Check for case 1 and 3 in the above example
        if (entityName.kind === 71 /* Identifier */ || entityName.parent.kind === 143 /* QualifiedName */) {
            return resolveEntityName(entityName, SymbolFlags.Namespace, /*ignoreErrors*/ false, dontResolveAlias);
        }
        else {
            // Case 2 in above example
            // entityName.kind could be a QualifiedName or a Missing identifier
            ts.Debug.assert(entityName.parent.kind === 237 /* ImportEqualsDeclaration */);
            return resolveEntityName(entityName, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, /*ignoreErrors*/ false, dontResolveAlias);
        }
    }
    function getFullyQualifiedName(symbol) {
        return symbol.parent ? getFullyQualifiedName(symbol.parent) + "." + symbolToString(symbol) : symbolToString(symbol);
    }
    /**
     * Resolves a qualified name and any involved aliases.
     */
    function resolveEntityName(name, meaning, ignoreErrors, dontResolveAlias, location) {
        if (ts.nodeIsMissing(name)) {
            return undefined;
        }
        let symbol;
        if (name.kind === 71 /* Identifier */) {
            let message = meaning === SymbolFlags.Namespace ? ts.Diagnostics.Cannot_find_namespace_0 : ts.Diagnostics.Cannot_find_name_0;
            symbol = resolveName(location || name, name.escapedText, meaning, ignoreErrors ? undefined : message, name, /*isUse*/ true);
            if (!symbol) {
                return undefined;
            }
        }
        else if (name.kind === 143 /* QualifiedName */ || name.kind === 179 /* PropertyAccessExpression */) {
            let left = void 0;
            if (name.kind === 143 /* QualifiedName */) {
                left = name.left;
            }
            else if (name.kind === 179 /* PropertyAccessExpression */ &&
                (name.expression.kind === 185 /* ParenthesizedExpression */ || ts.isEntityNameExpression(name.expression))) {
                left = name.expression;
            }
            else {
                // If the expression in property-access expression is not entity-name or parenthsizedExpression (e.g. it is a call expression), it won't be able to successfully resolve the name.
                // This is the case when we are trying to do any language service operation in heritage clauses. By return undefined, the getSymbolOfEntityNameOrPropertyAccessExpression
                // will attempt to checkPropertyAccessExpression to resolve symbol.
                // i.e class C extends foo()./*do language service operation here*/B {}
                return undefined;
            }
            let right = name.kind === 143 /* QualifiedName */ ? name.right : name.name;
            let namespace = resolveEntityName(left, SymbolFlags.Namespace, ignoreErrors, /*dontResolveAlias*/ false, location);
            if (!namespace || ts.nodeIsMissing(right)) {
                return undefined;
            }
            else if (namespace === unknownSymbol) {
                return namespace;
            }
            symbol = getSymbol(getExportsOfSymbol(namespace), right.escapedText, meaning);
            if (!symbol) {
                if (!ignoreErrors) {
                    error(right, ts.Diagnostics.Namespace_0_has_no_exported_member_1, getFullyQualifiedName(namespace), ts.declarationNameToString(right));
                }
                return undefined;
            }
        }
        else if (name.kind === 185 /* ParenthesizedExpression */) {
            // If the expression in parenthesizedExpression is not an entity-name (e.g. it is a call expression), it won't be able to successfully resolve the name.
            // This is the case when we are trying to do any language service operation in heritage clauses.
            // By return undefined, the getSymbolOfEntityNameOrPropertyAccessExpression will attempt to checkPropertyAccessExpression to resolve symbol.
            // i.e class C extends foo()./*do language service operation here*/B {}
            return ts.isEntityNameExpression(name.expression) ?
                resolveEntityName(name.expression, meaning, ignoreErrors, dontResolveAlias, location) :
                undefined;
        }
        else {
            ts.Debug.assertNever(name, "Unknown entity name kind.");
        }
        ts.Debug.assert((ts.getCheckFlags(symbol) & CheckFlags.Instantiated) === 0, "Should never get an instantiated symbol here.");
        return (symbol.flags & meaning) || dontResolveAlias ? symbol : resolveAlias(symbol);
    }
    function resolveExternalModuleName(location, moduleReferenceExpression) {
        return resolveExternalModuleNameWorker(location, moduleReferenceExpression, ts.Diagnostics.Cannot_find_module_0);
    }
    function resolveExternalModuleNameWorker(location, moduleReferenceExpression, moduleNotFoundError, isForAugmentation) {
        if (isForAugmentation === void 0) { isForAugmentation = false; }
        if (moduleReferenceExpression.kind !== 9 /* StringLiteral */ && moduleReferenceExpression.kind !== 13 /* NoSubstitutionTemplateLiteral */) {
            return;
        }
        let moduleReferenceLiteral = moduleReferenceExpression;
        return resolveExternalModule(location, moduleReferenceLiteral.text, moduleNotFoundError, moduleReferenceLiteral, isForAugmentation);
    }
    function resolveExternalModule(location, moduleReference, moduleNotFoundError, errorNode, isForAugmentation) {
        if (isForAugmentation === void 0) { isForAugmentation = false; }
        if (moduleReference === undefined) {
            return;
        }
        if (ts.startsWith(moduleReference, "@types/")) {
            let diag = ts.Diagnostics.Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1;
            let withoutAtTypePrefix = ts.removePrefix(moduleReference, "@types/");
            error(errorNode, diag, withoutAtTypePrefix, moduleReference);
        }
        let ambientModule = tryFindAmbientModule(moduleReference, /*withAugmentations*/ true);
        if (ambientModule) {
            return ambientModule;
        }
        let resolvedModule = ts.getResolvedModule(ts.getSourceFileOfNode(location), moduleReference);
        let resolutionDiagnostic = resolvedModule && ts.getResolutionDiagnostic(compilerOptions, resolvedModule);
        let sourceFile = resolvedModule && !resolutionDiagnostic && thing.getSourceFile(resolvedModule.resolvedFileName);
        if (sourceFile) {
            if (sourceFile.symbol) {
                // merged symbol is module declaration symbol combined with all augmentations
                return getMergedSymbol(sourceFile.symbol);
            }
            if (moduleNotFoundError) {
                // report errors only if it was requested
                error(errorNode, ts.Diagnostics.File_0_is_not_a_module, sourceFile.fileName);
            }
            return undefined;
        }
        if (patternAmbientModules) {
            let pattern = ts.findBestPatternMatch(patternAmbientModules, function (_) { return _.pattern; }, moduleReference);
            if (pattern) {
                return getMergedSymbol(pattern.symbol);
            }
        }
        // May be an untyped module. If so, ignore resolutionDiagnostic.
        if (resolvedModule && !ts.extensionIsTypeScript(resolvedModule.extension) && resolutionDiagnostic === undefined || resolutionDiagnostic === ts.Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type) {
            if (isForAugmentation) {
                let diag = ts.Diagnostics.Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented;
                error(errorNode, diag, moduleReference, resolvedModule.resolvedFileName);
            }
            else if (noImplicitAny && moduleNotFoundError) {
                let errorInfo = !resolvedModule.isExternalLibraryImport ? undefined : ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Try_npm_install_types_Slash_0_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0, moduleReference);
                errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type, moduleReference, resolvedModule.resolvedFileName);
                diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(errorNode, errorInfo));
            }
            // Failed imports and untyped modules are both treated in an untyped manner; only difference is whether we give a diagnostic first.
            return undefined;
        }
        if (moduleNotFoundError) {
            // report errors only if it was requested
            if (resolutionDiagnostic) {
                error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName);
            }
            else {
                let tsExtension = ts.tryExtractTypeScriptExtension(moduleReference);
                if (tsExtension) {
                    let diag = ts.Diagnostics.An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead;
                    error(errorNode, diag, tsExtension, ts.removeExtension(moduleReference, tsExtension));
                }
                else {
                    error(errorNode, moduleNotFoundError, moduleReference);
                }
            }
        }
        return undefined;
    }
    // An external module with an 'export =' declaration resolves to the target of the 'export =' declaration,
    // and an external module with no 'export =' declaration resolves to the module itself.
    function resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) {
        return moduleSymbol && getMergedSymbol(resolveSymbol(moduleSymbol.exports.get("export=" /* ExportEquals */), dontResolveAlias)) || moduleSymbol;
    }
    // An external module with an 'export =' declaration may be referenced as an ES6 module provided the 'export ='
    // references a symbol that is at least declared as a module or a variable. The target of the 'export =' may
    // combine other declarations with the module or variable (e.g. a class/module, function/module, interface/variable).
    function resolveESModuleSymbol(moduleSymbol, moduleReferenceExpression, dontResolveAlias) {
        let symbol = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias);
        if (!dontResolveAlias && symbol && !(symbol.flags & (1536 /* Module */ | 3 /* Variable */))) {
            error(moduleReferenceExpression, ts.Diagnostics.Module_0_resolves_to_a_non_module_entity_and_cannot_be_imported_using_this_construct, symbolToString(moduleSymbol));
        }
        return symbol;
    }
    function hasExportAssignmentSymbol(moduleSymbol) {
        return moduleSymbol.exports.get("export=" /* ExportEquals */) !== undefined;
    }
    function getExportsOfModuleAsArray(moduleSymbol) {
        return symbolsToArray(getExportsOfModule(moduleSymbol));
    }
    function getExportsAndPropertiesOfModule(moduleSymbol) {
        let exports = getExportsOfModuleAsArray(moduleSymbol);
        let exportEquals = resolveExternalModuleSymbol(moduleSymbol);
        if (exportEquals !== moduleSymbol) {
            ts.addRange(exports, getPropertiesOfType(getTypeOfSymbol(exportEquals)));
        }
        return exports;
    }
    function tryGetMemberInModuleExports(memberName, moduleSymbol) {
        let symbolTable = getExportsOfModule(moduleSymbol);
        if (symbolTable) {
            return symbolTable.get(memberName);
        }
    }
    function tryGetMemberInModuleExportsAndProperties(memberName, moduleSymbol) {
        let symbol = tryGetMemberInModuleExports(memberName, moduleSymbol);
        if (!symbol) {
            let exportEquals = resolveExternalModuleSymbol(moduleSymbol);
            if (exportEquals !== moduleSymbol) {
                return getPropertyOfType(getTypeOfSymbol(exportEquals), memberName);
            }
        }
        return symbol;
    }
    function getExportsOfSymbol(symbol) {
        return symbol.flags & 1536 /* Module */ ? getExportsOfModule(symbol) : symbol.exports || emptySymbols;
    }
    function getExportsOfModule(moduleSymbol) {
        let links = getSymbolLinks(moduleSymbol);
        return links.resolvedExports || (links.resolvedExports = getExportsOfModuleWorker(moduleSymbol));
    }
    /**
     * Extends one symbol table with another while collecting information on name collisions for error message generation into the `lookupTable` argument
     * Not passing `lookupTable` and `exportNode` disables this collection, and just extends the tables
     */
    function extendExportSymbols(target, source, lookupTable, exportNode) {
        source && source.forEach(function (sourceSymbol, id) {
            if (id === "default")
                return;
            let targetSymbol = target.get(id);
            if (!targetSymbol) {
                target.set(id, sourceSymbol);
                if (lookupTable && exportNode) {
                    lookupTable.set(id, {
                        specifierText: ts.getTextOfNode(exportNode.moduleSpecifier)
                    });
                }
            }
            else if (lookupTable && exportNode && targetSymbol && resolveSymbol(targetSymbol) !== resolveSymbol(sourceSymbol)) {
                let collisionTracker = lookupTable.get(id);
                if (!collisionTracker.exportsWithDuplicate) {
                    collisionTracker.exportsWithDuplicate = [exportNode];
                }
                else {
                    collisionTracker.exportsWithDuplicate.push(exportNode);
                }
            }
        });
    }
    function getExportsOfModuleWorker(moduleSymbol) {
        let visitedSymbols = [];
        // A module defined by an 'export=' consists on one export that needs to be resolved
        moduleSymbol = resolveExternalModuleSymbol(moduleSymbol);
        return visit(moduleSymbol) || emptySymbols;
        // The ES6 spec permits export * declarations in a module to circularly reference the module itself. For example,
        // module 'a' can 'export * from "b"' and 'b' can 'export * from "a"' without error.
        function visit(symbol) {
            if (!(symbol && symbol.flags & 1952 /* HasExports */ && ts.pushIfUnique(visitedSymbols, symbol))) {
                return;
            }
            let symbols = ts.cloneMap(symbol.exports);
            // All export * declarations are collected in an __export symbol by the binder
            let exportStars = symbol.exports.get("__export" /* ExportStar */);
            if (exportStars) {
                let nestedSymbols = ts.createSymbolTable();
                let lookupTable_1 = ts.createMap();
                for (let _i = 0, _a = exportStars.declarations; _i < _a.length; _i++) {
                    let node = _a[_i];
                    let resolvedModule = resolveExternalModuleName(node, node.moduleSpecifier);
                    let exportedSymbols = visit(resolvedModule);
                    extendExportSymbols(nestedSymbols, exportedSymbols, lookupTable_1, node);
                }
                lookupTable_1.forEach(function (_a, id) {
                    let exportsWithDuplicate = _a.exportsWithDuplicate;
                    // It's not an error if the file with multiple `export *`s with duplicate names exports a member with that name itself
                    if (id === "export=" || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols.has(id)) {
                        return;
                    }
                    for (let _i = 0, exportsWithDuplicate_1 = exportsWithDuplicate; _i < exportsWithDuplicate_1.length; _i++) {
                        let node = exportsWithDuplicate_1[_i];
                        diagnostics.add(ts.createDiagnosticForNode(node, ts.Diagnostics.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity, lookupTable_1.get(id).specifierText, ts.unescapeLeadingUnderscores(id)));
                    }
                });
                extendExportSymbols(symbols, nestedSymbols);
            }
            return symbols;
        }
    }
    function getMergedSymbol(symbol) {
        let merged;
        return symbol && symbol.mergeId && (merged = mergedSymbols[symbol.mergeId]) ? merged : symbol;
    }
    function getSymbolOfNode(node) {
        return getMergedSymbol(node.symbol);
    }
    function getParentOfSymbol(symbol) {
        return getMergedSymbol(symbol.parent);
    }
    function getExportSymbolOfValueSymbolIfExported(symbol) {
        return symbol && (symbol.flags & 1048576 /* ExportValue */) !== 0
            ? getMergedSymbol(symbol.exportSymbol)
            : symbol;
    }
    function symbolIsValue(symbol) {
        return !!(symbol.flags & SymbolFlags.Value || symbol.flags & SymbolFlags.Alias && resolveAlias(symbol).flags & SymbolFlags.Value);
    }
    function findConstructorDeclaration(node) {
        let members = node.members;
        for (let _i = 0, members_2 = members; _i < members_2.length; _i++) {
            let member = members_2[_i];
            if (member.kind === 152 /* Constructor */ && ts.nodeIsPresent(member.body)) {
                return member;
            }
        }
    }
    function createType(flags) {
        let result = new Type(checker, flags);
        typeCount++;
        result.id = typeCount;
        return result;
    }
    function createIntrinsicType(kind, intrinsicName) {
        let type = createType(kind);
        type.intrinsicName = intrinsicName;
        return type;
    }
    function createBooleanType(trueFalseTypes) {
        let type = getUnionType(trueFalseTypes);
        type.flags |= 8 /* Boolean */;
        type.intrinsicName = "boolean";
        return type;
    }
    function createObjectType(objectFlags, symbol) {
        let type = createType(TypeFlags.Object);
        type.objectFlags = objectFlags;
        type.symbol = symbol;
        return type;
    }
    function createTypeofType() {
        return getUnionType(ts.arrayFrom(typeofEQFacts.keys(), getLiteralType));
    }
    // A reserved member name starts with two underscores, but the third character cannot be an underscore
    // or the @ symbol. A third underscore indicates an escaped form of an identifer that started
    // with at least two underscores. The @ character indicates that the name is denoted by a well known ES
    // Symbol instance.
    function isReservedMemberName(name) {
        return name.charCodeAt(0) === 95 /* _ */ &&
            name.charCodeAt(1) === 95 /* _ */ &&
            name.charCodeAt(2) !== 95 /* _ */ &&
            name.charCodeAt(2) !== 64 /* at */;
    }
    function getNamedMembers(members) {
        let result;
        members.forEach(function (symbol, id) {
            if (!isReservedMemberName(id)) {
                if (!result)
                    result = [];
                if (symbolIsValue(symbol)) {
                    result.push(symbol);
                }
            }
        });
        return result || ts.emptyArray;
    }
    function setStructuredTypeMembers(type, members, callSignatures, constructSignatures, stringIndexInfo, numberIndexInfo) {
        type.members = members;
        type.properties = getNamedMembers(members);
        type.callSignatures = callSignatures;
        type.constructSignatures = constructSignatures;
        if (stringIndexInfo)
            type.stringIndexInfo = stringIndexInfo;
        if (numberIndexInfo)
            type.numberIndexInfo = numberIndexInfo;
        return type;
    }
    function createAnonymousType(symbol, members, callSignatures, constructSignatures, stringIndexInfo, numberIndexInfo) {
        return setStructuredTypeMembers(createObjectType(16 /* Anonymous */, symbol), members, callSignatures, constructSignatures, stringIndexInfo, numberIndexInfo);
    }
    function forEachSymbolTableInScope(enclosingDeclaration, callback) {
        let result;
        for (let location = enclosingDeclaration; location; location = location.parent) {
            // Locals of a source file are not in scope (because they get merged into the global symbol table)
            if (location.locals && !isGlobalSourceFile(location)) {
                if (result = callback(location.locals)) {
                    return result;
                }
            }
            switch (location.kind) {
                case SyntaxKind.SourceFile:
                    if (!ts.isExternalOrCommonJsModule(location)) {
                        break;
                    }
                // falls through
                case SyntaxKind.ModuleDeclaration:
                    if (result = callback(getSymbolOfNode(location).exports)) {
                        return result;
                    }
                    break;
            }
        }
        return callback(globals);
    }
    function getQualifiedLeftMeaning(rightMeaning) {
        // If we are looking in value space, the parent meaning is value, other wise it is namespace
        return rightMeaning === SymbolFlags.Value ? SymbolFlags.Value : SymbolFlags.Namespace;
    }
    function getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, useOnlyExternalAliasing) {
        if (!(symbol && !isPropertyOrMethodDeclarationSymbol(symbol))) {
            return undefined;
        }
        let visitedSymbolTables = [];
        return forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable);
        function getAccessibleSymbolChainFromSymbolTable(symbols) {
            if (!ts.pushIfUnique(visitedSymbolTables, symbols)) {
                return undefined;
            }
            let result = trySymbolTable(symbols);
            visitedSymbolTables.pop();
            return result;
        }
        function canQualifySymbol(symbolFromSymbolTable, meaning) {
            // If the symbol is equivalent and doesn't need further qualification, this symbol is accessible
            return !needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning) ||
                // If symbol needs qualification, make sure that parent is accessible, if it is then this symbol is accessible too
                !!getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, getQualifiedLeftMeaning(meaning), useOnlyExternalAliasing);
        }
        function isAccessible(symbolFromSymbolTable, resolvedAliasSymbol) {
            return symbol === (resolvedAliasSymbol || symbolFromSymbolTable) &&
                // if the symbolFromSymbolTable is not external module (it could be if it was determined as ambient external module and would be in globals table)
                // and if symbolFromSymbolTable or alias resolution matches the symbol,
                // check the symbol can be qualified, it is only then this symbol is accessible
                !ts.some(symbolFromSymbolTable.declarations, hasExternalModuleSymbol) &&
                canQualifySymbol(symbolFromSymbolTable, meaning);
        }
        function isUMDExportSymbol(symbol) {
            return symbol && symbol.declarations && symbol.declarations[0] && ts.isNamespaceExportDeclaration(symbol.declarations[0]);
        }
        function trySymbolTable(symbols) {
            // If symbol is directly available by its name in the symbol table
            if (isAccessible(symbols.get(symbol.escapedName))) {
                return [symbol];
            }
            // Check if symbol is any of the alias
            return ts.forEachEntry(symbols, function (symbolFromSymbolTable) {
                if (symbolFromSymbolTable.flags & SymbolFlags.Alias
                    && symbolFromSymbolTable.escapedName !== "export="
                    && !ts.getDeclarationOfKind(symbolFromSymbolTable, SyntaxKind.ExportSpecifier)
                    && !(isUMDExportSymbol(symbolFromSymbolTable) && enclosingDeclaration && ts.isExternalModule(ts.getSourceFileOfNode(enclosingDeclaration)))
                    // If `!useOnlyExternalAliasing`, we can use any type of alias to get the name
                    && (!useOnlyExternalAliasing || ts.some(symbolFromSymbolTable.declarations, ts.isExternalModuleImportEqualsDeclaration))) {
                    let resolvedImportedSymbol = resolveAlias(symbolFromSymbolTable);
                    if (isAccessible(symbolFromSymbolTable, resolvedImportedSymbol)) {
                        return [symbolFromSymbolTable];
                    }
                    // Look in the exported members, if we can find accessibleSymbolChain, symbol is accessible using this chain
                    // but only if the symbolFromSymbolTable can be qualified
                    let accessibleSymbolsFromExports = resolvedImportedSymbol.exports ? getAccessibleSymbolChainFromSymbolTable(resolvedImportedSymbol.exports) : undefined;
                    if (accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning))) {
                        return [symbolFromSymbolTable].concat(accessibleSymbolsFromExports);
                    }
                }
            });
        }
    }
    function needsQualification(symbol, enclosingDeclaration, meaning) {
        let qualify = false;
        forEachSymbolTableInScope(enclosingDeclaration, function (symbolTable) {
            // If symbol of this name is not available in the symbol table we are ok
            let symbolFromSymbolTable = symbolTable.get(symbol.escapedName);
            if (!symbolFromSymbolTable) {
                // Continue to the next symbol table
                return false;
            }
            // If the symbol with this name is present it should refer to the symbol
            if (symbolFromSymbolTable === symbol) {
                // No need to qualify
                return true;
            }
            // Qualify if the symbol from symbol table has same meaning as expected
            symbolFromSymbolTable = (symbolFromSymbolTable.flags & SymbolFlags.Alias && !ts.getDeclarationOfKind(symbolFromSymbolTable, SyntaxKind.ExportSpecifier)) ? resolveAlias(symbolFromSymbolTable) : symbolFromSymbolTable;
            if (symbolFromSymbolTable.flags & meaning) {
                qualify = true;
                return true;
            }
            // Continue to the next symbol table
            return false;
        });
        return qualify;
    }
    function isPropertyOrMethodDeclarationSymbol(symbol) {
        if (symbol.declarations && symbol.declarations.length) {
            for (let _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                let declaration = _a[_i];
                switch (declaration.kind) {
                    case SyntaxKind.PropertyDeclaration:
                    case SyntaxKind.MethodDeclaration:
                    case 153 /* GetAccessor */:
                    case 154 /* SetAccessor */:
                        continue;
                    default:
                        return false;
                }
            }
            return true;
        }
        return false;
    }
    function isTypeSymbolAccessible(typeSymbol, enclosingDeclaration) {
        let access = isSymbolAccessible(typeSymbol, enclosingDeclaration, SymbolFlags.Type, /*shouldComputeAliasesToMakeVisible*/ false);
        return access.accessibility === 0 /* Accessible */;
    }
    /**
     * Check if the given symbol in given enclosing declaration is accessible and mark all associated alias to be visible if requested
     *
     * @param symbol a Symbol to check if accessible
     * @param enclosingDeclaration a Node containing reference to the symbol
     * @param meaning a SymbolFlags to check if such meaning of the symbol is accessible
     * @param shouldComputeAliasToMakeVisible a boolean value to indicate whether to return aliases to be mark visible in case the symbol is accessible
     */
    function isSymbolAccessible(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible) {
        if (symbol && enclosingDeclaration && !(symbol.flags & SymbolFlags.TypeParameter)) {
            let initialSymbol = symbol;
            let meaningToLook = meaning;
            while (symbol) {
                // Symbol is accessible if it by itself is accessible
                let accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaningToLook, /*useOnlyExternalAliasing*/ false);
                if (accessibleSymbolChain) {
                    let hasAccessibleDeclarations = hasVisibleDeclarations(accessibleSymbolChain[0], shouldComputeAliasesToMakeVisible);
                    if (!hasAccessibleDeclarations) {
                        return {
                            accessibility: 1 /* NotAccessible */,
                            errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),
                            errorModuleName: symbol !== initialSymbol ? symbolToString(symbol, enclosingDeclaration, SymbolFlags.Namespace) : undefined,
                        };
                    }
                    return hasAccessibleDeclarations;
                }
                // If we haven't got the accessible symbol, it doesn't mean the symbol is actually inaccessible.
                // It could be a qualified symbol and hence verify the path
                // e.g.:
                // module m {
                //     export class c {
                //     }
                // }
                // const x: typeof m.c
                // In the above example when we start with checking if typeof m.c symbol is accessible,
                // we are going to see if c can be accessed in scope directly.
                // But it can't, hence the accessible is going to be undefined, but that doesn't mean m.c is inaccessible
                // It is accessible if the parent m is accessible because then m.c can be accessed through qualification
                meaningToLook = getQualifiedLeftMeaning(meaning);
                symbol = getParentOfSymbol(symbol);
            }
            // This could be a symbol that is not exported in the external module
            // or it could be a symbol from different external module that is not aliased and hence cannot be named
            let symbolExternalModule = ts.forEach(initialSymbol.declarations, getExternalModuleContainer);
            if (symbolExternalModule) {
                let enclosingExternalModule = getExternalModuleContainer(enclosingDeclaration);
                if (symbolExternalModule !== enclosingExternalModule) {
                    // name from different external module that is not visible
                    return {
                        accessibility: 2 /* CannotBeNamed */,
                        errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),
                        errorModuleName: symbolToString(symbolExternalModule)
                    };
                }
            }
            // Just a local name that is not accessible
            return {
                accessibility: 1 /* NotAccessible */,
                errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),
            };
        }
        return { accessibility: 0 /* Accessible */ };
        function getExternalModuleContainer(declaration) {
            let node = ts.findAncestor(declaration, hasExternalModuleSymbol);
            return node && getSymbolOfNode(node);
        }
    }
    function hasExternalModuleSymbol(declaration) {
        return ts.isAmbientModule(declaration) || (declaration.kind === SyntaxKind.SourceFile && ts.isExternalOrCommonJsModule(declaration));
    }
    function hasVisibleDeclarations(symbol, shouldComputeAliasToMakeVisible) {
        let aliasesToMakeVisible;
        if (ts.forEach(symbol.declarations, function (declaration) { return !getIsDeclarationVisible(declaration); })) {
            return undefined;
        }
        return { accessibility: 0 /* Accessible */, aliasesToMakeVisible: aliasesToMakeVisible };
        function getIsDeclarationVisible(declaration) {
            if (!isDeclarationVisible(declaration)) {
                // Mark the unexported alias as visible if its parent is visible
                // because these kind of aliases can be used to name types in declaration file
                let anyImportSyntax = getAnyImportSyntax(declaration);
                if (anyImportSyntax &&
                    !ts.hasModifier(anyImportSyntax, 1 /* Export */) && // import clause without export
                    isDeclarationVisible(anyImportSyntax.parent)) {
                    // In function "buildTypeDisplay" where we decide whether to write type-alias or serialize types,
                    // we want to just check if type- alias is accessible or not but we don't care about emitting those alias at that time
                    // since we will do the emitting later in trackSymbol.
                    if (shouldComputeAliasToMakeVisible) {
                        getNodeLinks(declaration).isVisible = true;
                        aliasesToMakeVisible = ts.appendIfUnique(aliasesToMakeVisible, anyImportSyntax);
                    }
                    return true;
                }
                // Declaration is not visible
                return false;
            }
            return true;
        }
    }
    function isEntityNameVisible(entityName, enclosingDeclaration) {
        // get symbol of the first identifier of the entityName
        let meaning;
        if (entityName.parent.kind === 162 /* TypeQuery */ || ts.isExpressionWithTypeArgumentsInClassExtendsClause(entityName.parent)) {
            // Typeof value
            meaning = SymbolFlags.Value | 1048576 /* ExportValue */;
        }
        else if (entityName.kind === 143 /* QualifiedName */ || entityName.kind === 179 /* PropertyAccessExpression */ ||
            entityName.parent.kind === 237 /* ImportEqualsDeclaration */) {
            // Left identifier from type reference or TypeAlias
            // Entity name of the import declaration
            meaning = SymbolFlags.Namespace;
        }
        else {
            // Type Reference or TypeAlias entity = Identifier
            meaning = SymbolFlags.Type;
        }
        let firstIdentifier = getFirstIdentifier(entityName);
        let symbol = resolveName(enclosingDeclaration, firstIdentifier.escapedText, meaning, /*nodeNotFoundErrorMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ false);
        // Verify if the symbol is accessible
        return (symbol && hasVisibleDeclarations(symbol, /*shouldComputeAliasToMakeVisible*/ true)) || {
            accessibility: 1 /* NotAccessible */,
            errorSymbolName: ts.getTextOfNode(firstIdentifier),
            errorNode: firstIdentifier
        };
    }
    function writeKeyword(writer, kind) {
        writer.writeKeyword(ts.tokenToString(kind));
    }
    function writePunctuation(writer, kind) {
        writer.writePunctuation(ts.tokenToString(kind));
    }
    function writeSpace(writer) {
        writer.writeSpace(" ");
    }
    function symbolToString(symbol, enclosingDeclaration, meaning) {
        return ts.usingSingleLineStringWriter(function (writer) {
            getSymbolDisplayBuilder().buildSymbolDisplay(symbol, writer, enclosingDeclaration, meaning);
        });
    }
    function signatureToString(signature, enclosingDeclaration, flags, kind) {
        return ts.usingSingleLineStringWriter(function (writer) {
            getSymbolDisplayBuilder().buildSignatureDisplay(signature, writer, enclosingDeclaration, flags, kind);
        });
    }
    function typeToString(type, enclosingDeclaration, flags) {
        let typeNode = nodeBuilder.typeToTypeNode(type, enclosingDeclaration, toNodeBuilderFlags(flags) | ts.NodeBuilderFlags.IgnoreErrors | ts.NodeBuilderFlags.WriteTypeParametersInQualifiedName);
        ts.Debug.assert(typeNode !== undefined, "should always get typenode");
        let options = { removeComments: true };
        let writer = ts.createTextWriter("");
        let printer = ts.createPrinter(options);
        let sourceFile = enclosingDeclaration && ts.getSourceFileOfNode(enclosingDeclaration);
        printer.writeNode(4 /* Unspecified */, typeNode, /*sourceFile*/ sourceFile, writer);
        let result = writer.getText();
        let maxLength = compilerOptions.noErrorTruncation || flags & 8 /* NoTruncation */ ? undefined : 100;
        if (maxLength && result.length >= maxLength) {
            return result.substr(0, maxLength - "...".length) + "...";
        }
        return result;
        function toNodeBuilderFlags(flags) {
            let result = ts.NodeBuilderFlags.None;
            if (!flags) {
                return result;
            }
            if (flags & 8 /* NoTruncation */) {
                result |= ts.NodeBuilderFlags.NoTruncation;
            }
            if (flags & 256 /* UseFullyQualifiedType */) {
                result |= ts.NodeBuilderFlags.UseFullyQualifiedType;
            }
            if (flags & 4096 /* SuppressAnyReturnType */) {
                result |= ts.NodeBuilderFlags.SuppressAnyReturnType;
            }
            if (flags & 1 /* WriteArrayAsGenericType */) {
                result |= ts.NodeBuilderFlags.WriteArrayAsGenericType;
            }
            if (flags & 64 /* WriteTypeArgumentsOfSignature */) {
                result |= ts.NodeBuilderFlags.WriteTypeArgumentsOfSignature;
            }
            return result;
        }
    }
    function createNodeBuilder() {
        return {
            typeToTypeNode: function (type, enclosingDeclaration, flags) {
                ts.Debug.assert(enclosingDeclaration === undefined || (enclosingDeclaration.flags & 8 /* Synthesized */) === 0);
                let context = createNodeBuilderContext(enclosingDeclaration, flags);
                let resultingNode = typeToTypeNodeHelper(type, context);
                let result = context.encounteredError ? undefined : resultingNode;
                return result;
            },
            indexInfoToIndexSignatureDeclaration: function (indexInfo, kind, enclosingDeclaration, flags) {
                ts.Debug.assert(enclosingDeclaration === undefined || (enclosingDeclaration.flags & 8 /* Synthesized */) === 0);
                let context = createNodeBuilderContext(enclosingDeclaration, flags);
                let resultingNode = indexInfoToIndexSignatureDeclarationHelper(indexInfo, kind, context);
                let result = context.encounteredError ? undefined : resultingNode;
                return result;
            },
            signatureToSignatureDeclaration: function (signature, kind, enclosingDeclaration, flags) {
                ts.Debug.assert(enclosingDeclaration === undefined || (enclosingDeclaration.flags & 8 /* Synthesized */) === 0);
                let context = createNodeBuilderContext(enclosingDeclaration, flags);
                let resultingNode = signatureToSignatureDeclarationHelper(signature, kind, context);
                let result = context.encounteredError ? undefined : resultingNode;
                return result;
            }
        };
        function createNodeBuilderContext(enclosingDeclaration, flags) {
            return {
                enclosingDeclaration: enclosingDeclaration,
                flags: flags,
                encounteredError: false,
                symbolStack: undefined
            };
        }
        function typeToTypeNodeHelper(type, context) {
            let inTypeAlias = context.flags & ts.NodeBuilderFlags.InTypeAlias;
            context.flags &= ~ts.NodeBuilderFlags.InTypeAlias;
            if (!type) {
                context.encounteredError = true;
                return undefined;
            }
            if (type.flags & 1 /* Any */) {
                return ts.createKeywordTypeNode(119 /* AnyKeyword */);
            }
            if (type.flags & 2 /* String */) {
                return ts.createKeywordTypeNode(136 /* StringKeyword */);
            }
            if (type.flags & 4 /* Number */) {
                return ts.createKeywordTypeNode(133 /* NumberKeyword */);
            }
            if (type.flags & 8 /* Boolean */) {
                return ts.createKeywordTypeNode(122 /* BooleanKeyword */);
            }
            if (type.flags & 256 /* EnumLiteral */ && !(type.flags & 65536 /* Union */)) {
                let parentSymbol = getParentOfSymbol(type.symbol);
                let parentName = symbolToName(parentSymbol, context, SymbolFlags.Type, /*expectsIdentifier*/ false);
                let enumLiteralName = getDeclaredTypeOfSymbol(parentSymbol) === type ? parentName : ts.createQualifiedName(parentName, getNameOfSymbol(type.symbol, context));
                return ts.createTypeReferenceNode(enumLiteralName, /*typeArguments*/ undefined);
            }
            if (type.flags & 272 /* EnumLike */) {
                let name = symbolToName(type.symbol, context, SymbolFlags.Type, /*expectsIdentifier*/ false);
                return ts.createTypeReferenceNode(name, /*typeArguments*/ undefined);
            }
            if (type.flags & (32 /* StringLiteral */)) {
                return ts.createLiteralTypeNode(ts.setEmitFlags(ts.createLiteral(type.value), 16777216 /* NoAsciiEscaping */));
            }
            if (type.flags & (64 /* NumberLiteral */)) {
                return ts.createLiteralTypeNode((ts.createLiteral(type.value)));
            }
            if (type.flags & 128 /* BooleanLiteral */) {
                return type.intrinsicName === "true" ? ts.createTrue() : ts.createFalse();
            }
            if (type.flags & 1024 /* Void */) {
                return ts.createKeywordTypeNode(105 /* VoidKeyword */);
            }
            if (type.flags & 2048 /* Undefined */) {
                return ts.createKeywordTypeNode(139 /* UndefinedKeyword */);
            }
            if (type.flags & 4096 /* Null */) {
                return ts.createKeywordTypeNode(95 /* NullKeyword */);
            }
            if (type.flags & 8192 /* Never */) {
                return ts.createKeywordTypeNode(130 /* NeverKeyword */);
            }
            if (type.flags & 512 /* ESSymbol */) {
                return ts.createKeywordTypeNode(137 /* SymbolKeyword */);
            }
            if (type.flags & 16777216 /* NonPrimitive */) {
                return ts.createKeywordTypeNode(134 /* ObjectKeyword */);
            }
            if (type.flags & 16384 /* TypeParameter */ && type.isThisType) {
                if (context.flags & ts.NodeBuilderFlags.InObjectTypeLiteral) {
                    if (!context.encounteredError && !(context.flags & ts.NodeBuilderFlags.AllowThisInObjectLiteral)) {
                        context.encounteredError = true;
                    }
                }
                return ts.createThis();
            }
            let objectFlags = getObjectFlags(type);
            if (objectFlags & 4 /* Reference */) {
                ts.Debug.assert(!!(type.flags & TypeFlags.Object));
                return typeReferenceToTypeNode(type);
            }
            if (type.flags & 16384 /* TypeParameter */ || objectFlags & 3 /* ClassOrInterface */) {
                let name = type.symbol ? symbolToName(type.symbol, context, SymbolFlags.Type, /*expectsIdentifier*/ false) : ts.createIdentifier("?");
                // Ignore constraint/default when creating a usage (as opposed to declaration) of a type parameter.
                return ts.createTypeReferenceNode(name, /*typeArguments*/ undefined);
            }
            if (!inTypeAlias && type.aliasSymbol && isTypeSymbolAccessible(type.aliasSymbol, context.enclosingDeclaration)) {
                let name = symbolToTypeReferenceName(type.aliasSymbol);
                let typeArgumentNodes = mapToTypeNodes(type.aliasTypeArguments, context);
                return ts.createTypeReferenceNode(name, typeArgumentNodes);
            }
            if (type.flags & (65536 /* Union */ | 131072 /* Intersection */)) {
                let types = type.flags & 65536 /* Union */ ? formatUnionTypes(type.types) : type.types;
                let typeNodes = mapToTypeNodes(types, context);
                if (typeNodes && typeNodes.length > 0) {
                    let unionOrIntersectionTypeNode = ts.createUnionOrIntersectionTypeNode(type.flags & 65536 /* Union */ ? 166 /* UnionType */ : 167 /* IntersectionType */, typeNodes);
                    return unionOrIntersectionTypeNode;
                }
                else {
                    if (!context.encounteredError && !(context.flags & ts.NodeBuilderFlags.AllowEmptyUnionOrIntersection)) {
                        context.encounteredError = true;
                    }
                    return undefined;
                }
            }
            if (objectFlags & (16 /* Anonymous */ | 32 /* Mapped */)) {
                ts.Debug.assert(!!(type.flags & TypeFlags.Object));
                // The type is an object literal type.
                return createAnonymousTypeNode(type);
            }
            if (type.flags & 262144 /* Index */) {
                let indexedType = type.type;
                let indexTypeNode = typeToTypeNodeHelper(indexedType, context);
                return ts.createTypeOperatorNode(indexTypeNode);
            }
            if (type.flags & 524288 /* IndexedAccess */) {
                let objectTypeNode = typeToTypeNodeHelper(type.objectType, context);
                let indexTypeNode = typeToTypeNodeHelper(type.indexType, context);
                return ts.createIndexedAccessTypeNode(objectTypeNode, indexTypeNode);
            }
            ts.Debug.fail("Should be unreachable.");
            function createMappedTypeNodeFromType(type) {
                ts.Debug.assert(!!(type.flags & TypeFlags.Object));
                let readonlyToken = type.declaration && type.declaration.readonlyToken ? ts.createToken(131 /* ReadonlyKeyword */) : undefined;
                let questionToken = type.declaration && type.declaration.questionToken ? ts.createToken(55 /* QuestionToken */) : undefined;
                let typeParameterNode = typeParameterToDeclaration(getTypeParameterFromMappedType(type), context);
                let templateTypeNode = typeToTypeNodeHelper(getTemplateTypeFromMappedType(type), context);
                let mappedTypeNode = ts.createMappedTypeNode(readonlyToken, typeParameterNode, questionToken, templateTypeNode);
                return ts.setEmitFlags(mappedTypeNode, 1 /* SingleLine */);
            }
            function createAnonymousTypeNode(type) {
                let symbol = type.symbol;
                if (symbol) {
                    // Always use 'typeof T' for type of class, enum, and module objects
                    if (symbol.flags & 32 /* Class */ && !getBaseTypeVariableOfClass(symbol) ||
                        symbol.flags & (384 /* Enum */ | 512 /* ValueModule */) ||
                        shouldWriteTypeOfFunctionSymbol()) {
                        return createTypeQueryNodeFromSymbol(symbol, SymbolFlags.Value);
                    }
                    else if (ts.contains(context.symbolStack, symbol)) {
                        // If type is an anonymous type literal in a type alias declaration, use type alias name
                        let typeAlias = getTypeAliasForTypeLiteral(type);
                        if (typeAlias) {
                            // The specified symbol flags need to be reinterpreted as type flags
                            let entityName = symbolToName(typeAlias, context, SymbolFlags.Type, /*expectsIdentifier*/ false);
                            return ts.createTypeReferenceNode(entityName, /*typeArguments*/ undefined);
                        }
                        else {
                            return ts.createKeywordTypeNode(119 /* AnyKeyword */);
                        }
                    }
                    else {
                        // Since instantiations of the same anonymous type have the same symbol, tracking symbols instead
                        // of types allows us to catch circular references to instantiations of the same anonymous type
                        if (!context.symbolStack) {
                            context.symbolStack = [];
                        }
                        context.symbolStack.push(symbol);
                        let result = createTypeNodeFromObjectType(type);
                        context.symbolStack.pop();
                        return result;
                    }
                }
                else {
                    // Anonymous types without a symbol are never circular.
                    return createTypeNodeFromObjectType(type);
                }
                function shouldWriteTypeOfFunctionSymbol() {
                    let isStaticMethodSymbol = !!(symbol.flags & 8192 /* Method */) && // typeof static method
                        ts.some(symbol.declarations, function (declaration) { return ts.hasModifier(declaration, ModifierFlags.Static); });
                    let isNonLocalFunctionSymbol = !!(symbol.flags & 16 /* Function */) &&
                        (symbol.parent || // is exported function symbol
                            ts.forEach(symbol.declarations, function (declaration) {
                                return declaration.parent.kind === SyntaxKind.SourceFile || declaration.parent.kind === 234 /* ModuleBlock */;
                            }));
                    if (isStaticMethodSymbol || isNonLocalFunctionSymbol) {
                        // typeof is allowed only for static/non local functions
                        return ts.contains(context.symbolStack, symbol); // it is type of the symbol uses itself recursively
                    }
                }
            }
            function createTypeNodeFromObjectType(type) {
                if (isGenericMappedType(type)) {
                    return createMappedTypeNodeFromType(type);
                }
                let resolved = resolveStructuredTypeMembers(type);
                if (!resolved.properties.length && !resolved.stringIndexInfo && !resolved.numberIndexInfo) {
                    if (!resolved.callSignatures.length && !resolved.constructSignatures.length) {
                        return ts.setEmitFlags(ts.createTypeLiteralNode(/*members*/ undefined), 1 /* SingleLine */);
                    }
                    if (resolved.callSignatures.length === 1 && !resolved.constructSignatures.length) {
                        let signature = resolved.callSignatures[0];
                        let signatureNode = signatureToSignatureDeclarationHelper(signature, 160 /* FunctionType */, context);
                        return signatureNode;
                    }
                    if (resolved.constructSignatures.length === 1 && !resolved.callSignatures.length) {
                        let signature = resolved.constructSignatures[0];
                        let signatureNode = signatureToSignatureDeclarationHelper(signature, 161 /* ConstructorType */, context);
                        return signatureNode;
                    }
                }
                let savedFlags = context.flags;
                context.flags |= ts.NodeBuilderFlags.InObjectTypeLiteral;
                let members = createTypeNodesFromResolvedType(resolved);
                context.flags = savedFlags;
                let typeLiteralNode = ts.createTypeLiteralNode(members);
                return ts.setEmitFlags(typeLiteralNode, 1 /* SingleLine */);
            }
            function createTypeQueryNodeFromSymbol(symbol, symbolFlags) {
                let entityName = symbolToName(symbol, context, symbolFlags, /*expectsIdentifier*/ false);
                return ts.createTypeQueryNode(entityName);
            }
            function symbolToTypeReferenceName(symbol) {
                // Unnamed function expressions and arrow functions have reserved names that we don't want to display
                let entityName = symbol.flags & 32 /* Class */ || !isReservedMemberName(symbol.escapedName) ? symbolToName(symbol, context, SymbolFlags.Type, /*expectsIdentifier*/ false) : ts.createIdentifier("");
                return entityName;
            }
            function typeReferenceToTypeNode(type) {
                let typeArguments = type.typeArguments || ts.emptyArray;
                if (type.target === globalArrayType) {
                    if (context.flags & ts.NodeBuilderFlags.WriteArrayAsGenericType) {
                        let typeArgumentNode = typeToTypeNodeHelper(typeArguments[0], context);
                        return ts.createTypeReferenceNode("Array", [typeArgumentNode]);
                    }
                    let elementType = typeToTypeNodeHelper(typeArguments[0], context);
                    return ts.createArrayTypeNode(elementType);
                }
                else if (type.target.objectFlags & 8 /* Tuple */) {
                    if (typeArguments.length > 0) {
                        let tupleConstituentNodes = mapToTypeNodes(typeArguments.slice(0, getTypeReferenceArity(type)), context);
                        if (tupleConstituentNodes && tupleConstituentNodes.length > 0) {
                            return ts.createTupleTypeNode(tupleConstituentNodes);
                        }
                    }
                    if (context.encounteredError || (context.flags & ts.NodeBuilderFlags.AllowEmptyTuple)) {
                        return ts.createTupleTypeNode([]);
                    }
                    context.encounteredError = true;
                    return undefined;
                }
                else {
                    let outerTypeParameters = type.target.outerTypeParameters;
                    let i = 0;
                    let qualifiedName = void 0;
                    if (outerTypeParameters) {
                        let length_1 = outerTypeParameters.length;
                        while (i < length_1) {
                            // Find group of type arguments for type parameters with the same declaring container.
                            let start = i;
                            let parent = getParentSymbolOfTypeParameter(outerTypeParameters[i]);
                            do {
                                i++;
                            } while (i < length_1 && getParentSymbolOfTypeParameter(outerTypeParameters[i]) === parent);
                            // When type parameters are their own type arguments for the whole group (i.e. we have
                            // the default outer type arguments), we don't show the group.
                            if (!ts.rangeEquals(outerTypeParameters, typeArguments, start, i)) {
                                let typeArgumentSlice = mapToTypeNodes(typeArguments.slice(start, i), context);
                                let typeArgumentNodes_1 = typeArgumentSlice && ts.createNodeArray(typeArgumentSlice);
                                let namePart = symbolToTypeReferenceName(parent);
                                (namePart.kind === 71 /* Identifier */ ? namePart : namePart.right).typeArguments = typeArgumentNodes_1;
                                if (qualifiedName) {
                                    ts.Debug.assert(!qualifiedName.right);
                                    qualifiedName = addToQualifiedNameMissingRightIdentifier(qualifiedName, namePart);
                                    qualifiedName = ts.createQualifiedName(qualifiedName, /*right*/ undefined);
                                }
                                else {
                                    qualifiedName = ts.createQualifiedName(namePart, /*right*/ undefined);
                                }
                            }
                        }
                    }
                    let entityName = undefined;
                    let nameIdentifier = symbolToTypeReferenceName(type.symbol);
                    if (qualifiedName) {
                        ts.Debug.assert(!qualifiedName.right);
                        qualifiedName = addToQualifiedNameMissingRightIdentifier(qualifiedName, nameIdentifier);
                        entityName = qualifiedName;
                    }
                    else {
                        entityName = nameIdentifier;
                    }
                    let typeArgumentNodes = void 0;
                    if (typeArguments.length > 0) {
                        let typeParameterCount = (type.target.typeParameters || ts.emptyArray).length;
                        typeArgumentNodes = mapToTypeNodes(typeArguments.slice(i, typeParameterCount), context);
                    }
                    if (typeArgumentNodes) {
                        let lastIdentifier = entityName.kind === 71 /* Identifier */ ? entityName : entityName.right;
                        lastIdentifier.typeArguments = undefined;
                    }
                    return ts.createTypeReferenceNode(entityName, typeArgumentNodes);
                }
            }
            function addToQualifiedNameMissingRightIdentifier(left, right) {
                ts.Debug.assert(left.right === undefined);
                if (right.kind === 71 /* Identifier */) {
                    left.right = right;
                    return left;
                }
                let rightPart = right;
                while (rightPart.left.kind !== 71 /* Identifier */) {
                    rightPart = rightPart.left;
                }
                left.right = rightPart.left;
                rightPart.left = left;
                return right;
            }
            function createTypeNodesFromResolvedType(resolvedType) {
                let typeElements = [];
                for (let _i = 0, _a = resolvedType.callSignatures; _i < _a.length; _i++) {
                    let signature = _a[_i];
                    typeElements.push(signatureToSignatureDeclarationHelper(signature, 155 /* CallSignature */, context));
                }
                for (let _b = 0, _c = resolvedType.constructSignatures; _b < _c.length; _b++) {
                    let signature = _c[_b];
                    typeElements.push(signatureToSignatureDeclarationHelper(signature, 156 /* ConstructSignature */, context));
                }
                if (resolvedType.stringIndexInfo) {
                    typeElements.push(indexInfoToIndexSignatureDeclarationHelper(resolvedType.stringIndexInfo, 0 /* String */, context));
                }
                if (resolvedType.numberIndexInfo) {
                    typeElements.push(indexInfoToIndexSignatureDeclarationHelper(resolvedType.numberIndexInfo, 1 /* Number */, context));
                }
                let properties = resolvedType.properties;
                if (!properties) {
                    return typeElements;
                }
                for (let _d = 0, properties_1 = properties; _d < properties_1.length; _d++) {
                    let propertySymbol = properties_1[_d];
                    let propertyType = getTypeOfSymbol(propertySymbol);
                    let saveEnclosingDeclaration = context.enclosingDeclaration;
                    context.enclosingDeclaration = undefined;
                    let propertyName = symbolToName(propertySymbol, context, SymbolFlags.Value, /*expectsIdentifier*/ true);
                    context.enclosingDeclaration = saveEnclosingDeclaration;
                    let optionalToken = propertySymbol.flags & 16777216 /* Optional */ ? ts.createToken(55 /* QuestionToken */) : undefined;
                    if (propertySymbol.flags & (16 /* Function */ | 8192 /* Method */) && !getPropertiesOfObjectType(propertyType).length) {
                        let signatures = getSignaturesOfType(propertyType, 0 /* Call */);
                        for (let _e = 0, signatures_1 = signatures; _e < signatures_1.length; _e++) {
                            let signature = signatures_1[_e];
                            let methodDeclaration = signatureToSignatureDeclarationHelper(signature, 150 /* MethodSignature */, context);
                            methodDeclaration.name = propertyName;
                            methodDeclaration.questionToken = optionalToken;
                            typeElements.push(methodDeclaration);
                        }
                    }
                    else {
                        let propertyTypeNode = propertyType ? typeToTypeNodeHelper(propertyType, context) : ts.createKeywordTypeNode(119 /* AnyKeyword */);
                        let modifiers = isReadonlySymbol(propertySymbol) ? [ts.createToken(131 /* ReadonlyKeyword */)] : undefined;
                        let propertySignature = ts.createPropertySignature(modifiers, propertyName, optionalToken, propertyTypeNode,
                        /*initializer*/ undefined);
                        typeElements.push(propertySignature);
                    }
                }
                return typeElements.length ? typeElements : undefined;
            }
        }
        function mapToTypeNodes(types, context) {
            if (ts.some(types)) {
                let result = [];
                for (let i = 0; i < types.length; ++i) {
                    let type = types[i];
                    let typeNode = typeToTypeNodeHelper(type, context);
                    if (typeNode) {
                        result.push(typeNode);
                    }
                }
                return result;
            }
        }
        function indexInfoToIndexSignatureDeclarationHelper(indexInfo, kind, context) {
            let name = ts.getNameFromIndexInfo(indexInfo) || "x";
            let indexerTypeNode = ts.createKeywordTypeNode(kind === 0 /* String */ ? 136 /* StringKeyword */ : 133 /* NumberKeyword */);
            let indexingParameter = ts.createParameter(
            /*decorators*/ undefined,
            /*modifiers*/ undefined,
            /*dotDotDotToken*/ undefined, name,
            /*questionToken*/ undefined, indexerTypeNode,
            /*initializer*/ undefined);
            let typeNode = typeToTypeNodeHelper(indexInfo.type, context);
            return ts.createIndexSignature(
            /*decorators*/ undefined, indexInfo.isReadonly ? [ts.createToken(131 /* ReadonlyKeyword */)] : undefined, [indexingParameter], typeNode);
        }
        function signatureToSignatureDeclarationHelper(signature, kind, context) {
            let typeParameters = signature.typeParameters && signature.typeParameters.map(function (parameter) { return typeParameterToDeclaration(parameter, context); });
            let parameters = signature.parameters.map(function (parameter) { return symbolToParameterDeclaration(parameter, context); });
            if (signature.thisParameter) {
                let thisParameter = symbolToParameterDeclaration(signature.thisParameter, context);
                parameters.unshift(thisParameter);
            }
            let returnTypeNode;
            if (signature.typePredicate) {
                let typePredicate = signature.typePredicate;
                let parameterName = typePredicate.kind === 1 /* Identifier */ ?
                    ts.setEmitFlags(ts.createIdentifier(typePredicate.parameterName), 16777216 /* NoAsciiEscaping */) :
                    ts.createThisTypeNode();
                let typeNode = typeToTypeNodeHelper(typePredicate.type, context);
                returnTypeNode = ts.createTypePredicateNode(parameterName, typeNode);
            }
            else {
                let returnType = getReturnTypeOfSignature(signature);
                returnTypeNode = returnType && typeToTypeNodeHelper(returnType, context);
            }
            if (context.flags & ts.NodeBuilderFlags.SuppressAnyReturnType) {
                if (returnTypeNode && returnTypeNode.kind === 119 /* AnyKeyword */) {
                    returnTypeNode = undefined;
                }
            }
            else if (!returnTypeNode) {
                returnTypeNode = ts.createKeywordTypeNode(119 /* AnyKeyword */);
            }
            return ts.createSignatureDeclaration(kind, typeParameters, parameters, returnTypeNode);
        }
        function typeParameterToDeclaration(type, context) {
            let name = symbolToName(type.symbol, context, SymbolFlags.Type, /*expectsIdentifier*/ true);
            let constraint = getConstraintFromTypeParameter(type);
            let constraintNode = constraint && typeToTypeNodeHelper(constraint, context);
            let defaultParameter = getDefaultFromTypeParameter(type);
            let defaultParameterNode = defaultParameter && typeToTypeNodeHelper(defaultParameter, context);
            return ts.createTypeParameterDeclaration(name, constraintNode, defaultParameterNode);
        }
        function symbolToParameterDeclaration(parameterSymbol, context) {
            let parameterDeclaration = ts.getDeclarationOfKind(parameterSymbol, SyntaxKind.Parameter);
            if (isTransientSymbol(parameterSymbol) && parameterSymbol.isRestParameter) {
                // special-case synthetic rest parameters in JS files
                return ts.createParameter(
                /*decorators*/ undefined,
                /*modifiers*/ undefined, parameterSymbol.isRestParameter ? ts.createToken(24 /* DotDotDotToken */) : undefined, "args",
                /*questionToken*/ undefined, typeToTypeNodeHelper(anyArrayType, context),
                /*initializer*/ undefined);
            }
            let modifiers = parameterDeclaration.modifiers && parameterDeclaration.modifiers.map(ts.getSynthesizedClone);
            let dotDotDotToken = ts.isRestParameter(parameterDeclaration) ? ts.createToken(24 /* DotDotDotToken */) : undefined;
            let name = parameterDeclaration.name ?
                parameterDeclaration.name.kind === 71 /* Identifier */ ?
                    ts.setEmitFlags(ts.getSynthesizedClone(parameterDeclaration.name), 16777216 /* NoAsciiEscaping */) :
                    cloneBindingName(parameterDeclaration.name) :
                ts.symbolName(parameterSymbol);
            let questionToken = isOptionalParameter(parameterDeclaration) ? ts.createToken(55 /* QuestionToken */) : undefined;
            let parameterType = getTypeOfSymbol(parameterSymbol);
            if (isRequiredInitializedParameter(parameterDeclaration)) {
                parameterType = getNullableType(parameterType, 2048 /* Undefined */);
            }
            let parameterTypeNode = typeToTypeNodeHelper(parameterType, context);
            let parameterNode = ts.createParameter(
            /*decorators*/ undefined, modifiers, dotDotDotToken, name, questionToken, parameterTypeNode,
            /*initializer*/ undefined);
            return parameterNode;
            function cloneBindingName(node) {
                return elideInitializerAndSetEmitFlags(node);
                function elideInitializerAndSetEmitFlags(node) {
                    let visited = ts.visitEachChild(node, elideInitializerAndSetEmitFlags, ts.nullTransformationContext, /*nodesVisitor*/ undefined, elideInitializerAndSetEmitFlags);
                    let clone = ts.nodeIsSynthesized(visited) ? visited : ts.getSynthesizedClone(visited);
                    if (clone.kind === 176 /* BindingElement */) {
                        clone.initializer = undefined;
                    }
                    return ts.setEmitFlags(clone, 1 /* SingleLine */ | 16777216 /* NoAsciiEscaping */);
                }
            }
        }
        function symbolToName(symbol, context, meaning, expectsIdentifier) {
            // Try to get qualified name if the symbol is not a type parameter and there is an enclosing declaration.
            let chain;
            let isTypeParameter = symbol.flags & SymbolFlags.TypeParameter;
            if (!isTypeParameter && (context.enclosingDeclaration || context.flags & ts.NodeBuilderFlags.UseFullyQualifiedType)) {
                chain = getSymbolChain(symbol, meaning, /*endOfChain*/ true);
                ts.Debug.assert(chain && chain.length > 0);
            }
            else {
                chain = [symbol];
            }
            if (expectsIdentifier && chain.length !== 1
                && !context.encounteredError
                && !(context.flags & ts.NodeBuilderFlags.AllowQualifedNameInPlaceOfIdentifier)) {
                context.encounteredError = true;
            }
            return createEntityNameFromSymbolChain(chain, chain.length - 1);
            function createEntityNameFromSymbolChain(chain, index) {
                ts.Debug.assert(chain && 0 <= index && index < chain.length);
                let symbol = chain[index];
                let typeParameterNodes;
                if (context.flags & ts.NodeBuilderFlags.WriteTypeParametersInQualifiedName && index > 0) {
                    let parentSymbol = chain[index - 1];
                    let typeParameters = void 0;
                    if (ts.getCheckFlags(symbol) & CheckFlags.Instantiated) {
                        typeParameters = getTypeParametersOfClassOrInterface(parentSymbol);
                    }
                    else {
                        let targetSymbol = getTargetSymbol(parentSymbol);
                        if (targetSymbol.flags & (32 /* Class */ | 64 /* Interface */ | 524288 /* TypeAlias */)) {
                            typeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                        }
                    }
                    typeParameterNodes = mapToTypeNodes(typeParameters, context);
                }
                let symbolName = getNameOfSymbol(symbol, context);
                let identifier = ts.setEmitFlags(ts.createIdentifier(symbolName, typeParameterNodes), 16777216 /* NoAsciiEscaping */);
                return index > 0 ? ts.createQualifiedName(createEntityNameFromSymbolChain(chain, index - 1), identifier) : identifier;
            }
            /** @param endOfChain Set to false for recursive calls; non-recursive calls should always output something. */
            function getSymbolChain(symbol, meaning, endOfChain) {
                let accessibleSymbolChain = getAccessibleSymbolChain(symbol, context.enclosingDeclaration, meaning, /*useOnlyExternalAliasing*/ false);
                let parentSymbol;
                if (!accessibleSymbolChain ||
                    needsQualification(accessibleSymbolChain[0], context.enclosingDeclaration, accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(meaning))) {
                    // Go up and add our parent.
                    let parent = getParentOfSymbol(accessibleSymbolChain ? accessibleSymbolChain[0] : symbol);
                    if (parent) {
                        let parentChain = getSymbolChain(parent, getQualifiedLeftMeaning(meaning), /*endOfChain*/ false);
                        if (parentChain) {
                            parentSymbol = parent;
                            accessibleSymbolChain = parentChain.concat(accessibleSymbolChain || [symbol]);
                        }
                    }
                }
                if (accessibleSymbolChain) {
                    return accessibleSymbolChain;
                }
                if (
                    // If this is the last part of outputting the symbol, always output. The cases apply only to parent symbols.
                    endOfChain ||
                    // If a parent symbol is an external module, don't write it. (We prefer just `x` vs `"foo/bar".x`.)
                    !(!parentSymbol && ts.forEach(symbol.declarations, hasExternalModuleSymbol)) &&
                    // If a parent symbol is an anonymous type, don't write it.
                    !(symbol.flags & (2048 /* TypeLiteral */ | 4096 /* ObjectLiteral */))) {
                    return [symbol];
                }
            }
        }
    }
    function typePredicateToString(typePredicate, enclosingDeclaration, flags) {
        return ts.usingSingleLineStringWriter(function (writer) {
            getSymbolDisplayBuilder().buildTypePredicateDisplay(typePredicate, writer, enclosingDeclaration, flags);
        });
    }
    function formatUnionTypes(types) {
        let result = [];
        let flags = 0;
        for (let i = 0; i < types.length; i++) {
            let t = types[i];
            flags |= t.flags;
            if (!(t.flags & 6144 /* Nullable */)) {
                if (t.flags & (128 /* BooleanLiteral */ | 256 /* EnumLiteral */)) {
                    let baseType = t.flags & 128 /* BooleanLiteral */ ? booleanType : getBaseTypeOfEnumLiteralType(t);
                    if (baseType.flags & 65536 /* Union */) {
                        let count = baseType.types.length;
                        if (i + count <= types.length && types[i + count - 1] === baseType.types[count - 1]) {
                            result.push(baseType);
                            i += count - 1;
                            continue;
                        }
                    }
                }
                result.push(t);
            }
        }
        if (flags & 4096 /* Null */)
            result.push(nullType);
        if (flags & 2048 /* Undefined */)
            result.push(undefinedType);
        return result || types;
    }
    function visibilityToString(flags) {
        if (flags === 8 /* Private */) {
            return "private";
        }
        if (flags === 16 /* Protected */) {
            return "protected";
        }
        return "public";
    }
    function getTypeAliasForTypeLiteral(type) {
        if (type.symbol && type.symbol.flags & 2048 /* TypeLiteral */) {
            let node = ts.findAncestor(type.symbol.declarations[0].parent, function (n) { return n.kind !== 168 /* ParenthesizedType */; });
            if (node.kind === 231 /* TypeAliasDeclaration */) {
                return getSymbolOfNode(node);
            }
        }
        return undefined;
    }
    function isTopLevelInExternalModuleAugmentation(node) {
        return node && node.parent &&
            node.parent.kind === 234 /* ModuleBlock */ &&
            ts.isExternalModuleAugmentation(node.parent.parent);
    }
    function literalTypeToString(type) {
        return type.flags & 32 /* StringLiteral */ ? '"' + ts.escapeString(type.value) + '"' : "" + type.value;
    }
    function getNameOfSymbol(symbol, context) {
        if (symbol.declarations && symbol.declarations.length) {
            let declaration = symbol.declarations[0];
            let name = ts.getNameOfDeclaration(declaration);
            if (name) {
                return ts.declarationNameToString(name);
            }
            if (declaration.parent && declaration.parent.kind === SyntaxKind.VariableDeclaration) {
                return ts.declarationNameToString(declaration.parent.name);
            }
            if (context && !context.encounteredError && !(context.flags & ts.NodeBuilderFlags.AllowAnonymousIdentifier)) {
                context.encounteredError = true;
            }
            switch (declaration.kind) {
                case SyntaxKind.ClassExpression:
                    return "(Anonymous class)";
                case 186 /* FunctionExpression */:
                case 187 /* ArrowFunction */:
                    return "(Anonymous function)";
            }
        }
        if (symbol.syntheticLiteralTypeOrigin) {
            let stringValue = symbol.syntheticLiteralTypeOrigin.value;
            if (!ts.isIdentifierText(stringValue, compilerOptions.target)) {
                return "\"" + ts.escapeString(stringValue, 34 /* doubleQuote */) + "\"";
            }
        }
        return ts.symbolName(symbol);
    }
    function getSymbolDisplayBuilder() {
        /**
         * Writes only the name of the symbol out to the writer. Uses the original source text
         * for the name of the symbol if it is available to match how the user wrote the name.
         */
        function appendSymbolNameOnly(symbol, writer) {
            writer.writeSymbol(getNameOfSymbol(symbol), symbol);
        }
        /**
         * Writes a property access or element access with the name of the symbol out to the writer.
         * Uses the original source text for the name of the symbol if it is available to match how the user wrote the name,
         * ensuring that any names written with literals use element accesses.
         */
        function appendPropertyOrElementAccessForSymbol(symbol, writer) {
            let symbolName = getNameOfSymbol(symbol);
            let firstChar = symbolName.charCodeAt(0);
            let needsElementAccess = !ts.isIdentifierStart(firstChar, languageVersion);
            if (needsElementAccess) {
                writePunctuation(writer, 21 /* OpenBracketToken */);
                if (ts.isSingleOrDoubleQuote(firstChar)) {
                    writer.writeStringLiteral(symbolName);
                }
                else {
                    writer.writeSymbol(symbolName, symbol);
                }
                writePunctuation(writer, 22 /* CloseBracketToken */);
            }
            else {
                writePunctuation(writer, 23 /* DotToken */);
                writer.writeSymbol(symbolName, symbol);
            }
        }
        /**
         * Enclosing declaration is optional when we don't want to get qualified name in the enclosing declaration scope
         * Meaning needs to be specified if the enclosing declaration is given
         */
        function buildSymbolDisplay(symbol, writer, enclosingDeclaration, meaning, flags, typeFlags) {
            let parentSymbol;
            function appendParentTypeArgumentsAndSymbolName(symbol) {
                if (parentSymbol) {
                    // Write type arguments of instantiated class/interface here
                    if (flags & 1 /* WriteTypeParametersOrArguments */) {
                        if (ts.getCheckFlags(symbol) & CheckFlags.Instantiated) {
                            let params = getTypeParametersOfClassOrInterface(parentSymbol.flags & SymbolFlags.Alias ? resolveAlias(parentSymbol) : parentSymbol);
                            buildDisplayForTypeArgumentsAndDelimiters(params, symbol.mapper, writer, enclosingDeclaration);
                        }
                        else {
                            buildTypeParameterDisplayFromSymbol(parentSymbol, writer, enclosingDeclaration);
                        }
                    }
                    appendPropertyOrElementAccessForSymbol(symbol, writer);
                }
                else {
                    appendSymbolNameOnly(symbol, writer);
                }
                parentSymbol = symbol;
            }
            // Let the writer know we just wrote out a symbol.  The declaration emitter writer uses
            // this to determine if an import it has previously seen (and not written out) needs
            // to be written to the file once the walk of the tree is complete.
            //
            // NOTE(cyrusn): This approach feels somewhat unfortunate.  A simple pass over the tree
            // up front (for example, during checking) could determine if we need to emit the imports
            // and we could then access that data during declaration emit.
            writer.trackSymbol(symbol, enclosingDeclaration, meaning);
            /** @param endOfChain Set to false for recursive calls; non-recursive calls should always output something. */
            function walkSymbol(symbol, meaning, endOfChain) {
                let accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, !!(flags & 2 /* UseOnlyExternalAliasing */));
                if (!accessibleSymbolChain ||
                    needsQualification(accessibleSymbolChain[0], enclosingDeclaration, accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(meaning))) {
                    // Go up and add our parent.
                    let parent = getParentOfSymbol(accessibleSymbolChain ? accessibleSymbolChain[0] : symbol);
                    if (parent) {
                        walkSymbol(parent, getQualifiedLeftMeaning(meaning), /*endOfChain*/ false);
                    }
                }
                if (accessibleSymbolChain) {
                    for (let _i = 0, accessibleSymbolChain_1 = accessibleSymbolChain; _i < accessibleSymbolChain_1.length; _i++) {
                        let accessibleSymbol = accessibleSymbolChain_1[_i];
                        appendParentTypeArgumentsAndSymbolName(accessibleSymbol);
                    }
                }
                else if (
                    // If this is the last part of outputting the symbol, always output. The cases apply only to parent symbols.
                    endOfChain ||
                    // If a parent symbol is an external module, don't write it. (We prefer just `x` vs `"foo/bar".x`.)
                    !(!parentSymbol && ts.forEach(symbol.declarations, hasExternalModuleSymbol)) &&
                    // If a parent symbol is an anonymous type, don't write it.
                    !(symbol.flags & (2048 /* TypeLiteral */ | 4096 /* ObjectLiteral */))) {
                    appendParentTypeArgumentsAndSymbolName(symbol);
                }
            }
            // Get qualified name if the symbol is not a type parameter
            // and there is an enclosing declaration or we specifically
            // asked for it
            let isTypeParameter = symbol.flags & SymbolFlags.TypeParameter;
            let typeFormatFlag = 256 /* UseFullyQualifiedType */ & typeFlags;
            if (!isTypeParameter && (enclosingDeclaration || typeFormatFlag)) {
                walkSymbol(symbol, meaning, /*endOfChain*/ true);
            }
            else {
                appendParentTypeArgumentsAndSymbolName(symbol);
            }
        }
        function buildTypeDisplay(type, writer, enclosingDeclaration, globalFlags, symbolStack) {
            let globalFlagsToPass = globalFlags & (32 /* WriteOwnNameForAnyLike */ | 16384 /* WriteClassExpressionAsTypeLiteral */);
            let inObjectTypeLiteral = false;
            return writeType(type, globalFlags);
            function writeType(type, flags) {
                let nextFlags = flags & ~1024 /* InTypeAlias */;
                // Write undefined/null type as any
                if (type.flags & 16793231 /* Intrinsic */) {
                    // Special handling for unknown / resolving types, they should show up as any and not unknown or __resolving
                    writer.writeKeyword(!(globalFlags & 32 /* WriteOwnNameForAnyLike */) && isTypeAny(type)
                        ? "any"
                        : type.intrinsicName);
                }
                else if (type.flags & 16384 /* TypeParameter */ && type.isThisType) {
                    if (inObjectTypeLiteral) {
                        writer.reportInaccessibleThisError();
                    }
                    writer.writeKeyword("this");
                }
                else if (getObjectFlags(type) & 4 /* Reference */) {
                    writeTypeReference(type, nextFlags);
                }
                else if (type.flags & 256 /* EnumLiteral */ && !(type.flags & 65536 /* Union */)) {
                    let parent = getParentOfSymbol(type.symbol);
                    buildSymbolDisplay(parent, writer, enclosingDeclaration, SymbolFlags.Type, 0 /* None */, nextFlags);
                    // In a literal enum type with a single member E { A }, E and E.A denote the
                    // same type. We always display this type simply as E.
                    if (getDeclaredTypeOfSymbol(parent) !== type) {
                        writePunctuation(writer, 23 /* DotToken */);
                        appendSymbolNameOnly(type.symbol, writer);
                    }
                }
                else if (getObjectFlags(type) & 3 /* ClassOrInterface */ || type.flags & (272 /* EnumLike */ | 16384 /* TypeParameter */)) {
                    // The specified symbol flags need to be reinterpreted as type flags
                    buildSymbolDisplay(type.symbol, writer, enclosingDeclaration, SymbolFlags.Type, 0 /* None */, nextFlags);
                }
                else if (!(flags & 1024 /* InTypeAlias */) && type.aliasSymbol &&
                    ((flags & 65536 /* UseAliasDefinedOutsideCurrentScope */) || isTypeSymbolAccessible(type.aliasSymbol, enclosingDeclaration))) {
                    let typeArguments = type.aliasTypeArguments;
                    writeSymbolTypeReference(type.aliasSymbol, typeArguments, 0, ts.length(typeArguments), nextFlags);
                }
                else if (type.flags & 196608 /* UnionOrIntersection */) {
                    writeUnionOrIntersectionType(type, nextFlags);
                }
                else if (getObjectFlags(type) & (16 /* Anonymous */ | 32 /* Mapped */)) {
                    writeAnonymousType(type, nextFlags);
                }
                else if (type.flags & 96 /* StringOrNumberLiteral */) {
                    writer.writeStringLiteral(literalTypeToString(type));
                }
                else if (type.flags & 262144 /* Index */) {
                    if (flags & 128 /* InElementType */) {
                        writePunctuation(writer, 19 /* OpenParenToken */);
                    }
                    writer.writeKeyword("keyof");
                    writeSpace(writer);
                    writeType(type.type, 128 /* InElementType */);
                    if (flags & 128 /* InElementType */) {
                        writePunctuation(writer, 20 /* CloseParenToken */);
                    }
                }
                else if (type.flags & 524288 /* IndexedAccess */) {
                    writeType(type.objectType, 128 /* InElementType */);
                    writePunctuation(writer, 21 /* OpenBracketToken */);
                    writeType(type.indexType, 0 /* None */);
                    writePunctuation(writer, 22 /* CloseBracketToken */);
                }
                else {
                    // Should never get here
                    // { ... }
                    writePunctuation(writer, 17 /* OpenBraceToken */);
                    writeSpace(writer);
                    writePunctuation(writer, 24 /* DotDotDotToken */);
                    writeSpace(writer);
                    writePunctuation(writer, 18 /* CloseBraceToken */);
                }
            }
            function writeTypeList(types, delimiter) {
                for (let i = 0; i < types.length; i++) {
                    if (i > 0) {
                        if (delimiter !== 26 /* CommaToken */) {
                            writeSpace(writer);
                        }
                        writePunctuation(writer, delimiter);
                        writeSpace(writer);
                    }
                    writeType(types[i], delimiter === 26 /* CommaToken */ ? 0 /* None */ : 128 /* InElementType */);
                }
            }
            function writeSymbolTypeReference(symbol, typeArguments, pos, end, flags) {
                // Unnamed function expressions and arrow functions have reserved names that we don't want to display
                if (symbol.flags & 32 /* Class */ || !isReservedMemberName(symbol.escapedName)) {
                    buildSymbolDisplay(symbol, writer, enclosingDeclaration, SymbolFlags.Type, 0 /* None */, flags);
                }
                if (pos < end) {
                    writePunctuation(writer, 27 /* LessThanToken */);
                    writeType(typeArguments[pos], 512 /* InFirstTypeArgument */);
                    pos++;
                    while (pos < end) {
                        writePunctuation(writer, 26 /* CommaToken */);
                        writeSpace(writer);
                        writeType(typeArguments[pos], 0 /* None */);
                        pos++;
                    }
                    writePunctuation(writer, 29 /* GreaterThanToken */);
                }
            }
            function writeTypeReference(type, flags) {
                let typeArguments = type.typeArguments || ts.emptyArray;
                if (type.target === globalArrayType && !(flags & 1 /* WriteArrayAsGenericType */)) {
                    writeType(typeArguments[0], 128 /* InElementType */ | 32768 /* InArrayType */);
                    writePunctuation(writer, 21 /* OpenBracketToken */);
                    writePunctuation(writer, 22 /* CloseBracketToken */);
                }
                else if (type.target.objectFlags & 8 /* Tuple */) {
                    writePunctuation(writer, 21 /* OpenBracketToken */);
                    writeTypeList(type.typeArguments.slice(0, getTypeReferenceArity(type)), 26 /* CommaToken */);
                    writePunctuation(writer, 22 /* CloseBracketToken */);
                }
                else if (flags & 16384 /* WriteClassExpressionAsTypeLiteral */ &&
                    type.symbol.valueDeclaration &&
                    type.symbol.valueDeclaration.kind === SyntaxKind.ClassExpression) {
                    writeAnonymousType(type, flags);
                }
                else {
                    // Write the type reference in the format f<A>.g<B>.C<X, Y> where A and B are type arguments
                    // for outer type parameters, and f and g are the respective declaring containers of those
                    // type parameters.
                    let outerTypeParameters = type.target.outerTypeParameters;
                    let i = 0;
                    if (outerTypeParameters) {
                        let length_2 = outerTypeParameters.length;
                        while (i < length_2) {
                            // Find group of type arguments for type parameters with the same declaring container.
                            let start = i;
                            let parent = getParentSymbolOfTypeParameter(outerTypeParameters[i]);
                            do {
                                i++;
                            } while (i < length_2 && getParentSymbolOfTypeParameter(outerTypeParameters[i]) === parent);
                            // When type parameters are their own type arguments for the whole group (i.e. we have
                            // the default outer type arguments), we don't show the group.
                            if (!ts.rangeEquals(outerTypeParameters, typeArguments, start, i)) {
                                writeSymbolTypeReference(parent, typeArguments, start, i, flags);
                                writePunctuation(writer, 23 /* DotToken */);
                            }
                        }
                    }
                    let typeParameterCount = (type.target.typeParameters || ts.emptyArray).length;
                    writeSymbolTypeReference(type.symbol, typeArguments, i, typeParameterCount, flags);
                }
            }
            function writeUnionOrIntersectionType(type, flags) {
                if (flags & 128 /* InElementType */) {
                    writePunctuation(writer, 19 /* OpenParenToken */);
                }
                if (type.flags & 65536 /* Union */) {
                    writeTypeList(formatUnionTypes(type.types), 49 /* BarToken */);
                }
                else {
                    writeTypeList(type.types, 48 /* AmpersandToken */);
                }
                if (flags & 128 /* InElementType */) {
                    writePunctuation(writer, 20 /* CloseParenToken */);
                }
            }
            function writeAnonymousType(type, flags) {
                let symbol = type.symbol;
                if (symbol) {
                    // Always use 'typeof T' for type of class, enum, and module objects
                    if (symbol.flags & 32 /* Class */ &&
                        !getBaseTypeVariableOfClass(symbol) &&
                        !(symbol.valueDeclaration.kind === SyntaxKind.ClassExpression && flags & 16384 /* WriteClassExpressionAsTypeLiteral */) ||
                        symbol.flags & (384 /* Enum */ | 512 /* ValueModule */)) {
                        writeTypeOfSymbol(type, flags);
                    }
                    else if (shouldWriteTypeOfFunctionSymbol()) {
                        writeTypeOfSymbol(type, flags);
                    }
                    else if (ts.contains(symbolStack, symbol)) {
                        // If type is an anonymous type literal in a type alias declaration, use type alias name
                        let typeAlias = getTypeAliasForTypeLiteral(type);
                        if (typeAlias) {
                            // The specified symbol flags need to be reinterpreted as type flags
                            buildSymbolDisplay(typeAlias, writer, enclosingDeclaration, SymbolFlags.Type, 0 /* None */, flags);
                        }
                        else {
                            // Recursive usage, use any
                            writeKeyword(writer, 119 /* AnyKeyword */);
                        }
                    }
                    else {
                        // Since instantiations of the same anonymous type have the same symbol, tracking symbols instead
                        // of types allows us to catch circular references to instantiations of the same anonymous type
                        // However, in case of class expressions, we want to write both the static side and the instance side.
                        // We skip adding the static side so that the instance side has a chance to be written
                        // before checking for circular references.
                        if (!symbolStack) {
                            symbolStack = [];
                        }
                        let isConstructorObject = type.objectFlags & 16 /* Anonymous */ && type.symbol && type.symbol.flags & 32 /* Class */;
                        if (isConstructorObject) {
                            writeLiteralType(type, flags);
                        }
                        else {
                            symbolStack.push(symbol);
                            writeLiteralType(type, flags);
                            symbolStack.pop();
                        }
                    }
                }
                else {
                    // Anonymous types with no symbol are never circular
                    writeLiteralType(type, flags);
                }
                function shouldWriteTypeOfFunctionSymbol() {
                    let isStaticMethodSymbol = !!(symbol.flags & 8192 /* Method */) && // typeof static method
                        ts.some(symbol.declarations, function (declaration) { return ts.hasModifier(declaration, ModifierFlags.Static); });
                    let isNonLocalFunctionSymbol = !!(symbol.flags & 16 /* Function */) &&
                        (symbol.parent || // is exported function symbol
                            ts.some(symbol.declarations, function (declaration) {
                                return declaration.parent.kind === SyntaxKind.SourceFile || declaration.parent.kind === 234 /* ModuleBlock */;
                            }));
                    if (isStaticMethodSymbol || isNonLocalFunctionSymbol) {
                        // typeof is allowed only for static/non local functions
                        return !!(flags & 4 /* UseTypeOfFunction */) || // use typeof if format flags specify it
                            ts.contains(symbolStack, symbol); // it is type of the symbol uses itself recursively
                    }
                }
            }
            function writeTypeOfSymbol(type, typeFormatFlags) {
                if (typeFormatFlags & 32768 /* InArrayType */) {
                    writePunctuation(writer, 19 /* OpenParenToken */);
                }
                writeKeyword(writer, 103 /* TypeOfKeyword */);
                writeSpace(writer);
                buildSymbolDisplay(type.symbol, writer, enclosingDeclaration, SymbolFlags.Value, 0 /* None */, typeFormatFlags);
                if (typeFormatFlags & 32768 /* InArrayType */) {
                    writePunctuation(writer, 20 /* CloseParenToken */);
                }
            }
            function writePropertyWithModifiers(prop) {
                if (isReadonlySymbol(prop)) {
                    writeKeyword(writer, 131 /* ReadonlyKeyword */);
                    writeSpace(writer);
                }
                buildSymbolDisplay(prop, writer);
                if (prop.flags & 16777216 /* Optional */) {
                    writePunctuation(writer, 55 /* QuestionToken */);
                }
            }
            function shouldAddParenthesisAroundFunctionType(callSignature, flags) {
                if (flags & 128 /* InElementType */) {
                    return true;
                }
                else if (flags & 512 /* InFirstTypeArgument */) {
                    // Add parenthesis around function type for the first type argument to avoid ambiguity
                    let typeParameters = callSignature.target && (flags & 64 /* WriteTypeArgumentsOfSignature */) ?
                        callSignature.target.typeParameters : callSignature.typeParameters;
                    return typeParameters && typeParameters.length !== 0;
                }
                return false;
            }
            function writeLiteralType(type, flags) {
                if (isGenericMappedType(type)) {
                    writeMappedType(type);
                    return;
                }
                let resolved = resolveStructuredTypeMembers(type);
                if (!resolved.properties.length && !resolved.stringIndexInfo && !resolved.numberIndexInfo) {
                    if (!resolved.callSignatures.length && !resolved.constructSignatures.length) {
                        writePunctuation(writer, 17 /* OpenBraceToken */);
                        writePunctuation(writer, 18 /* CloseBraceToken */);
                        return;
                    }
                    if (resolved.callSignatures.length === 1 && !resolved.constructSignatures.length) {
                        let parenthesizeSignature = shouldAddParenthesisAroundFunctionType(resolved.callSignatures[0], flags);
                        if (parenthesizeSignature) {
                            writePunctuation(writer, 19 /* OpenParenToken */);
                        }
                        buildSignatureDisplay(resolved.callSignatures[0], writer, enclosingDeclaration, globalFlagsToPass | 16 /* WriteArrowStyleSignature */, /*kind*/ undefined, symbolStack);
                        if (parenthesizeSignature) {
                            writePunctuation(writer, 20 /* CloseParenToken */);
                        }
                        return;
                    }
                    if (resolved.constructSignatures.length === 1 && !resolved.callSignatures.length) {
                        if (flags & 128 /* InElementType */) {
                            writePunctuation(writer, 19 /* OpenParenToken */);
                        }
                        writeKeyword(writer, 94 /* NewKeyword */);
                        writeSpace(writer);
                        buildSignatureDisplay(resolved.constructSignatures[0], writer, enclosingDeclaration, globalFlagsToPass | 16 /* WriteArrowStyleSignature */, /*kind*/ undefined, symbolStack);
                        if (flags & 128 /* InElementType */) {
                            writePunctuation(writer, 20 /* CloseParenToken */);
                        }
                        return;
                    }
                }
                let saveInObjectTypeLiteral = inObjectTypeLiteral;
                inObjectTypeLiteral = true;
                writePunctuation(writer, 17 /* OpenBraceToken */);
                writer.writeLine();
                writer.increaseIndent();
                writeObjectLiteralType(resolved);
                writer.decreaseIndent();
                writePunctuation(writer, 18 /* CloseBraceToken */);
                inObjectTypeLiteral = saveInObjectTypeLiteral;
            }
            function writeObjectLiteralType(resolved) {
                for (let _i = 0, _a = resolved.callSignatures; _i < _a.length; _i++) {
                    let signature = _a[_i];
                    buildSignatureDisplay(signature, writer, enclosingDeclaration, globalFlagsToPass, /*kind*/ undefined, symbolStack);
                    writePunctuation(writer, 25 /* SemicolonToken */);
                    writer.writeLine();
                }
                for (let _b = 0, _c = resolved.constructSignatures; _b < _c.length; _b++) {
                    let signature = _c[_b];
                    buildSignatureDisplay(signature, writer, enclosingDeclaration, globalFlagsToPass, 1 /* Construct */, symbolStack);
                    writePunctuation(writer, 25 /* SemicolonToken */);
                    writer.writeLine();
                }
                buildIndexSignatureDisplay(resolved.stringIndexInfo, writer, 0 /* String */, enclosingDeclaration, globalFlags, symbolStack);
                buildIndexSignatureDisplay(resolved.numberIndexInfo, writer, 1 /* Number */, enclosingDeclaration, globalFlags, symbolStack);
                for (let _d = 0, _e = resolved.properties; _d < _e.length; _d++) {
                    let p = _e[_d];
                    if (globalFlags & 16384 /* WriteClassExpressionAsTypeLiteral */) {
                        if (p.flags & 4194304 /* Prototype */) {
                            continue;
                        }
                        if (ts.getDeclarationModifierFlagsFromSymbol(p) & (8 /* Private */ | 16 /* Protected */)) {
                            writer.reportPrivateInBaseOfClassExpression(ts.symbolName(p));
                        }
                    }
                    let t = getTypeOfSymbol(p);
                    if (p.flags & (16 /* Function */ | 8192 /* Method */) && !getPropertiesOfObjectType(t).length) {
                        let signatures = getSignaturesOfType(t, 0 /* Call */);
                        for (let _f = 0, signatures_2 = signatures; _f < signatures_2.length; _f++) {
                            let signature = signatures_2[_f];
                            writePropertyWithModifiers(p);
                            buildSignatureDisplay(signature, writer, enclosingDeclaration, globalFlagsToPass, /*kind*/ undefined, symbolStack);
                            writePunctuation(writer, 25 /* SemicolonToken */);
                            writer.writeLine();
                        }
                    }
                    else {
                        writePropertyWithModifiers(p);
                        writePunctuation(writer, 56 /* ColonToken */);
                        writeSpace(writer);
                        writeType(t, globalFlags & 16384 /* WriteClassExpressionAsTypeLiteral */);
                        writePunctuation(writer, 25 /* SemicolonToken */);
                        writer.writeLine();
                    }
                }
            }
            function writeMappedType(type) {
                writePunctuation(writer, 17 /* OpenBraceToken */);
                writer.writeLine();
                writer.increaseIndent();
                if (type.declaration.readonlyToken) {
                    writeKeyword(writer, 131 /* ReadonlyKeyword */);
                    writeSpace(writer);
                }
                writePunctuation(writer, 21 /* OpenBracketToken */);
                appendSymbolNameOnly(getTypeParameterFromMappedType(type).symbol, writer);
                writeSpace(writer);
                writeKeyword(writer, 92 /* InKeyword */);
                writeSpace(writer);
                writeType(getConstraintTypeFromMappedType(type), 0 /* None */);
                writePunctuation(writer, 22 /* CloseBracketToken */);
                if (type.declaration.questionToken) {
                    writePunctuation(writer, 55 /* QuestionToken */);
                }
                writePunctuation(writer, 56 /* ColonToken */);
                writeSpace(writer);
                writeType(getTemplateTypeFromMappedType(type), 0 /* None */);
                writePunctuation(writer, 25 /* SemicolonToken */);
                writer.writeLine();
                writer.decreaseIndent();
                writePunctuation(writer, 18 /* CloseBraceToken */);
            }
        }
        function buildTypeParameterDisplayFromSymbol(symbol, writer, enclosingDeclaration, flags) {
            let targetSymbol = getTargetSymbol(symbol);
            if (targetSymbol.flags & 32 /* Class */ || targetSymbol.flags & 64 /* Interface */ || targetSymbol.flags & 524288 /* TypeAlias */) {
                buildDisplayForTypeParametersAndDelimiters(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol), writer, enclosingDeclaration, flags);
            }
        }
        function buildTypeParameterDisplay(tp, writer, enclosingDeclaration, flags, symbolStack) {
            appendSymbolNameOnly(tp.symbol, writer);
            let constraint = getConstraintOfTypeParameter(tp);
            if (constraint) {
                writeSpace(writer);
                writeKeyword(writer, 85 /* ExtendsKeyword */);
                writeSpace(writer);
                buildTypeDisplay(constraint, writer, enclosingDeclaration, flags, symbolStack);
            }
            let defaultType = getDefaultFromTypeParameter(tp);
            if (defaultType) {
                writeSpace(writer);
                writePunctuation(writer, 58 /* EqualsToken */);
                writeSpace(writer);
                buildTypeDisplay(defaultType, writer, enclosingDeclaration, flags, symbolStack);
            }
        }
        function buildParameterDisplay(p, writer, enclosingDeclaration, flags, symbolStack) {
            let parameterNode = p.valueDeclaration;
            if (parameterNode ? ts.isRestParameter(parameterNode) : isTransientSymbol(p) && p.isRestParameter) {
                writePunctuation(writer, 24 /* DotDotDotToken */);
            }
            if (parameterNode && ts.isBindingPattern(parameterNode.name)) {
                buildBindingPatternDisplay(parameterNode.name, writer, enclosingDeclaration, flags, symbolStack);
            }
            else {
                appendSymbolNameOnly(p, writer);
            }
            if (parameterNode && isOptionalParameter(parameterNode)) {
                writePunctuation(writer, 55 /* QuestionToken */);
            }
            writePunctuation(writer, 56 /* ColonToken */);
            writeSpace(writer);
            let type = getTypeOfSymbol(p);
            if (parameterNode && isRequiredInitializedParameter(parameterNode)) {
                type = getNullableType(type, 2048 /* Undefined */);
            }
            buildTypeDisplay(type, writer, enclosingDeclaration, flags, symbolStack);
        }
        function buildBindingPatternDisplay(bindingPattern, writer, enclosingDeclaration, flags, symbolStack) {
            // We have to explicitly emit square bracket and bracket because these tokens are not stored inside the node.
            if (bindingPattern.kind === 174 /* ObjectBindingPattern */) {
                writePunctuation(writer, 17 /* OpenBraceToken */);
                buildDisplayForCommaSeparatedList(bindingPattern.elements, writer, function (e) { return buildBindingElementDisplay(e, writer, enclosingDeclaration, flags, symbolStack); });
                writePunctuation(writer, 18 /* CloseBraceToken */);
            }
            else if (bindingPattern.kind === 175 /* ArrayBindingPattern */) {
                writePunctuation(writer, 21 /* OpenBracketToken */);
                let elements = bindingPattern.elements;
                buildDisplayForCommaSeparatedList(elements, writer, function (e) { return buildBindingElementDisplay(e, writer, enclosingDeclaration, flags, symbolStack); });
                if (elements && elements.hasTrailingComma) {
                    writePunctuation(writer, 26 /* CommaToken */);
                }
                writePunctuation(writer, 22 /* CloseBracketToken */);
            }
        }
        function buildBindingElementDisplay(bindingElement, writer, enclosingDeclaration, flags, symbolStack) {
            if (ts.isOmittedExpression(bindingElement)) {
                return;
            }
            ts.Debug.assert(bindingElement.kind === 176 /* BindingElement */);
            if (bindingElement.propertyName) {
                writer.writeProperty(ts.getTextOfNode(bindingElement.propertyName));
                writePunctuation(writer, 56 /* ColonToken */);
                writeSpace(writer);
            }
            if (ts.isBindingPattern(bindingElement.name)) {
                buildBindingPatternDisplay(bindingElement.name, writer, enclosingDeclaration, flags, symbolStack);
            }
            else {
                if (bindingElement.dotDotDotToken) {
                    writePunctuation(writer, 24 /* DotDotDotToken */);
                }
                appendSymbolNameOnly(bindingElement.symbol, writer);
            }
        }
        function buildDisplayForTypeParametersAndDelimiters(typeParameters, writer, enclosingDeclaration, flags, symbolStack) {
            if (typeParameters && typeParameters.length) {
                writePunctuation(writer, 27 /* LessThanToken */);
                buildDisplayForCommaSeparatedList(typeParameters, writer, function (p) { return buildTypeParameterDisplay(p, writer, enclosingDeclaration, flags, symbolStack); });
                writePunctuation(writer, 29 /* GreaterThanToken */);
            }
        }
        function buildDisplayForCommaSeparatedList(list, writer, action) {
            for (let i = 0; i < list.length; i++) {
                if (i > 0) {
                    writePunctuation(writer, 26 /* CommaToken */);
                    writeSpace(writer);
                }
                action(list[i]);
            }
        }
        function buildDisplayForTypeArgumentsAndDelimiters(typeParameters, mapper, writer, enclosingDeclaration) {
            if (typeParameters && typeParameters.length) {
                writePunctuation(writer, 27 /* LessThanToken */);
                let flags = 512 /* InFirstTypeArgument */;
                for (let i = 0; i < typeParameters.length; i++) {
                    if (i > 0) {
                        writePunctuation(writer, 26 /* CommaToken */);
                        writeSpace(writer);
                        flags = 0 /* None */;
                    }
                    buildTypeDisplay(mapper(typeParameters[i]), writer, enclosingDeclaration, flags);
                }
                writePunctuation(writer, 29 /* GreaterThanToken */);
            }
        }
        function buildDisplayForParametersAndDelimiters(thisParameter, parameters, writer, enclosingDeclaration, flags, symbolStack) {
            writePunctuation(writer, 19 /* OpenParenToken */);
            if (thisParameter) {
                buildParameterDisplay(thisParameter, writer, enclosingDeclaration, flags, symbolStack);
            }
            for (let i = 0; i < parameters.length; i++) {
                if (i > 0 || thisParameter) {
                    writePunctuation(writer, 26 /* CommaToken */);
                    writeSpace(writer);
                }
                buildParameterDisplay(parameters[i], writer, enclosingDeclaration, flags, symbolStack);
            }
            writePunctuation(writer, 20 /* CloseParenToken */);
        }
        function buildTypePredicateDisplay(predicate, writer, enclosingDeclaration, flags, symbolStack) {
            if (ts.isIdentifierTypePredicate(predicate)) {
                writer.writeParameter(predicate.parameterName);
            }
            else {
                writeKeyword(writer, 99 /* ThisKeyword */);
            }
            writeSpace(writer);
            writeKeyword(writer, 126 /* IsKeyword */);
            writeSpace(writer);
            buildTypeDisplay(predicate.type, writer, enclosingDeclaration, flags, symbolStack);
        }
        function buildReturnTypeDisplay(signature, writer, enclosingDeclaration, flags, symbolStack) {
            let returnType = getReturnTypeOfSignature(signature);
            if (flags & 4096 /* SuppressAnyReturnType */ && isTypeAny(returnType)) {
                return;
            }
            if (flags & 16 /* WriteArrowStyleSignature */) {
                writeSpace(writer);
                writePunctuation(writer, 36 /* EqualsGreaterThanToken */);
            }
            else {
                writePunctuation(writer, 56 /* ColonToken */);
            }
            writeSpace(writer);
            if (signature.typePredicate) {
                buildTypePredicateDisplay(signature.typePredicate, writer, enclosingDeclaration, flags, symbolStack);
            }
            else {
                buildTypeDisplay(returnType, writer, enclosingDeclaration, flags, symbolStack);
            }
        }
        function buildSignatureDisplay(signature, writer, enclosingDeclaration, flags, kind, symbolStack) {
            if (kind === 1 /* Construct */) {
                writeKeyword(writer, 94 /* NewKeyword */);
                writeSpace(writer);
            }
            if (signature.target && (flags & 64 /* WriteTypeArgumentsOfSignature */)) {
                // Instantiated signature, write type arguments instead
                // This is achieved by passing in the mapper separately
                buildDisplayForTypeArgumentsAndDelimiters(signature.target.typeParameters, signature.mapper, writer, enclosingDeclaration);
            }
            else {
                buildDisplayForTypeParametersAndDelimiters(signature.typeParameters, writer, enclosingDeclaration, flags, symbolStack);
            }
            buildDisplayForParametersAndDelimiters(signature.thisParameter, signature.parameters, writer, enclosingDeclaration, flags, symbolStack);
            buildReturnTypeDisplay(signature, writer, enclosingDeclaration, flags, symbolStack);
        }
        function buildIndexSignatureDisplay(info, writer, kind, enclosingDeclaration, globalFlags, symbolStack) {
            if (info) {
                if (info.isReadonly) {
                    writeKeyword(writer, 131 /* ReadonlyKeyword */);
                    writeSpace(writer);
                }
                writePunctuation(writer, 21 /* OpenBracketToken */);
                writer.writeParameter(info.declaration ? ts.declarationNameToString(info.declaration.parameters[0].name) : "x");
                writePunctuation(writer, 56 /* ColonToken */);
                writeSpace(writer);
                switch (kind) {
                    case 1 /* Number */:
                        writeKeyword(writer, 133 /* NumberKeyword */);
                        break;
                    case 0 /* String */:
                        writeKeyword(writer, 136 /* StringKeyword */);
                        break;
                }
                writePunctuation(writer, 22 /* CloseBracketToken */);
                writePunctuation(writer, 56 /* ColonToken */);
                writeSpace(writer);
                buildTypeDisplay(info.type, writer, enclosingDeclaration, globalFlags, symbolStack);
                writePunctuation(writer, 25 /* SemicolonToken */);
                writer.writeLine();
            }
        }
        return _displayBuilder || (_displayBuilder = {
            buildSymbolDisplay: buildSymbolDisplay,
            buildTypeDisplay: buildTypeDisplay,
            buildTypeParameterDisplay: buildTypeParameterDisplay,
            buildTypePredicateDisplay: buildTypePredicateDisplay,
            buildParameterDisplay: buildParameterDisplay,
            buildDisplayForParametersAndDelimiters: buildDisplayForParametersAndDelimiters,
            buildDisplayForTypeParametersAndDelimiters: buildDisplayForTypeParametersAndDelimiters,
            buildTypeParameterDisplayFromSymbol: buildTypeParameterDisplayFromSymbol,
            buildSignatureDisplay: buildSignatureDisplay,
            buildIndexSignatureDisplay: buildIndexSignatureDisplay,
            buildReturnTypeDisplay: buildReturnTypeDisplay
        });
    }
    function isDeclarationVisible(node) {
        if (node) {
            let links = getNodeLinks(node);
            if (links.isVisible === undefined) {
                links.isVisible = !!determineIfDeclarationIsVisible();
            }
            return links.isVisible;
        }
        return false;
        function determineIfDeclarationIsVisible() {
            switch (node.kind) {
                case 176 /* BindingElement */:
                    return isDeclarationVisible(node.parent.parent);
                case SyntaxKind.VariableDeclaration:
                    if (ts.isBindingPattern(node.name) &&
                        !node.name.elements.length) {
                        // If the binding pattern is empty, this variable declaration is not visible
                        return false;
                    }
                // falls through
                case SyntaxKind.ModuleDeclaration:
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.InterfaceDeclaration:
                case 231 /* TypeAliasDeclaration */:
                case 228 /* FunctionDeclaration */:
                case SyntaxKind.EnumDeclaration:
                case 237 /* ImportEqualsDeclaration */:
                    // external module augmentation is always visible
                    if (ts.isExternalModuleAugmentation(node)) {
                        return true;
                    }
                    let parent = getDeclarationContainer(node);
                    // If the node is not exported or it is not ambient module element (except import declaration)
                    if (!(ts.getCombinedModifierFlags(node) & 1 /* Export */) &&
                        !(node.kind !== 237 /* ImportEqualsDeclaration */ && parent.kind !== SyntaxKind.SourceFile && ts.isInAmbientContext(parent))) {
                        return isGlobalSourceFile(parent);
                    }
                    // Exported members/ambient module elements (exception import declaration) are visible if parent is visible
                    return isDeclarationVisible(parent);
                case SyntaxKind.PropertyDeclaration:
                case SyntaxKind.PropertySignature:
                case 153 /* GetAccessor */:
                case 154 /* SetAccessor */:
                case SyntaxKind.MethodDeclaration:
                case 150 /* MethodSignature */:
                    if (ts.hasModifier(node, 8 /* Private */ | 16 /* Protected */)) {
                        // Private/protected properties/methods are not visible
                        return false;
                    }
                // Public properties/methods are visible if its parents are visible, so:
                // falls through
                case 152 /* Constructor */:
                case 156 /* ConstructSignature */:
                case 155 /* CallSignature */:
                case 157 /* IndexSignature */:
                case SyntaxKind.Parameter:
                case 234 /* ModuleBlock */:
                case 160 /* FunctionType */:
                case 161 /* ConstructorType */:
                case 163 /* TypeLiteral */:
                case 159 /* TypeReference */:
                case 164 /* ArrayType */:
                case 165 /* TupleType */:
                case 166 /* UnionType */:
                case 167 /* IntersectionType */:
                case 168 /* ParenthesizedType */:
                    return isDeclarationVisible(node.parent);
                // Default binding, import specifier and namespace import is visible
                // only on demand so by default it is not visible
                case 239 /* ImportClause */:
                case 240 /* NamespaceImport */:
                case 242 /* ImportSpecifier */:
                    return false;
                // Type parameters are always visible
                case SyntaxKind.TypeParameter:
                // Source file and namespace export are always visible
                case SyntaxKind.SourceFile:
                case 236 /* NamespaceExportDeclaration */:
                    return true;
                // Export assignments do not create name bindings outside the module
                case SyntaxKind.ExportAssignment:
                    return false;
                default:
                    return false;
            }
        }
    }
    function collectLinkedAliases(node) {
        let exportSymbol;
        if (node.parent && node.parent.kind === SyntaxKind.ExportAssignment) {
            exportSymbol = resolveName(node.parent, node.escapedText, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias, ts.Diagnostics.Cannot_find_name_0, node, /*isUse*/ false);
        }
        else if (node.parent.kind === SyntaxKind.ExportSpecifier) {
            exportSymbol = getTargetOfExportSpecifier(node.parent, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias);
        }
        let result = [];
        if (exportSymbol) {
            buildVisibleNodeList(exportSymbol.declarations);
        }
        return result;
        function buildVisibleNodeList(declarations) {
            ts.forEach(declarations, function (declaration) {
                getNodeLinks(declaration).isVisible = true;
                let resultNode = getAnyImportSyntax(declaration) || declaration;
                ts.pushIfUnique(result, resultNode);
                if (ts.isInternalModuleImportEqualsDeclaration(declaration)) {
                    // Add the referenced top container visible
                    let internalModuleReference = declaration.moduleReference;
                    let firstIdentifier = getFirstIdentifier(internalModuleReference);
                    let importSymbol = resolveName(declaration, firstIdentifier.escapedText, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, undefined, undefined, /*isUse*/ false);
                    if (importSymbol) {
                        buildVisibleNodeList(importSymbol.declarations);
                    }
                }
            });
        }
    }
    /**
     * Push an entry on the type resolution stack. If an entry with the given target and the given property name
     * is already on the stack, and no entries in between already have a type, then a circularity has occurred.
     * In this case, the result values of the existing entry and all entries pushed after it are changed to false,
     * and the value false is returned. Otherwise, the new entry is just pushed onto the stack, and true is returned.
     * In order to see if the same query has already been done before, the target object and the propertyName both
     * must match the one passed in.
     *
     * @param target The symbol, type, or signature whose type is being queried
     * @param propertyName The property name that should be used to query the target for its type
     */
    function pushTypeResolution(target, propertyName) {
        let resolutionCycleStartIndex = findResolutionCycleStartIndex(target, propertyName);
        if (resolutionCycleStartIndex >= 0) {
            // A cycle was found
            let length_3 = resolutionTargets.length;
            for (let i = resolutionCycleStartIndex; i < length_3; i++) {
                resolutionResults[i] = false;
            }
            return false;
        }
        resolutionTargets.push(target);
        resolutionResults.push(/*items*/ true);
        resolutionPropertyNames.push(propertyName);
        return true;
    }
    function findResolutionCycleStartIndex(target, propertyName) {
        for (let i = resolutionTargets.length - 1; i >= 0; i--) {
            if (hasType(resolutionTargets[i], resolutionPropertyNames[i])) {
                return -1;
            }
            if (resolutionTargets[i] === target && resolutionPropertyNames[i] === propertyName) {
                return i;
            }
        }
        return -1;
    }
    function hasType(target, propertyName) {
        if (propertyName === 0 /* Type */) {
            return getSymbolLinks(target).type;
        }
        if (propertyName === 2 /* DeclaredType */) {
            return getSymbolLinks(target).declaredType;
        }
        if (propertyName === 1 /* ResolvedBaseConstructorType */) {
            return target.resolvedBaseConstructorType;
        }
        if (propertyName === 3 /* ResolvedReturnType */) {
            return target.resolvedReturnType;
        }
        ts.Debug.fail("Unhandled TypeSystemPropertyName " + propertyName);
    }
    // Pop an entry from the type resolution stack and return its associated result value. The result value will
    // be true if no circularities were detected, or false if a circularity was found.
    function popTypeResolution() {
        resolutionTargets.pop();
        resolutionPropertyNames.pop();
        return resolutionResults.pop();
    }
    function getDeclarationContainer(node) {
        node = ts.findAncestor(ts.getRootDeclaration(node), function (node) {
            switch (node.kind) {
                case SyntaxKind.VariableDeclaration:
                case 227 /* VariableDeclarationList */:
                case 242 /* ImportSpecifier */:
                case 241 /* NamedImports */:
                case 240 /* NamespaceImport */:
                case 239 /* ImportClause */:
                    return false;
                default:
                    return true;
            }
        });
        return node && node.parent;
    }
    function getTypeOfPrototypeProperty(prototype) {
        // TypeScript 1.0 spec (April 2014): 8.4
        // Every class automatically contains a static property member named 'prototype',
        // the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.
        // It is an error to explicitly declare a static property member with the name 'prototype'.
        let classType = getDeclaredTypeOfSymbol(getParentOfSymbol(prototype));
        return classType.typeParameters ? createTypeReference(classType, ts.map(classType.typeParameters, function (_) { return anyType; })) : classType;
    }
    // Return the type of the given property in the given type, or undefined if no such property exists
    function getTypeOfPropertyOfType(type, name) {
        let prop = getPropertyOfType(type, name);
        return prop ? getTypeOfSymbol(prop) : undefined;
    }
    function isTypeAny(type) {
        return type && (type.flags & 1 /* Any */) !== 0;
    }
    // Return the type of a binding element parent. We check SymbolLinks first to see if a type has been
    // assigned by contextual typing.
    function getTypeForBindingElementParent(node) {
        let symbol = getSymbolOfNode(node);
        return symbol && getSymbolLinks(symbol).type || getTypeForVariableLikeDeclaration(node, /*includeOptionality*/ false);
    }
    function isComputedNonLiteralName(name) {
        return name.kind === 144 /* ComputedPropertyName */ && !ts.isStringOrNumericLiteral(name.expression);
    }
    function getRestType(source, properties, symbol) {
        source = filterType(source, function (t) { return !(t.flags & 6144 /* Nullable */); });
        if (source.flags & 8192 /* Never */) {
            return emptyObjectType;
        }
        if (source.flags & 65536 /* Union */) {
            return mapType(source, function (t) { return getRestType(t, properties, symbol); });
        }
        let members = ts.createSymbolTable();
        let names = ts.createUnderscoreEscapedMap();
        for (let _i = 0, properties_2 = properties; _i < properties_2.length; _i++) {
            let name = properties_2[_i];
            names.set(ts.getTextOfPropertyName(name), true);
        }
        for (let _a = 0, _b = getPropertiesOfType(source); _a < _b.length; _a++) {
            let prop = _b[_a];
            let inNamesToRemove = names.has(prop.escapedName);
            let isPrivate = ts.getDeclarationModifierFlagsFromSymbol(prop) & (8 /* Private */ | 16 /* Protected */);
            let isSetOnlyAccessor = prop.flags & 65536 /* SetAccessor */ && !(prop.flags & 32768 /* GetAccessor */);
            if (!inNamesToRemove && !isPrivate && !isClassMethod(prop) && !isSetOnlyAccessor) {
                members.set(prop.escapedName, prop);
            }
        }
        let stringIndexInfo = getIndexInfoOfType(source, 0 /* String */);
        let numberIndexInfo = getIndexInfoOfType(source, 1 /* Number */);
        return createAnonymousType(symbol, members, ts.emptyArray, ts.emptyArray, stringIndexInfo, numberIndexInfo);
    }
    /** Return the inferred type for a binding element */
    function getTypeForBindingElement(declaration) {
        let pattern = declaration.parent;
        let parentType = getTypeForBindingElementParent(pattern.parent);
        // If parent has the unknown (error) type, then so does this binding element
        if (parentType === unknownType) {
            return unknownType;
        }
        // If no type was specified or inferred for parent,
        // infer from the initializer of the binding element if one is present.
        // Otherwise, go with the undefined type of the parent.
        if (!parentType) {
            return declaration.initializer ? checkDeclarationInitializer(declaration) : parentType;
        }
        if (isTypeAny(parentType)) {
            return parentType;
        }
        let type;
        if (pattern.kind === 174 /* ObjectBindingPattern */) {
            if (declaration.dotDotDotToken) {
                if (!isValidSpreadType(parentType)) {
                    error(declaration, ts.Diagnostics.Rest_types_may_only_be_created_from_object_types);
                    return unknownType;
                }
                let literalMembers = [];
                for (let _i = 0, _a = pattern.elements; _i < _a.length; _i++) {
                    let element = _a[_i];
                    if (!element.dotDotDotToken) {
                        literalMembers.push(element.propertyName || element.name);
                    }
                }
                type = getRestType(parentType, literalMembers, declaration.symbol);
            }
            else {
                // Use explicitly specified property name ({ p: xxx } form), or otherwise the implied name ({ p } form)
                let name = declaration.propertyName || declaration.name;
                if (isComputedNonLiteralName(name)) {
                    // computed properties with non-literal names are treated as 'any'
                    return anyType;
                }
                // Use type of the specified property, or otherwise, for a numeric name, the type of the numeric index signature,
                // or otherwise the type of the string index signature.
                let text = ts.getTextOfPropertyName(name);
                let declaredType = getTypeOfPropertyOfType(parentType, text);
                type = declaredType && getFlowTypeOfReference(declaration, declaredType) ||
                    isNumericLiteralName(text) && getIndexTypeOfType(parentType, 1 /* Number */) ||
                    getIndexTypeOfType(parentType, 0 /* String */);
                if (!type) {
                    error(name, ts.Diagnostics.Type_0_has_no_property_1_and_no_string_index_signature, typeToString(parentType), ts.declarationNameToString(name));
                    return unknownType;
                }
            }
        }
        else {
            // This elementType will be used if the specific property corresponding to this index is not
            // present (aka the tuple element property). This call also checks that the parentType is in
            // fact an iterable or array (depending on target language).
            let elementType = checkIteratedTypeOrElementType(parentType, pattern, /*allowStringInput*/ false, /*allowAsyncIterables*/ false);
            if (declaration.dotDotDotToken) {
                // Rest element has an array type with the same element type as the parent type
                type = createArrayType(elementType);
            }
            else {
                // Use specific property type when parent is a tuple or numeric index type when parent is an array
                let propName = "" + ts.indexOf(pattern.elements, declaration);
                type = isTupleLikeType(parentType)
                    ? getTypeOfPropertyOfType(parentType, propName)
                    : elementType;
                if (!type) {
                    if (isTupleType(parentType)) {
                        error(declaration, ts.Diagnostics.Tuple_type_0_with_length_1_cannot_be_assigned_to_tuple_with_length_2, typeToString(parentType), getTypeReferenceArity(parentType), pattern.elements.length);
                    }
                    else {
                        error(declaration, ts.Diagnostics.Type_0_has_no_property_1, typeToString(parentType), propName);
                    }
                    return unknownType;
                }
            }
        }
        // In strict null checking mode, if a default value of a non-undefined type is specified, remove
        // undefined from the final type.
        if (strictNullChecks && declaration.initializer && !(getFalsyFlags(checkExpressionCached(declaration.initializer)) & 2048 /* Undefined */)) {
            type = getTypeWithFacts(type, 131072 /* NEUndefined */);
        }
        return declaration.initializer ?
            getUnionType([type, checkExpressionCached(declaration.initializer)], /*subtypeReduction*/ true) :
            type;
    }
    function getTypeForDeclarationFromJSDocComment(declaration) {
        let jsdocType = ts.getJSDocType(declaration);
        if (jsdocType) {
            return getTypeFromTypeNode(jsdocType);
        }
        return undefined;
    }
    function isNullOrUndefined(node) {
        let expr = ts.skipParentheses(node);
        return expr.kind === 95 /* NullKeyword */ || expr.kind === 71 /* Identifier */ && getResolvedSymbol(expr) === undefinedSymbol;
    }
    function isEmptyArrayLiteral(node) {
        let expr = ts.skipParentheses(node);
        return expr.kind === 177 /* ArrayLiteralExpression */ && expr.elements.length === 0;
    }
    function addOptionality(type, optional) {
        return strictNullChecks && optional ? getNullableType(type, 2048 /* Undefined */) : type;
    }
    // Return the inferred type for a variable, parameter, or property declaration
    function getTypeForVariableLikeDeclaration(declaration, includeOptionality) {
        // A variable declared in a for..in statement is of type string, or of type keyof T when the
        // right hand expression is of a type parameter type.
        if (declaration.parent.parent.kind === 215 /* ForInStatement */) {
            let indexType = getIndexType(checkNonNullExpression(declaration.parent.parent.expression));
            return indexType.flags & (16384 /* TypeParameter */ | 262144 /* Index */) ? indexType : stringType;
        }
        if (declaration.parent.parent.kind === SyntaxKind.ForOfStatement) {
            // checkRightHandSideOfForOf will return undefined if the for-of expression type was
            // missing properties/signatures required to get its iteratedType (like
            // [Symbol.iterator] or next). This may be because we accessed properties from anyType,
            // or it may have led to an error inside getElementTypeOfIterable.
            let forOfStatement = declaration.parent.parent;
            return checkRightHandSideOfForOf(forOfStatement.expression, forOfStatement.awaitModifier) || anyType;
        }
        if (ts.isBindingPattern(declaration.parent)) {
            return getTypeForBindingElement(declaration);
        }
        // Use type from type annotation if one is present
        let typeNode = ts.getEffectiveTypeAnnotationNode(declaration);
        if (typeNode) {
            let declaredType = getTypeFromTypeNode(typeNode);
            return addOptionality(declaredType, /*optional*/ declaration.questionToken && includeOptionality);
        }
        if ((noImplicitAny || ts.isInJavaScriptFile(declaration)) &&
            declaration.kind === SyntaxKind.VariableDeclaration && !ts.isBindingPattern(declaration.name) &&
            !(ts.getCombinedModifierFlags(declaration) & 1 /* Export */) && !ts.isInAmbientContext(declaration)) {
            // If --noImplicitAny is on or the declaration is in a Javascript file,
            // use control flow tracked 'any' type for non-ambient, non-exported let or let variables with no
            // initializer or a 'null' or 'undefined' initializer.
            if (!(ts.getCombinedNodeFlags(declaration) & 2 /* Const */) && (!declaration.initializer || isNullOrUndefined(declaration.initializer))) {
                return autoType;
            }
            // Use control flow tracked 'any[]' type for non-ambient, non-exported variables with an empty array
            // literal initializer.
            if (declaration.initializer && isEmptyArrayLiteral(declaration.initializer)) {
                return autoArrayType;
            }
        }
        if (declaration.kind === SyntaxKind.Parameter) {
            let func = declaration.parent;
            // For a parameter of a set accessor, use the type of the get accessor if one is present
            if (func.kind === 154 /* SetAccessor */ && !ts.hasDynamicName(func)) {
                let getter = ts.getDeclarationOfKind(declaration.parent.symbol, 153 /* GetAccessor */);
                if (getter) {
                    let getterSignature = getSignatureFromDeclaration(getter);
                    let thisParameter = getAccessorThisParameter(func);
                    if (thisParameter && declaration === thisParameter) {
                        // Use the type from the *getter*
                        ts.Debug.assert(!thisParameter.type);
                        return getTypeOfSymbol(getterSignature.thisParameter);
                    }
                    return getReturnTypeOfSignature(getterSignature);
                }
            }
            // Use contextual parameter type if one is available
            let type = void 0;
            if (declaration.symbol.escapedName === "this") {
                type = getContextualThisParameterType(func);
            }
            else {
                type = getContextuallyTypedParameterType(declaration);
            }
            if (type) {
                return addOptionality(type, /*optional*/ declaration.questionToken && includeOptionality);
            }
        }
        // Use the type of the initializer expression if one is present
        if (declaration.initializer) {
            let type = checkDeclarationInitializer(declaration);
            return addOptionality(type, /*optional*/ declaration.questionToken && includeOptionality);
        }
        if (ts.isJsxAttribute(declaration)) {
            // if JSX attribute doesn't have initializer, by default the attribute will have boolean value of true.
            // I.e <Elem attr /> is sugar for <Elem attr={true} />
            return trueType;
        }
        // If it is a short-hand property assignment, use the type of the identifier
        if (declaration.kind === 265 /* ShorthandPropertyAssignment */) {
            return checkIdentifier(declaration.name);
        }
        // If the declaration specifies a binding pattern, use the type implied by the binding pattern
        if (ts.isBindingPattern(declaration.name)) {
            return getTypeFromBindingPattern(declaration.name, /*includePatternInType*/ false, /*reportErrors*/ true);
        }
        // No type specified and nothing can be inferred
        return undefined;
    }
    function getWidenedTypeFromJSSpecialPropertyDeclarations(symbol) {
        let types = [];
        let definedInConstructor = false;
        let definedInMethod = false;
        let jsDocType;
        for (let _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
            let declaration = _a[_i];
            let expression = declaration.kind === 194 /* BinaryExpression */ ? declaration :
                declaration.kind === 179 /* PropertyAccessExpression */ ? ts.getAncestor(declaration, 194 /* BinaryExpression */) :
                    undefined;
            if (!expression) {
                return unknownType;
            }
            if (ts.isPropertyAccessExpression(expression.left) && expression.left.expression.kind === 99 /* ThisKeyword */) {
                if (ts.getThisContainer(expression, /*includeArrowFunctions*/ false).kind === 152 /* Constructor */) {
                    definedInConstructor = true;
                }
                else {
                    definedInMethod = true;
                }
            }
            // If there is a JSDoc type, use it
            let type_1 = getTypeForDeclarationFromJSDocComment(expression.parent);
            if (type_1) {
                let declarationType = getWidenedType(type_1);
                if (!jsDocType) {
                    jsDocType = declarationType;
                }
                else if (jsDocType !== unknownType && declarationType !== unknownType && !isTypeIdenticalTo(jsDocType, declarationType)) {
                    let name = ts.getNameOfDeclaration(declaration);
                    error(name, ts.Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2, ts.declarationNameToString(name), typeToString(jsDocType), typeToString(declarationType));
                }
            }
            else if (!jsDocType) {
                // If we don't have an explicit JSDoc type, get the type from the expression.
                types.push(getWidenedLiteralType(checkExpressionCached(expression.right)));
            }
        }
        let type = jsDocType || getUnionType(types, /*subtypeReduction*/ true);
        return getWidenedType(addOptionality(type, definedInMethod && !definedInConstructor));
    }
    // Return the type implied by a binding pattern element. This is the type of the initializer of the element if
    // one is present. Otherwise, if the element is itself a binding pattern, it is the type implied by the binding
    // pattern. Otherwise, it is the type any.
    function getTypeFromBindingElement(element, includePatternInType, reportErrors) {
        if (element.initializer) {
            return checkDeclarationInitializer(element);
        }
        if (ts.isBindingPattern(element.name)) {
            return getTypeFromBindingPattern(element.name, includePatternInType, reportErrors);
        }
        if (reportErrors && noImplicitAny && !declarationBelongsToPrivateAmbientMember(element)) {
            reportImplicitAnyError(element, anyType);
        }
        return anyType;
    }
    // Return the type implied by an object binding pattern
    function getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors) {
        let members = ts.createSymbolTable();
        let stringIndexInfo;
        let hasComputedProperties = false;
        ts.forEach(pattern.elements, function (e) {
            let name = e.propertyName || e.name;
            if (isComputedNonLiteralName(name)) {
                // do not include computed properties in the implied type
                hasComputedProperties = true;
                return;
            }
            if (e.dotDotDotToken) {
                stringIndexInfo = createIndexInfo(anyType, /*isReadonly*/ false);
                return;
            }
            let text = ts.getTextOfPropertyName(name);
            let flags = SymbolFlags.Property | (e.initializer ? 16777216 /* Optional */ : 0);
            let symbol = createSymbol(flags, text);
            symbol.type = getTypeFromBindingElement(e, includePatternInType, reportErrors);
            symbol.bindingElement = e;
            members.set(symbol.escapedName, symbol);
        });
        let result = createAnonymousType(undefined, members, ts.emptyArray, ts.emptyArray, stringIndexInfo, undefined);
        if (includePatternInType) {
            result.pattern = pattern;
        }
        if (hasComputedProperties) {
            result.objectFlags |= 512 /* ObjectLiteralPatternWithComputedProperties */;
        }
        return result;
    }
    // Return the type implied by an array binding pattern
    function getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors) {
        let elements = pattern.elements;
        let lastElement = ts.lastOrUndefined(elements);
        if (elements.length === 0 || (!ts.isOmittedExpression(lastElement) && lastElement.dotDotDotToken)) {
            return languageVersion >= 2 /* ES2015 */ ? createIterableType(anyType) : anyArrayType;
        }
        // If the pattern has at least one element, and no rest element, then it should imply a tuple type.
        let elementTypes = ts.map(elements, function (e) { return ts.isOmittedExpression(e) ? anyType : getTypeFromBindingElement(e, includePatternInType, reportErrors); });
        let result = createTupleType(elementTypes);
        if (includePatternInType) {
            result = cloneTypeReference(result);
            result.pattern = pattern;
        }
        return result;
    }
    // Return the type implied by a binding pattern. This is the type implied purely by the binding pattern itself
    // and without regard to its context (i.e. without regard any type annotation or initializer associated with the
    // declaration in which the binding pattern is contained). For example, the implied type of [x, y] is [any, any]
    // and the implied type of { x, y: z = 1 } is { x: any; y: number; }. The type implied by a binding pattern is
    // used as the contextual type of an initializer associated with the binding pattern. Also, for a destructuring
    // parameter with no type annotation or initializer, the type implied by the binding pattern becomes the type of
    // the parameter.
    function getTypeFromBindingPattern(pattern, includePatternInType, reportErrors) {
        return pattern.kind === 174 /* ObjectBindingPattern */
            ? getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors)
            : getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors);
    }
    // Return the type associated with a variable, parameter, or property declaration. In the simple case this is the type
    // specified in a type annotation or inferred from an initializer. However, in the case of a destructuring declaration it
    // is a bit more involved. For example:
    //
    //   let [x, s = ""] = [1, "one"];
    //
    // Here, the array literal [1, "one"] is contextually typed by the type [any, string], which is the implied type of the
    // binding pattern [x, s = ""]. Because the contextual type is a tuple type, the resulting type of [1, "one"] is the
    // tuple type [number, string]. Thus, the type inferred for 'x' is number and the type inferred for 's' is string.
    function getWidenedTypeForVariableLikeDeclaration(declaration, reportErrors) {
        let type = getTypeForVariableLikeDeclaration(declaration, /*includeOptionality*/ true);
        if (type) {
            if (reportErrors) {
                reportErrorsFromWidening(declaration, type);
            }
            // During a normal type check we'll never get to here with a property assignment (the check of the containing
            // object literal uses a different path). We exclude widening only so that language services and type verification
            // tools see the actual type.
            if (declaration.kind === 264 /* PropertyAssignment */) {
                return type;
            }
            return getWidenedType(type);
        }
        // Rest parameters default to type any[], other parameters default to type any
        type = declaration.dotDotDotToken ? anyArrayType : anyType;
        // Report implicit any errors unless this is a private property within an ambient declaration
        if (reportErrors && noImplicitAny) {
            if (!declarationBelongsToPrivateAmbientMember(declaration)) {
                reportImplicitAnyError(declaration, type);
            }
        }
        return type;
    }
    function declarationBelongsToPrivateAmbientMember(declaration) {
        let root = ts.getRootDeclaration(declaration);
        let memberDeclaration = root.kind === SyntaxKind.Parameter ? root.parent : root;
        return isPrivateWithinAmbient(memberDeclaration);
    }
    function getTypeOfVariableOrParameterOrProperty(symbol) {
        let links = getSymbolLinks(symbol);
        if (!links.type) {
            // Handle prototype property
            if (symbol.flags & 4194304 /* Prototype */) {
                return links.type = getTypeOfPrototypeProperty(symbol);
            }
            // Handle catch clause variables
            let declaration = symbol.valueDeclaration;
            if (ts.isCatchClauseVariableDeclarationOrBindingElement(declaration)) {
                return links.type = anyType;
            }
            // Handle export default expressions
            if (declaration.kind === SyntaxKind.ExportAssignment) {
                return links.type = checkExpression(declaration.expression);
            }
            if (ts.isInJavaScriptFile(declaration) && ts.isJSDocPropertyLikeTag(declaration) && declaration.typeExpression) {
                return links.type = getTypeFromTypeNode(declaration.typeExpression.type);
            }
            // Handle variable, parameter or property
            if (!pushTypeResolution(symbol, 0 /* Type */)) {
                return unknownType;
            }
            let type = void 0;
            // Handle certain special assignment kinds, which happen to union across multiple declarations:
            // * module.exports = expr
            // * exports.p = expr
            // * this.p = expr
            // * className.prototype.method = expr
            if (declaration.kind === 194 /* BinaryExpression */ ||
                declaration.kind === 179 /* PropertyAccessExpression */ && declaration.parent.kind === 194 /* BinaryExpression */) {
                type = getWidenedTypeFromJSSpecialPropertyDeclarations(symbol);
            }
            else {
                type = getWidenedTypeForVariableLikeDeclaration(declaration, /*reportErrors*/ true);
            }
            if (!popTypeResolution()) {
                type = reportCircularityError(symbol);
            }
            links.type = type;
        }
        return links.type;
    }
    function getAnnotatedAccessorType(accessor) {
        if (accessor) {
            if (accessor.kind === 153 /* GetAccessor */) {
                let getterTypeAnnotation = ts.getEffectiveReturnTypeNode(accessor);
                return getterTypeAnnotation && getTypeFromTypeNode(getterTypeAnnotation);
            }
            else {
                let setterTypeAnnotation = ts.getEffectiveSetAccessorTypeAnnotationNode(accessor);
                return setterTypeAnnotation && getTypeFromTypeNode(setterTypeAnnotation);
            }
        }
        return undefined;
    }
    function getAnnotatedAccessorThisParameter(accessor) {
        let parameter = getAccessorThisParameter(accessor);
        return parameter && parameter.symbol;
    }
    function getThisTypeOfDeclaration(declaration) {
        return getThisTypeOfSignature(getSignatureFromDeclaration(declaration));
    }
    function getTypeOfAccessors(symbol) {
        let links = getSymbolLinks(symbol);
        if (!links.type) {
            let getter = ts.getDeclarationOfKind(symbol, 153 /* GetAccessor */);
            let setter = ts.getDeclarationOfKind(symbol, 154 /* SetAccessor */);
            if (getter && ts.isInJavaScriptFile(getter)) {
                let jsDocType = getTypeForDeclarationFromJSDocComment(getter);
                if (jsDocType) {
                    return links.type = jsDocType;
                }
            }
            if (!pushTypeResolution(symbol, 0 /* Type */)) {
                return unknownType;
            }
            let type = void 0;
            // First try to see if the user specified a return type on the get-accessor.
            let getterReturnType = getAnnotatedAccessorType(getter);
            if (getterReturnType) {
                type = getterReturnType;
            }
            else {
                // If the user didn't specify a return type, try to use the set-accessor's parameter type.
                let setterParameterType = getAnnotatedAccessorType(setter);
                if (setterParameterType) {
                    type = setterParameterType;
                }
                else {
                    // If there are no specified types, try to infer it from the body of the get accessor if it exists.
                    if (getter && getter.body) {
                        type = getReturnTypeFromBody(getter);
                    }
                    else {
                        if (noImplicitAny) {
                            if (setter) {
                                error(setter, ts.Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation, symbolToString(symbol));
                            }
                            else {
                                ts.Debug.assert(!!getter, "there must existed getter as we are current checking either setter or getter in this function");
                                error(getter, ts.Diagnostics.Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation, symbolToString(symbol));
                            }
                        }
                        type = anyType;
                    }
                }
            }
            if (!popTypeResolution()) {
                type = anyType;
                if (noImplicitAny) {
                    let getter_1 = ts.getDeclarationOfKind(symbol, 153 /* GetAccessor */);
                    error(getter_1, ts.Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, symbolToString(symbol));
                }
            }
            links.type = type;
        }
        return links.type;
    }
    function getBaseTypeVariableOfClass(symbol) {
        let baseConstructorType = getBaseConstructorTypeOfClass(getDeclaredTypeOfClassOrInterface(symbol));
        return baseConstructorType.flags & 540672 /* TypeVariable */ ? baseConstructorType : undefined;
    }
    function getTypeOfFuncClassEnumModule(symbol) {
        let links = getSymbolLinks(symbol);
        if (!links.type) {
            if (symbol.flags & 1536 /* Module */ && ts.isShorthandAmbientModuleSymbol(symbol)) {
                links.type = anyType;
            }
            else {
                let type = createObjectType(16 /* Anonymous */, symbol);
                if (symbol.flags & 32 /* Class */) {
                    let baseTypeVariable = getBaseTypeVariableOfClass(symbol);
                    links.type = baseTypeVariable ? getIntersectionType([type, baseTypeVariable]) : type;
                }
                else {
                    links.type = strictNullChecks && symbol.flags & 16777216 /* Optional */ ? getNullableType(type, 2048 /* Undefined */) : type;
                }
            }
        }
        return links.type;
    }
    function getTypeOfEnumMember(symbol) {
        let links = getSymbolLinks(symbol);
        if (!links.type) {
            links.type = getDeclaredTypeOfEnumMember(symbol);
        }
        return links.type;
    }
    function getTypeOfAlias(symbol) {
        let links = getSymbolLinks(symbol);
        if (!links.type) {
            let targetSymbol = resolveAlias(symbol);
            // It only makes sense to get the type of a value symbol. If the result of resolving
            // the alias is not a value, then it has no type. To get the type associated with a
            // type symbol, call getDeclaredTypeOfSymbol.
            // This check is important because without it, a call to getTypeOfSymbol could end
            // up recursively calling getTypeOfAlias, causing a stack overflow.
            links.type = targetSymbol.flags & SymbolFlags.Value
                ? getTypeOfSymbol(targetSymbol)
                : unknownType;
        }
        return links.type;
    }
    function getTypeOfInstantiatedSymbol(symbol) {
        let links = getSymbolLinks(symbol);
        if (!links.type) {
            if (symbolInstantiationDepth === 100) {
                error(symbol.valueDeclaration, ts.Diagnostics.Generic_type_instantiation_is_excessively_deep_and_possibly_infinite);
                links.type = unknownType;
            }
            else {
                if (!pushTypeResolution(symbol, 0 /* Type */)) {
                    return unknownType;
                }
                symbolInstantiationDepth++;
                let type = instantiateType(getTypeOfSymbol(links.target), links.mapper);
                symbolInstantiationDepth--;
                if (!popTypeResolution()) {
                    type = reportCircularityError(symbol);
                }
                links.type = type;
            }
        }
        return links.type;
    }
    function reportCircularityError(symbol) {
        // Check if variable has type annotation that circularly references the variable itself
        if (ts.getEffectiveTypeAnnotationNode(symbol.valueDeclaration)) {
            error(symbol.valueDeclaration, ts.Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
            return unknownType;
        }
        // Otherwise variable has initializer that circularly references the variable itself
        if (noImplicitAny) {
            error(symbol.valueDeclaration, ts.Diagnostics._0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer, symbolToString(symbol));
        }
        return anyType;
    }
    function getTypeOfSymbol(symbol) {
        if (ts.getCheckFlags(symbol) & CheckFlags.Instantiated) {
            return getTypeOfInstantiatedSymbol(symbol);
        }
        if (symbol.flags & (3 /* Variable */ | SymbolFlags.Property)) {
            return getTypeOfVariableOrParameterOrProperty(symbol);
        }
        if (symbol.flags & (16 /* Function */ | 8192 /* Method */ | 32 /* Class */ | 384 /* Enum */ | 512 /* ValueModule */)) {
            return getTypeOfFuncClassEnumModule(symbol);
        }
        if (symbol.flags & 8 /* EnumMember */) {
            return getTypeOfEnumMember(symbol);
        }
        if (symbol.flags & 98304 /* Accessor */) {
            return getTypeOfAccessors(symbol);
        }
        if (symbol.flags & SymbolFlags.Alias) {
            return getTypeOfAlias(symbol);
        }
        return unknownType;
    }
    function isReferenceToType(type, target) {
        return type !== undefined
            && target !== undefined
            && (getObjectFlags(type) & 4 /* Reference */) !== 0
            && type.target === target;
    }
    function getTargetType(type) {
        return getObjectFlags(type) & 4 /* Reference */ ? type.target : type;
    }
    function hasBaseType(type, checkBase) {
        return check(type);
        function check(type) {
            if (getObjectFlags(type) & (3 /* ClassOrInterface */ | 4 /* Reference */)) {
                let target = getTargetType(type);
                return target === checkBase || ts.forEach(getBaseTypes(target), check);
            }
            else if (type.flags & 131072 /* Intersection */) {
                return ts.forEach(type.types, check);
            }
        }
    }
    // Appends the type parameters given by a list of declarations to a set of type parameters and returns the resulting set.
    // The function allocates a new array if the input type parameter set is undefined, but otherwise it modifies the set
    // in-place and returns the same array.
    function appendTypeParameters(typeParameters, declarations) {
        for (let _i = 0, declarations_2 = declarations; _i < declarations_2.length; _i++) {
            let declaration = declarations_2[_i];
            let tp = getDeclaredTypeOfTypeParameter(getSymbolOfNode(declaration));
            typeParameters = ts.appendIfUnique(typeParameters, tp);
        }
        return typeParameters;
    }
    // Return the outer type parameters of a node or undefined if the node has no outer type parameters.
    function getOuterTypeParameters(node, includeThisTypes) {
        while (true) {
            node = node.parent;
            if (!node) {
                return undefined;
            }
            switch (node.kind) {
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.ClassExpression:
                case SyntaxKind.InterfaceDeclaration:
                case 155 /* CallSignature */:
                case 156 /* ConstructSignature */:
                case 150 /* MethodSignature */:
                case 160 /* FunctionType */:
                case 161 /* ConstructorType */:
                case 276 /* JSDocFunctionType */:
                case 228 /* FunctionDeclaration */:
                case SyntaxKind.MethodDeclaration:
                case 186 /* FunctionExpression */:
                case 187 /* ArrowFunction */:
                case 231 /* TypeAliasDeclaration */:
                case 285 /* JSDocTemplateTag */:
                case 172 /* MappedType */:
                    let outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);
                    if (node.kind === 172 /* MappedType */) {
                        return ts.append(outerTypeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfNode(node.typeParameter)));
                    }
                    let outerAndOwnTypeParameters = appendTypeParameters(outerTypeParameters, ts.getEffectiveTypeParameterDeclarations(node) || ts.emptyArray);
                    let thisType = includeThisTypes &&
                        (node.kind === SyntaxKind.ClassDeclaration || node.kind === SyntaxKind.ClassExpression || node.kind === SyntaxKind.InterfaceDeclaration) &&
                        getDeclaredTypeOfClassOrInterface(getSymbolOfNode(node)).thisType;
                    return thisType ? ts.append(outerAndOwnTypeParameters, thisType) : outerAndOwnTypeParameters;
            }
        }
    }
    // The outer type parameters are those defined by enclosing generic classes, methods, or functions.
    function getOuterTypeParametersOfClassOrInterface(symbol) {
        let declaration = symbol.flags & 32 /* Class */ ? symbol.valueDeclaration : ts.getDeclarationOfKind(symbol, SyntaxKind.InterfaceDeclaration);
        return getOuterTypeParameters(declaration);
    }
    // The local type parameters are the combined set of type parameters from all declarations of the class,
    // interface, or type alias.
    function getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol) {
        let result;
        for (let _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
            let node = _a[_i];
            if (node.kind === SyntaxKind.InterfaceDeclaration || node.kind === SyntaxKind.ClassDeclaration ||
                node.kind === SyntaxKind.ClassExpression || node.kind === 231 /* TypeAliasDeclaration */) {
                let declaration = node;
                if (declaration.typeParameters) {
                    result = appendTypeParameters(result, declaration.typeParameters);
                }
            }
        }
        return result;
    }
    // The full set of type parameters for a generic class or interface type consists of its outer type parameters plus
    // its locally declared type parameters.
    function getTypeParametersOfClassOrInterface(symbol) {
        return ts.concatenate(getOuterTypeParametersOfClassOrInterface(symbol), getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol));
    }
    // A type is a mixin constructor if it has a single construct signature taking no type parameters and a single
    // rest parameter of type any[].
    function isMixinConstructorType(type) {
        let signatures = getSignaturesOfType(type, 1 /* Construct */);
        if (signatures.length === 1) {
            let s = signatures[0];
            return !s.typeParameters && s.parameters.length === 1 && s.hasRestParameter && getTypeOfParameter(s.parameters[0]) === anyArrayType;
        }
        return false;
    }
    function isConstructorType(type) {
        if (isValidBaseType(type) && getSignaturesOfType(type, 1 /* Construct */).length > 0) {
            return true;
        }
        if (type.flags & 540672 /* TypeVariable */) {
            let constraint = getBaseConstraintOfType(type);
            return constraint && isValidBaseType(constraint) && isMixinConstructorType(constraint);
        }
        return false;
    }
    function getBaseTypeNodeOfClass(type) {
        let decl = type.symbol.valueDeclaration;
        if (ts.isInJavaScriptFile(decl)) {
            // Prefer an @augments tag because it may have type parameters.
            let tag = ts.getJSDocAugmentsTag(decl);
            if (tag) {
                return tag.class;
            }
        }
        return ts.getClassExtendsHeritageClauseElement(decl);
    }
    function getConstructorsForTypeArguments(type, typeArgumentNodes, location) {
        let typeArgCount = ts.length(typeArgumentNodes);
        let isJavaScript = ts.isInJavaScriptFile(location);
        return ts.filter(getSignaturesOfType(type, 1 /* Construct */), function (sig) { return (isJavaScript || typeArgCount >= getMinTypeArgumentCount(sig.typeParameters)) && typeArgCount <= ts.length(sig.typeParameters); });
    }
    function getInstantiatedConstructorsForTypeArguments(type, typeArgumentNodes, location) {
        let signatures = getConstructorsForTypeArguments(type, typeArgumentNodes, location);
        let typeArguments = ts.map(typeArgumentNodes, getTypeFromTypeNode);
        return ts.sameMap(signatures, function (sig) { return ts.some(sig.typeParameters) ? getSignatureInstantiation(sig, typeArguments, ts.isInJavaScriptFile(location)) : sig; });
    }
    /**
     * The base constructor of a class can resolve to
     * * undefinedType if the class has no extends clause,
     * * unknownType if an error occurred during resolution of the extends expression,
     * * nullType if the extends expression is the null value,
     * * anyType if the extends expression has type any, or
     * * an object type with at least one construct signature.
     */
    function getBaseConstructorTypeOfClass(type) {
        if (!type.resolvedBaseConstructorType) {
            let decl = type.symbol.valueDeclaration;
            let extended = ts.getClassExtendsHeritageClauseElement(decl);
            let baseTypeNode = getBaseTypeNodeOfClass(type);
            if (!baseTypeNode) {
                return type.resolvedBaseConstructorType = undefinedType;
            }
            if (!pushTypeResolution(type, 1 /* ResolvedBaseConstructorType */)) {
                return unknownType;
            }
            let baseConstructorType = checkExpression(baseTypeNode.expression);
            if (extended && baseTypeNode !== extended) {
                ts.Debug.assert(!extended.typeArguments); // Because this is in a JS file, and baseTypeNode is in an @extends tag
                checkExpression(extended.expression);
            }
            if (baseConstructorType.flags & (TypeFlags.Object | 131072 /* Intersection */)) {
                // Resolving the members of a class requires us to resolve the base class of that class.
                // We force resolution here such that we catch circularities now.
                resolveStructuredTypeMembers(baseConstructorType);
            }
            if (!popTypeResolution()) {
                error(type.symbol.valueDeclaration, ts.Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression, symbolToString(type.symbol));
                return type.resolvedBaseConstructorType = unknownType;
            }
            if (!(baseConstructorType.flags & 1 /* Any */) && baseConstructorType !== nullWideningType && !isConstructorType(baseConstructorType)) {
                error(baseTypeNode.expression, ts.Diagnostics.Type_0_is_not_a_constructor_function_type, typeToString(baseConstructorType));
                return type.resolvedBaseConstructorType = unknownType;
            }
            type.resolvedBaseConstructorType = baseConstructorType;
        }
        return type.resolvedBaseConstructorType;
    }
    function getBaseTypes(type) {
        if (!type.resolvedBaseTypes) {
            if (type.objectFlags & 8 /* Tuple */) {
                type.resolvedBaseTypes = [createArrayType(getUnionType(type.typeParameters))];
            }
            else if (type.symbol.flags & (32 /* Class */ | 64 /* Interface */)) {
                if (type.symbol.flags & 32 /* Class */) {
                    resolveBaseTypesOfClass(type);
                }
                if (type.symbol.flags & 64 /* Interface */) {
                    resolveBaseTypesOfInterface(type);
                }
            }
            else {
                ts.Debug.fail("type must be class or interface");
            }
        }
        return type.resolvedBaseTypes;
    }
    function resolveBaseTypesOfClass(type) {
        type.resolvedBaseTypes = ts.emptyArray;
        let baseConstructorType = getApparentType(getBaseConstructorTypeOfClass(type));
        if (!(baseConstructorType.flags & (TypeFlags.Object | 131072 /* Intersection */ | 1 /* Any */))) {
            return;
        }
        let baseTypeNode = getBaseTypeNodeOfClass(type);
        let typeArgs = typeArgumentsFromTypeReferenceNode(baseTypeNode);
        let baseType;
        let originalBaseType = baseConstructorType && baseConstructorType.symbol ? getDeclaredTypeOfSymbol(baseConstructorType.symbol) : undefined;
        if (baseConstructorType.symbol && baseConstructorType.symbol.flags & 32 /* Class */ &&
            areAllOuterTypeParametersApplied(originalBaseType)) {
            // When base constructor type is a class with no captured type arguments we know that the constructors all have the same type parameters as the
            // class and all return the instance type of the class. There is no need for further checks and we can apply the
            // type arguments in the same manner as a type reference to get the same error reporting experience.
            baseType = getTypeFromClassOrInterfaceReference(baseTypeNode, baseConstructorType.symbol, typeArgs);
        }
        else if (baseConstructorType.flags & 1 /* Any */) {
            baseType = baseConstructorType;
        }
        else {
            // The class derives from a "class-like" constructor function, check that we have at least one construct signature
            // with a matching number of type parameters and use the return type of the first instantiated signature. Elsewhere
            // we check that all instantiated signatures return the same type.
            let constructors = getInstantiatedConstructorsForTypeArguments(baseConstructorType, baseTypeNode.typeArguments, baseTypeNode);
            if (!constructors.length) {
                error(baseTypeNode.expression, ts.Diagnostics.No_base_constructor_has_the_specified_number_of_type_arguments);
                return;
            }
            baseType = getReturnTypeOfSignature(constructors[0]);
        }
        if (baseType === unknownType) {
            return;
        }
        if (!isValidBaseType(baseType)) {
            error(baseTypeNode.expression, ts.Diagnostics.Base_constructor_return_type_0_is_not_a_class_or_interface_type, typeToString(baseType));
            return;
        }
        if (type === baseType || hasBaseType(baseType, type)) {
            error(type.symbol.valueDeclaration, ts.Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, /*enclosingDeclaration*/ undefined, 1 /* WriteArrayAsGenericType */));
            return;
        }
        type.resolvedBaseTypes = [baseType];
    }
    function areAllOuterTypeParametersApplied(type) {
        // An unapplied type parameter has its symbol still the same as the matching argument symbol.
        // Since parameters are applied outer-to-inner, only the last outer parameter needs to be checked.
        let outerTypeParameters = type.outerTypeParameters;
        if (outerTypeParameters) {
            let last_1 = outerTypeParameters.length - 1;
            let typeArguments = type.typeArguments;
            return outerTypeParameters[last_1].symbol !== typeArguments[last_1].symbol;
        }
        return true;
    }
    // A valid base type is `any`, any non-generic object type or intersection of non-generic
    // object types.
    function isValidBaseType(type) {
        return type.flags & (TypeFlags.Object | 16777216 /* NonPrimitive */ | 1 /* Any */) && !isGenericMappedType(type) ||
            type.flags & 131072 /* Intersection */ && !ts.forEach(type.types, function (t) { return !isValidBaseType(t); });
    }
    function resolveBaseTypesOfInterface(type) {
        type.resolvedBaseTypes = type.resolvedBaseTypes || ts.emptyArray;
        for (let _i = 0, _a = type.symbol.declarations; _i < _a.length; _i++) {
            let declaration = _a[_i];
            if (declaration.kind === SyntaxKind.InterfaceDeclaration && ts.getInterfaceBaseTypeNodes(declaration)) {
                for (let _b = 0, _c = ts.getInterfaceBaseTypeNodes(declaration); _b < _c.length; _b++) {
                    let node = _c[_b];
                    let baseType = getTypeFromTypeNode(node);
                    if (baseType !== unknownType) {
                        if (isValidBaseType(baseType)) {
                            if (type !== baseType && !hasBaseType(baseType, type)) {
                                if (type.resolvedBaseTypes === ts.emptyArray) {
                                    type.resolvedBaseTypes = [baseType];
                                }
                                else {
                                    type.resolvedBaseTypes.push(baseType);
                                }
                            }
                            else {
                                error(declaration, ts.Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, /*enclosingDeclaration*/ undefined, 1 /* WriteArrayAsGenericType */));
                            }
                        }
                        else {
                            error(node, ts.Diagnostics.An_interface_may_only_extend_a_class_or_another_interface);
                        }
                    }
                }
            }
        }
    }
    // Returns true if the interface given by the symbol is free of "this" references. Specifically, the result is
    // true if the interface itself contains no references to "this" in its body, if all base types are interfaces,
    // and if none of the base interfaces have a "this" type.
    function isIndependentInterface(symbol) {
        for (let _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
            let declaration = _a[_i];
            if (declaration.kind === SyntaxKind.InterfaceDeclaration) {
                if (declaration.flags & 64 /* ContainsThis */) {
                    return false;
                }
                let baseTypeNodes = ts.getInterfaceBaseTypeNodes(declaration);
                if (baseTypeNodes) {
                    for (let _b = 0, baseTypeNodes_1 = baseTypeNodes; _b < baseTypeNodes_1.length; _b++) {
                        let node = baseTypeNodes_1[_b];
                        if (ts.isEntityNameExpression(node.expression)) {
                            let baseSymbol = resolveEntityName(node.expression, SymbolFlags.Type, /*ignoreErrors*/ true);
                            if (!baseSymbol || !(baseSymbol.flags & 64 /* Interface */) || getDeclaredTypeOfClassOrInterface(baseSymbol).thisType) {
                                return false;
                            }
                        }
                    }
                }
            }
        }
        return true;
    }
    function getDeclaredTypeOfClassOrInterface(symbol) {
        let links = getSymbolLinks(symbol);
        if (!links.declaredType) {
            let kind = symbol.flags & 32 /* Class */ ? 1 /* Class */ : 2 /* Interface */;
            let type = links.declaredType = createObjectType(kind, symbol);
            let outerTypeParameters = getOuterTypeParametersOfClassOrInterface(symbol);
            let localTypeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
            // A class or interface is generic if it has type parameters or a "this" type. We always give classes a "this" type
            // because it is not feasible to analyze all members to determine if the "this" type escapes the class (in particular,
            // property types inferred from initializers and method return types inferred from return statements are very hard
            // to exhaustively analyze). We give interfaces a "this" type if we can't definitely determine that they are free of
            // "this" references.
            if (outerTypeParameters || localTypeParameters || kind === 1 /* Class */ || !isIndependentInterface(symbol)) {
                type.objectFlags |= 4 /* Reference */;
                type.typeParameters = ts.concatenate(outerTypeParameters, localTypeParameters);
                type.outerTypeParameters = outerTypeParameters;
                type.localTypeParameters = localTypeParameters;
                type.instantiations = ts.createMap();
                type.instantiations.set(getTypeListId(type.typeParameters), type);
                type.target = type;
                type.typeArguments = type.typeParameters;
                type.thisType = createType(16384 /* TypeParameter */);
                type.thisType.isThisType = true;
                type.thisType.symbol = symbol;
                type.thisType.constraint = type;
            }
        }
        return links.declaredType;
    }
    function getDeclaredTypeOfTypeAlias(symbol) {
        let links = getSymbolLinks(symbol);
        if (!links.declaredType) {
            // Note that we use the links object as the target here because the symbol object is used as the unique
            // identity for resolution of the 'type' property in SymbolLinks.
            if (!pushTypeResolution(symbol, 2 /* DeclaredType */)) {
                return unknownType;
            }
            let declaration = ts.find(symbol.declarations, function (d) {
                return d.kind === 286 /* JSDocTypedefTag */ || d.kind === 231 /* TypeAliasDeclaration */;
            });
            let typeNode = declaration.kind === 286 /* JSDocTypedefTag */ ? declaration.typeExpression : declaration.type;
            // If typeNode is missing, we will error in checkJSDocTypedefTag.
            let type = typeNode ? getTypeFromTypeNode(typeNode) : unknownType;
            if (popTypeResolution()) {
                let typeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                if (typeParameters) {
                    // Initialize the instantiation cache for generic type aliases. The declared type corresponds to
                    // an instantiation of the type alias with the type parameters supplied as type arguments.
                    links.typeParameters = typeParameters;
                    links.instantiations = ts.createMap();
                    links.instantiations.set(getTypeListId(typeParameters), type);
                }
            }
            else {
                type = unknownType;
                error(declaration.name, ts.Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol));
            }
            links.declaredType = type;
        }
        return links.declaredType;
    }
    function isLiteralEnumMember(member) {
        let expr = member.initializer;
        if (!expr) {
            return !ts.isInAmbientContext(member);
        }
        switch (expr.kind) {
            case 9 /* StringLiteral */:
            case 8 /* NumericLiteral */:
                return true;
            case 192 /* PrefixUnaryExpression */:
                return expr.operator === 38 /* MinusToken */ &&
                    expr.operand.kind === 8 /* NumericLiteral */;
            case 71 /* Identifier */:
                return ts.nodeIsMissing(expr) || !!getSymbolOfNode(member.parent).exports.get(expr.escapedText);
            default:
                return false;
        }
    }
    function getEnumKind(symbol) {
        let links = getSymbolLinks(symbol);
        if (links.enumKind !== undefined) {
            return links.enumKind;
        }
        let hasNonLiteralMember = false;
        for (let _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
            let declaration = _a[_i];
            if (declaration.kind === SyntaxKind.EnumDeclaration) {
                for (let _b = 0, _c = declaration.members; _b < _c.length; _b++) {
                    let member = _c[_b];
                    if (member.initializer && member.initializer.kind === 9 /* StringLiteral */) {
                        return links.enumKind = 1 /* Literal */;
                    }
                    if (!isLiteralEnumMember(member)) {
                        hasNonLiteralMember = true;
                    }
                }
            }
        }
        return links.enumKind = hasNonLiteralMember ? 0 /* Numeric */ : 1 /* Literal */;
    }
    function getBaseTypeOfEnumLiteralType(type) {
        return type.flags & 256 /* EnumLiteral */ && !(type.flags & 65536 /* Union */) ? getDeclaredTypeOfSymbol(getParentOfSymbol(type.symbol)) : type;
    }
    function getDeclaredTypeOfEnum(symbol) {
        let links = getSymbolLinks(symbol);
        if (links.declaredType) {
            return links.declaredType;
        }
        if (getEnumKind(symbol) === 1 /* Literal */) {
            enumCount++;
            let memberTypeList = [];
            for (let _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                let declaration = _a[_i];
                if (declaration.kind === SyntaxKind.EnumDeclaration) {
                    for (let _b = 0, _c = declaration.members; _b < _c.length; _b++) {
                        let member = _c[_b];
                        let memberType = getLiteralType(getEnumMemberValue(member), enumCount, getSymbolOfNode(member));
                        getSymbolLinks(getSymbolOfNode(member)).declaredType = memberType;
                        memberTypeList.push(memberType);
                    }
                }
            }
            if (memberTypeList.length) {
                let enumType_1 = getUnionType(memberTypeList, /*subtypeReduction*/ false, symbol, /*aliasTypeArguments*/ undefined);
                if (enumType_1.flags & 65536 /* Union */) {
                    enumType_1.flags |= 256 /* EnumLiteral */;
                    enumType_1.symbol = symbol;
                }
                return links.declaredType = enumType_1;
            }
        }
        let enumType = createType(16 /* Enum */);
        enumType.symbol = symbol;
        return links.declaredType = enumType;
    }
    function getDeclaredTypeOfEnumMember(symbol) {
        let links = getSymbolLinks(symbol);
        if (!links.declaredType) {
            let enumType = getDeclaredTypeOfEnum(getParentOfSymbol(symbol));
            if (!links.declaredType) {
                links.declaredType = enumType;
            }
        }
        return links.declaredType;
    }
    function getDeclaredTypeOfTypeParameter(symbol) {
        let links = getSymbolLinks(symbol);
        if (!links.declaredType) {
            let type = createType(16384 /* TypeParameter */);
            type.symbol = symbol;
            links.declaredType = type;
        }
        return links.declaredType;
    }
    function getDeclaredTypeOfAlias(symbol) {
        let links = getSymbolLinks(symbol);
        if (!links.declaredType) {
            links.declaredType = getDeclaredTypeOfSymbol(resolveAlias(symbol));
        }
        return links.declaredType;
    }
    function getDeclaredTypeOfSymbol(symbol) {
        return tryGetDeclaredTypeOfSymbol(symbol) || unknownType;
    }
    function tryGetDeclaredTypeOfSymbol(symbol) {
        if (symbol.flags & (32 /* Class */ | 64 /* Interface */)) {
            return getDeclaredTypeOfClassOrInterface(symbol);
        }
        if (symbol.flags & 524288 /* TypeAlias */) {
            return getDeclaredTypeOfTypeAlias(symbol);
        }
        if (symbol.flags & SymbolFlags.TypeParameter) {
            return getDeclaredTypeOfTypeParameter(symbol);
        }
        if (symbol.flags & 384 /* Enum */) {
            return getDeclaredTypeOfEnum(symbol);
        }
        if (symbol.flags & 8 /* EnumMember */) {
            return getDeclaredTypeOfEnumMember(symbol);
        }
        if (symbol.flags & SymbolFlags.Alias) {
            return getDeclaredTypeOfAlias(symbol);
        }
        return undefined;
    }
    // A type reference is considered independent if each type argument is considered independent.
    function isIndependentTypeReference(node) {
        if (node.typeArguments) {
            for (let _i = 0, _a = node.typeArguments; _i < _a.length; _i++) {
                let typeNode = _a[_i];
                if (!isIndependentType(typeNode)) {
                    return false;
                }
            }
        }
        return true;
    }
    // A type is considered independent if it the any, string, number, boolean, symbol, or void keyword, a string
    // literal type, an array with an element type that is considered independent, or a type reference that is
    // considered independent.
    function isIndependentType(node) {
        switch (node.kind) {
            case 119 /* AnyKeyword */:
            case 136 /* StringKeyword */:
            case 133 /* NumberKeyword */:
            case 122 /* BooleanKeyword */:
            case 137 /* SymbolKeyword */:
            case 134 /* ObjectKeyword */:
            case 105 /* VoidKeyword */:
            case 139 /* UndefinedKeyword */:
            case 95 /* NullKeyword */:
            case 130 /* NeverKeyword */:
            case 173 /* LiteralType */:
                return true;
            case 164 /* ArrayType */:
                return isIndependentType(node.elementType);
            case 159 /* TypeReference */:
                return isIndependentTypeReference(node);
        }
        return false;
    }
    // A variable-like declaration is considered independent (free of this references) if it has a type annotation
    // that specifies an independent type, or if it has no type annotation and no initializer (and thus of type any).
    function isIndependentVariableLikeDeclaration(node) {
        let typeNode = ts.getEffectiveTypeAnnotationNode(node);
        return typeNode ? isIndependentType(typeNode) : !node.initializer;
    }
    // A function-like declaration is considered independent (free of this references) if it has a return type
    // annotation that is considered independent and if each parameter is considered independent.
    function isIndependentFunctionLikeDeclaration(node) {
        if (node.kind !== 152 /* Constructor */) {
            let typeNode = ts.getEffectiveReturnTypeNode(node);
            if (!typeNode || !isIndependentType(typeNode)) {
                return false;
            }
        }
        for (let _i = 0, _a = node.parameters; _i < _a.length; _i++) {
            let parameter = _a[_i];
            if (!isIndependentVariableLikeDeclaration(parameter)) {
                return false;
            }
        }
        return true;
    }
    // Returns true if the class or interface member given by the symbol is free of "this" references. The
    // function may return false for symbols that are actually free of "this" references because it is not
    // feasible to perform a complete analysis in all cases. In particular, property members with types
    // inferred from their initializers and function members with inferred return types are conservatively
    // assumed not to be free of "this" references.
    function isIndependentMember(symbol) {
        if (symbol.declarations && symbol.declarations.length === 1) {
            let declaration = symbol.declarations[0];
            if (declaration) {
                switch (declaration.kind) {
                    case SyntaxKind.PropertyDeclaration:
                    case SyntaxKind.PropertySignature:
                        return isIndependentVariableLikeDeclaration(declaration);
                    case SyntaxKind.MethodDeclaration:
                    case 150 /* MethodSignature */:
                    case 152 /* Constructor */:
                        return isIndependentFunctionLikeDeclaration(declaration);
                }
            }
        }
        return false;
    }
    // The mappingThisOnly flag indicates that the only type parameter being mapped is "this". When the flag is true,
    // we check symbols to see if we can quickly conclude they are free of "this" references, thus needing no instantiation.
    function createInstantiatedSymbolTable(symbols, mapper, mappingThisOnly) {
        let result = ts.createSymbolTable();
        for (let _i = 0, symbols_2 = symbols; _i < symbols_2.length; _i++) {
            let symbol = symbols_2[_i];
            result.set(symbol.escapedName, mappingThisOnly && isIndependentMember(symbol) ? symbol : instantiateSymbol(symbol, mapper));
        }
        return result;
    }
    function addInheritedMembers(symbols, baseSymbols) {
        for (let _i = 0, baseSymbols_1 = baseSymbols; _i < baseSymbols_1.length; _i++) {
            let s = baseSymbols_1[_i];
            if (!symbols.has(s.escapedName)) {
                symbols.set(s.escapedName, s);
            }
        }
    }
    function resolveDeclaredMembers(type) {
        if (!type.declaredProperties) {
            let symbol = type.symbol;
            type.declaredProperties = getNamedMembers(symbol.members);
            type.declaredCallSignatures = getSignaturesOfSymbol(symbol.members.get("__call" /* Call */));
            type.declaredConstructSignatures = getSignaturesOfSymbol(symbol.members.get("__new" /* New */));
            type.declaredStringIndexInfo = getIndexInfoOfSymbol(symbol, 0 /* String */);
            type.declaredNumberIndexInfo = getIndexInfoOfSymbol(symbol, 1 /* Number */);
        }
        return type;
    }
    function getTypeWithThisArgument(type, thisArgument) {
        if (getObjectFlags(type) & 4 /* Reference */) {
            let target = type.target;
            let typeArguments = type.typeArguments;
            if (ts.length(target.typeParameters) === ts.length(typeArguments)) {
                return createTypeReference(target, ts.concatenate(typeArguments, [thisArgument || target.thisType]));
            }
        }
        else if (type.flags & 131072 /* Intersection */) {
            return getIntersectionType(ts.map(type.types, function (t) { return getTypeWithThisArgument(t, thisArgument); }));
        }
        return type;
    }
    function resolveObjectTypeMembers(type, source, typeParameters, typeArguments) {
        let mapper;
        let members;
        let callSignatures;
        let constructSignatures;
        let stringIndexInfo;
        let numberIndexInfo;
        if (ts.rangeEquals(typeParameters, typeArguments, 0, typeParameters.length)) {
            mapper = identityMapper;
            members = source.symbol ? source.symbol.members : ts.createSymbolTable(source.declaredProperties);
            callSignatures = source.declaredCallSignatures;
            constructSignatures = source.declaredConstructSignatures;
            stringIndexInfo = source.declaredStringIndexInfo;
            numberIndexInfo = source.declaredNumberIndexInfo;
        }
        else {
            mapper = createTypeMapper(typeParameters, typeArguments);
            members = createInstantiatedSymbolTable(source.declaredProperties, mapper, /*mappingThisOnly*/ typeParameters.length === 1);
            callSignatures = instantiateSignatures(source.declaredCallSignatures, mapper);
            constructSignatures = instantiateSignatures(source.declaredConstructSignatures, mapper);
            stringIndexInfo = instantiateIndexInfo(source.declaredStringIndexInfo, mapper);
            numberIndexInfo = instantiateIndexInfo(source.declaredNumberIndexInfo, mapper);
        }
        let baseTypes = getBaseTypes(source);
        if (baseTypes.length) {
            if (source.symbol && members === source.symbol.members) {
                members = ts.createSymbolTable(source.declaredProperties);
            }
            let thisArgument = ts.lastOrUndefined(typeArguments);
            for (let _i = 0, baseTypes_1 = baseTypes; _i < baseTypes_1.length; _i++) {
                let baseType = baseTypes_1[_i];
                let instantiatedBaseType = thisArgument ? getTypeWithThisArgument(instantiateType(baseType, mapper), thisArgument) : baseType;
                addInheritedMembers(members, getPropertiesOfType(instantiatedBaseType));
                callSignatures = ts.concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, 0 /* Call */));
                constructSignatures = ts.concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, 1 /* Construct */));
                if (!stringIndexInfo) {
                    stringIndexInfo = instantiatedBaseType === anyType ?
                        createIndexInfo(anyType, /*isReadonly*/ false) :
                        getIndexInfoOfType(instantiatedBaseType, 0 /* String */);
                }
                numberIndexInfo = numberIndexInfo || getIndexInfoOfType(instantiatedBaseType, 1 /* Number */);
            }
        }
        setStructuredTypeMembers(type, members, callSignatures, constructSignatures, stringIndexInfo, numberIndexInfo);
    }
    function resolveClassOrInterfaceMembers(type) {
        resolveObjectTypeMembers(type, resolveDeclaredMembers(type), ts.emptyArray, ts.emptyArray);
    }
    function resolveTypeReferenceMembers(type) {
        let source = resolveDeclaredMembers(type.target);
        let typeParameters = ts.concatenate(source.typeParameters, [source.thisType]);
        let typeArguments = type.typeArguments && type.typeArguments.length === typeParameters.length ?
            type.typeArguments : ts.concatenate(type.typeArguments, [type]);
        resolveObjectTypeMembers(type, source, typeParameters, typeArguments);
    }
    function createSignature(declaration, typeParameters, thisParameter, parameters, resolvedReturnType, typePredicate, minArgumentCount, hasRestParameter, hasLiteralTypes) {
        let sig = new Signature(checker);
        sig.declaration = declaration;
        sig.typeParameters = typeParameters;
        sig.parameters = parameters;
        sig.thisParameter = thisParameter;
        sig.resolvedReturnType = resolvedReturnType;
        sig.typePredicate = typePredicate;
        sig.minArgumentCount = minArgumentCount;
        sig.hasRestParameter = hasRestParameter;
        sig.hasLiteralTypes = hasLiteralTypes;
        return sig;
    }
    function cloneSignature(sig) {
        return createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, sig.resolvedReturnType, sig.typePredicate, sig.minArgumentCount, sig.hasRestParameter, sig.hasLiteralTypes);
    }
    function getDefaultConstructSignatures(classType) {
        let baseConstructorType = getBaseConstructorTypeOfClass(classType);
        let baseSignatures = getSignaturesOfType(baseConstructorType, 1 /* Construct */);
        if (baseSignatures.length === 0) {
            return [createSignature(undefined, classType.localTypeParameters, undefined, ts.emptyArray, classType, /*typePredicate*/ undefined, 0, /*hasRestParameter*/ false, /*hasLiteralTypes*/ false)];
        }
        let baseTypeNode = getBaseTypeNodeOfClass(classType);
        let isJavaScript = ts.isInJavaScriptFile(baseTypeNode);
        let typeArguments = typeArgumentsFromTypeReferenceNode(baseTypeNode);
        let typeArgCount = ts.length(typeArguments);
        let result = [];
        for (let _i = 0, baseSignatures_1 = baseSignatures; _i < baseSignatures_1.length; _i++) {
            let baseSig = baseSignatures_1[_i];
            let minTypeArgumentCount = getMinTypeArgumentCount(baseSig.typeParameters);
            let typeParamCount = ts.length(baseSig.typeParameters);
            if ((isJavaScript || typeArgCount >= minTypeArgumentCount) && typeArgCount <= typeParamCount) {
                let sig = typeParamCount ? createSignatureInstantiation(baseSig, fillMissingTypeArguments(typeArguments, baseSig.typeParameters, minTypeArgumentCount, isJavaScript)) : cloneSignature(baseSig);
                sig.typeParameters = classType.localTypeParameters;
                sig.resolvedReturnType = classType;
                result.push(sig);
            }
        }
        return result;
    }
    function findMatchingSignature(signatureList, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes) {
        for (let _i = 0, signatureList_1 = signatureList; _i < signatureList_1.length; _i++) {
            let s = signatureList_1[_i];
            if (compareSignaturesIdentical(s, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes, compareTypesIdentical)) {
                return s;
            }
        }
    }
    function findMatchingSignatures(signatureLists, signature, listIndex) {
        if (signature.typeParameters) {
            // We require an exact match for generic signatures, so we only return signatures from the first
            // signature list and only if they have exact matches in the other signature lists.
            if (listIndex > 0) {
                return undefined;
            }
            for (let i = 1; i < signatureLists.length; i++) {
                if (!findMatchingSignature(signatureLists[i], signature, /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ false)) {
                    return undefined;
                }
            }
            return [signature];
        }
        let result = undefined;
        for (let i = 0; i < signatureLists.length; i++) {
            // Allow matching non-generic signatures to have excess parameters and different return types
            let match = i === listIndex ? signature : findMatchingSignature(signatureLists[i], signature, /*partialMatch*/ true, /*ignoreThisTypes*/ true, /*ignoreReturnTypes*/ true);
            if (!match) {
                return undefined;
            }
            result = ts.appendIfUnique(result, match);
        }
        return result;
    }
    // The signatures of a union type are those signatures that are present in each of the constituent types.
    // Generic signatures must match exactly, but non-generic signatures are allowed to have extra optional
    // parameters and may differ in return types. When signatures differ in return types, the resulting return
    // type is the union of the constituent return types.
    function getUnionSignatures(types, kind) {
        let signatureLists = ts.map(types, function (t) { return getSignaturesOfType(t, kind); });
        let result = undefined;
        for (let i = 0; i < signatureLists.length; i++) {
            for (let _i = 0, _a = signatureLists[i]; _i < _a.length; _i++) {
                let signature = _a[_i];
                // Only process signatures with parameter lists that aren't already in the result list
                if (!result || !findMatchingSignature(result, signature, /*partialMatch*/ false, /*ignoreThisTypes*/ true, /*ignoreReturnTypes*/ true)) {
                    let unionSignatures = findMatchingSignatures(signatureLists, signature, i);
                    if (unionSignatures) {
                        let s = signature;
                        // Union the result types when more than one signature matches
                        if (unionSignatures.length > 1) {
                            s = cloneSignature(signature);
                            if (ts.forEach(unionSignatures, function (sig) { return sig.thisParameter; })) {
                                let thisType = getUnionType(ts.map(unionSignatures, function (sig) { return getTypeOfSymbol(sig.thisParameter) || anyType; }), /*subtypeReduction*/ true);
                                s.thisParameter = createSymbolWithType(signature.thisParameter, thisType);
                            }
                            // Clear resolved return type we possibly got from cloneSignature
                            s.resolvedReturnType = undefined;
                            s.unionSignatures = unionSignatures;
                        }
                        (result || (result = [])).push(s);
                    }
                }
            }
        }
        return result || ts.emptyArray;
    }
    function getUnionIndexInfo(types, kind) {
        let indexTypes = [];
        let isAnyReadonly = false;
        for (let _i = 0, types_1 = types; _i < types_1.length; _i++) {
            let type = types_1[_i];
            let indexInfo = getIndexInfoOfType(type, kind);
            if (!indexInfo) {
                return undefined;
            }
            indexTypes.push(indexInfo.type);
            isAnyReadonly = isAnyReadonly || indexInfo.isReadonly;
        }
        return createIndexInfo(getUnionType(indexTypes, /*subtypeReduction*/ true), isAnyReadonly);
    }
    function resolveUnionTypeMembers(type) {
        // The members and properties collections are empty for union types. To get all properties of a union
        // type use getPropertiesOfType (only the language service uses this).
        let callSignatures = getUnionSignatures(type.types, 0 /* Call */);
        let constructSignatures = getUnionSignatures(type.types, 1 /* Construct */);
        let stringIndexInfo = getUnionIndexInfo(type.types, 0 /* String */);
        let numberIndexInfo = getUnionIndexInfo(type.types, 1 /* Number */);
        setStructuredTypeMembers(type, emptySymbols, callSignatures, constructSignatures, stringIndexInfo, numberIndexInfo);
    }
    function intersectTypes(type1, type2) {
        return !type1 ? type2 : !type2 ? type1 : getIntersectionType([type1, type2]);
    }
    function intersectIndexInfos(info1, info2) {
        return !info1 ? info2 : !info2 ? info1 : createIndexInfo(getIntersectionType([info1.type, info2.type]), info1.isReadonly && info2.isReadonly);
    }
    function unionSpreadIndexInfos(info1, info2) {
        return info1 && info2 && createIndexInfo(getUnionType([info1.type, info2.type]), info1.isReadonly || info2.isReadonly);
    }
    function includeMixinType(type, types, index) {
        let mixedTypes = [];
        for (let i = 0; i < types.length; i++) {
            if (i === index) {
                mixedTypes.push(type);
            }
            else if (isMixinConstructorType(types[i])) {
                mixedTypes.push(getReturnTypeOfSignature(getSignaturesOfType(types[i], 1 /* Construct */)[0]));
            }
        }
        return getIntersectionType(mixedTypes);
    }
    function resolveIntersectionTypeMembers(type) {
        // The members and properties collections are empty for intersection types. To get all properties of an
        // intersection type use getPropertiesOfType (only the language service uses this).
        let callSignatures = ts.emptyArray;
        let constructSignatures = ts.emptyArray;
        let stringIndexInfo;
        let numberIndexInfo;
        let types = type.types;
        let mixinCount = ts.countWhere(types, isMixinConstructorType);
        let _loop_3 = function (i) {
            let t = type.types[i];
            // When an intersection type contains mixin constructor types, the construct signatures from
            // those types are discarded and their return types are mixed into the return types of all
            // other construct signatures in the intersection type. For example, the intersection type
            // '{ new(...args: any[]) => A } & { new(s: string) => B }' has a single construct signature
            // 'new(s: string) => A & B'.
            if (mixinCount === 0 || mixinCount === types.length && i === 0 || !isMixinConstructorType(t)) {
                let signatures = getSignaturesOfType(t, 1 /* Construct */);
                if (signatures.length && mixinCount > 0) {
                    signatures = ts.map(signatures, function (s) {
                        let clone = cloneSignature(s);
                        clone.resolvedReturnType = includeMixinType(getReturnTypeOfSignature(s), types, i);
                        return clone;
                    });
                }
                constructSignatures = ts.concatenate(constructSignatures, signatures);
            }
            callSignatures = ts.concatenate(callSignatures, getSignaturesOfType(t, 0 /* Call */));
            stringIndexInfo = intersectIndexInfos(stringIndexInfo, getIndexInfoOfType(t, 0 /* String */));
            numberIndexInfo = intersectIndexInfos(numberIndexInfo, getIndexInfoOfType(t, 1 /* Number */));
        };
        for (let i = 0; i < types.length; i++) {
            _loop_3(i);
        }
        setStructuredTypeMembers(type, emptySymbols, callSignatures, constructSignatures, stringIndexInfo, numberIndexInfo);
    }
    /**
     * Converts an AnonymousType to a ResolvedType.
     */
    function resolveAnonymousTypeMembers(type) {
        let symbol = type.symbol;
        if (type.target) {
            let members = createInstantiatedSymbolTable(getPropertiesOfObjectType(type.target), type.mapper, /*mappingThisOnly*/ false);
            let callSignatures = instantiateSignatures(getSignaturesOfType(type.target, 0 /* Call */), type.mapper);
            let constructSignatures = instantiateSignatures(getSignaturesOfType(type.target, 1 /* Construct */), type.mapper);
            let stringIndexInfo = instantiateIndexInfo(getIndexInfoOfType(type.target, 0 /* String */), type.mapper);
            let numberIndexInfo = instantiateIndexInfo(getIndexInfoOfType(type.target, 1 /* Number */), type.mapper);
            setStructuredTypeMembers(type, members, callSignatures, constructSignatures, stringIndexInfo, numberIndexInfo);
        }
        else if (symbol.flags & 2048 /* TypeLiteral */) {
            let members = symbol.members;
            let callSignatures = getSignaturesOfSymbol(members.get("__call" /* Call */));
            let constructSignatures = getSignaturesOfSymbol(members.get("__new" /* New */));
            let stringIndexInfo = getIndexInfoOfSymbol(symbol, 0 /* String */);
            let numberIndexInfo = getIndexInfoOfSymbol(symbol, 1 /* Number */);
            setStructuredTypeMembers(type, members, callSignatures, constructSignatures, stringIndexInfo, numberIndexInfo);
        }
        else {
            // Combinations of function, class, enum and module
            let members = emptySymbols;
            let stringIndexInfo = undefined;
            if (symbol.exports) {
                members = getExportsOfSymbol(symbol);
            }
            if (symbol.flags & 32 /* Class */) {
                let classType = getDeclaredTypeOfClassOrInterface(symbol);
                let baseConstructorType = getBaseConstructorTypeOfClass(classType);
                if (baseConstructorType.flags & (TypeFlags.Object | 131072 /* Intersection */ | 540672 /* TypeVariable */)) {
                    members = ts.createSymbolTable(getNamedMembers(members));
                    addInheritedMembers(members, getPropertiesOfType(baseConstructorType));
                }
                else if (baseConstructorType === anyType) {
                    stringIndexInfo = createIndexInfo(anyType, /*isReadonly*/ false);
                }
            }
            let numberIndexInfo = symbol.flags & 384 /* Enum */ ? enumNumberIndexInfo : undefined;
            setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, stringIndexInfo, numberIndexInfo);
            // We resolve the members before computing the signatures because a signature may use
            // typeof with a qualified name expression that circularly references the type we are
            // in the process of resolving (see issue #6072). The temporarily empty signature list
            // will never be observed because a qualified name can't reference signatures.
            if (symbol.flags & (16 /* Function */ | 8192 /* Method */)) {
                type.callSignatures = getSignaturesOfSymbol(symbol);
            }
            // And likewise for construct signatures for classes
            if (symbol.flags & 32 /* Class */) {
                let classType = getDeclaredTypeOfClassOrInterface(symbol);
                let constructSignatures = getSignaturesOfSymbol(symbol.members.get("__constructor" /* Constructor */));
                if (!constructSignatures.length) {
                    constructSignatures = getDefaultConstructSignatures(classType);
                }
                type.constructSignatures = constructSignatures;
            }
        }
    }
    /** Resolve the members of a mapped type { [P in K]: T } */
    function resolveMappedTypeMembers(type) {
        let members = ts.createSymbolTable();
        let stringIndexInfo;
        // Resolve upfront such that recursive references see an empty object type.
        setStructuredTypeMembers(type, emptySymbols, ts.emptyArray, ts.emptyArray, undefined, undefined);
        // In { [P in K]: T }, we refer to P as the type parameter type, K as the constraint type,
        // and T as the template type.
        let typeParameter = getTypeParameterFromMappedType(type);
        let constraintType = getConstraintTypeFromMappedType(type);
        let templateType = getTemplateTypeFromMappedType(type);
        let modifiersType = getApparentType(getModifiersTypeFromMappedType(type)); // The 'T' in 'keyof T'
        let templateReadonly = !!type.declaration.readonlyToken;
        let templateOptional = !!type.declaration.questionToken;
        if (type.declaration.typeParameter.constraint.kind === 170 /* TypeOperator */) {
            // We have a { [P in keyof T]: X }
            for (let _i = 0, _a = getPropertiesOfType(modifiersType); _i < _a.length; _i++) {
                let propertySymbol = _a[_i];
                addMemberForKeyType(getLiteralTypeFromPropertyName(propertySymbol), propertySymbol);
            }
            if (modifiersType.flags & 1 /* Any */ || getIndexInfoOfType(modifiersType, 0 /* String */)) {
                addMemberForKeyType(stringType);
            }
        }
        else {
            // First, if the constraint type is a type parameter, obtain the base constraint. Then,
            // if the key type is a 'keyof X', obtain 'keyof C' where C is the base constraint of X.
            // Finally, iterate over the constituents of the resulting iteration type.
            let keyType = constraintType.flags & 540672 /* TypeVariable */ ? getApparentType(constraintType) : constraintType;
            let iterationType = keyType.flags & 262144 /* Index */ ? getIndexType(getApparentType(keyType.type)) : keyType;
            forEachType(iterationType, addMemberForKeyType);
        }
        setStructuredTypeMembers(type, members, ts.emptyArray, ts.emptyArray, stringIndexInfo, undefined);
        function addMemberForKeyType(t, propertySymbolOrIndex) {
            let propertySymbol;
            // forEachType delegates to forEach, which calls with a numeric second argument
            //  the type system currently doesn't catch this incompatibility, so we annotate
            //  the function ourselves to indicate the runtime behavior and deal with it here
            if (typeof propertySymbolOrIndex === "object") {
                propertySymbol = propertySymbolOrIndex;
            }
            // Create a mapper from T to the current iteration type constituent. Then, if the
            // mapped type is itself an instantiated type, combine the iteration mapper with the
            // instantiation mapper.
            let iterationMapper = createTypeMapper([typeParameter], [t]);
            let templateMapper = type.mapper ? combineTypeMappers(type.mapper, iterationMapper) : iterationMapper;
            let propType = instantiateType(templateType, templateMapper);
            // If the current iteration type constituent is a string literal type, create a property.
            // Otherwise, for type string create a string index signature.
            if (t.flags & 32 /* StringLiteral */) {
                let propName = ts.escapeLeadingUnderscores(t.value);
                let modifiersProp = getPropertyOfType(modifiersType, propName);
                let isOptional = templateOptional || !!(modifiersProp && modifiersProp.flags & 16777216 /* Optional */);
                let prop = createSymbol(SymbolFlags.Property | (isOptional ? 16777216 /* Optional */ : 0), propName);
                prop.checkFlags = templateReadonly || modifiersProp && isReadonlySymbol(modifiersProp) ? 8 /* Readonly */ : 0;
                prop.type = propType;
                if (propertySymbol) {
                    prop.syntheticOrigin = propertySymbol;
                    prop.declarations = propertySymbol.declarations;
                }
                prop.syntheticLiteralTypeOrigin = t;
                members.set(propName, prop);
            }
            else if (t.flags & (1 /* Any */ | 2 /* String */)) {
                stringIndexInfo = createIndexInfo(propType, templateReadonly);
            }
        }
    }
    function getTypeParameterFromMappedType(type) {
        return type.typeParameter ||
            (type.typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfNode(type.declaration.typeParameter)));
    }
    function getConstraintTypeFromMappedType(type) {
        return type.constraintType ||
            (type.constraintType = instantiateType(getConstraintOfTypeParameter(getTypeParameterFromMappedType(type)), type.mapper || identityMapper) || unknownType);
    }
    function getTemplateTypeFromMappedType(type) {
        return type.templateType ||
            (type.templateType = type.declaration.type ?
                instantiateType(addOptionality(getTypeFromTypeNode(type.declaration.type), !!type.declaration.questionToken), type.mapper || identityMapper) :
                unknownType);
    }
    function getModifiersTypeFromMappedType(type) {
        if (!type.modifiersType) {
            let constraintDeclaration = type.declaration.typeParameter.constraint;
            if (constraintDeclaration.kind === 170 /* TypeOperator */) {
                // If the constraint declaration is a 'keyof T' node, the modifiers type is T. We check
                // AST nodes here because, when T is a non-generic type, the logic below eagerly resolves
                // 'keyof T' to a literal union type and we can't recover T from that type.
                type.modifiersType = instantiateType(getTypeFromTypeNode(constraintDeclaration.type), type.mapper || identityMapper);
            }
            else {
                // Otherwise, get the declared constraint type, and if the constraint type is a type parameter,
                // get the constraint of that type parameter. If the resulting type is an indexed type 'keyof T',
                // the modifiers type is T. Otherwise, the modifiers type is {}.
                let declaredType = getTypeFromMappedTypeNode(type.declaration);
                let constraint = getConstraintTypeFromMappedType(declaredType);
                let extendedConstraint = constraint && constraint.flags & 16384 /* TypeParameter */ ? getConstraintOfTypeParameter(constraint) : constraint;
                type.modifiersType = extendedConstraint && extendedConstraint.flags & 262144 /* Index */ ? instantiateType(extendedConstraint.type, type.mapper || identityMapper) : emptyObjectType;
            }
        }
        return type.modifiersType;
    }
    function isPartialMappedType(type) {
        return getObjectFlags(type) & 32 /* Mapped */ && !!type.declaration.questionToken;
    }
    function isGenericMappedType(type) {
        return getObjectFlags(type) & 32 /* Mapped */ && isGenericIndexType(getConstraintTypeFromMappedType(type));
    }
    function resolveStructuredTypeMembers(type) {
        if (!type.members) {
            if (type.flags & TypeFlags.Object) {
                if (type.objectFlags & 4 /* Reference */) {
                    resolveTypeReferenceMembers(type);
                }
                else if (type.objectFlags & 3 /* ClassOrInterface */) {
                    resolveClassOrInterfaceMembers(type);
                }
                else if (type.objectFlags & 16 /* Anonymous */) {
                    resolveAnonymousTypeMembers(type);
                }
                else if (type.objectFlags & 32 /* Mapped */) {
                    resolveMappedTypeMembers(type);
                }
            }
            else if (type.flags & 65536 /* Union */) {
                resolveUnionTypeMembers(type);
            }
            else if (type.flags & 131072 /* Intersection */) {
                resolveIntersectionTypeMembers(type);
            }
        }
        return type;
    }
    /** Return properties of an object type or an empty array for other types */
    function getPropertiesOfObjectType(type) {
        if (type.flags & TypeFlags.Object) {
            return resolveStructuredTypeMembers(type).properties;
        }
        return ts.emptyArray;
    }
    /** If the given type is an object type and that type has a property by the given name,
     * return the symbol for that property. Otherwise return undefined.
     */
    function getPropertyOfObjectType(type, name) {
        if (type.flags & TypeFlags.Object) {
            let resolved = resolveStructuredTypeMembers(type);
            let symbol = resolved.members.get(name);
            if (symbol && symbolIsValue(symbol)) {
                return symbol;
            }
        }
    }
    function getPropertiesOfUnionOrIntersectionType(type) {
        if (!type.resolvedProperties) {
            let members = ts.createSymbolTable();
            for (let _i = 0, _a = type.types; _i < _a.length; _i++) {
                let current = _a[_i];
                for (let _b = 0, _c = getPropertiesOfType(current); _b < _c.length; _b++) {
                    let prop = _c[_b];
                    if (!members.has(prop.escapedName)) {
                        let combinedProp = getPropertyOfUnionOrIntersectionType(type, prop.escapedName);
                        if (combinedProp) {
                            members.set(prop.escapedName, combinedProp);
                        }
                    }
                }
                // The properties of a union type are those that are present in all constituent types, so
                // we only need to check the properties of the first type
                if (type.flags & 65536 /* Union */) {
                    break;
                }
            }
            type.resolvedProperties = getNamedMembers(members);
        }
        return type.resolvedProperties;
    }
    function getPropertiesOfType(type) {
        type = getApparentType(type);
        return type.flags & 196608 /* UnionOrIntersection */ ?
            getPropertiesOfUnionOrIntersectionType(type) :
            getPropertiesOfObjectType(type);
    }
    function getAllPossiblePropertiesOfTypes(types) {
        let unionType = getUnionType(types);
        if (!(unionType.flags & 65536 /* Union */)) {
            return getPropertiesOfType(unionType);
        }
        let props = ts.createSymbolTable();
        for (let _i = 0, types_2 = types; _i < types_2.length; _i++) {
            let memberType = types_2[_i];
            for (let _a = 0, _b = getPropertiesOfType(memberType); _a < _b.length; _a++) {
                let escapedName = _b[_a].escapedName;
                if (!props.has(escapedName)) {
                    props.set(escapedName, createUnionOrIntersectionProperty(unionType, escapedName));
                }
            }
        }
        return ts.arrayFrom(props.values());
    }
    function getConstraintOfType(type) {
        return type.flags & 16384 /* TypeParameter */ ? getConstraintOfTypeParameter(type) :
            type.flags & 524288 /* IndexedAccess */ ? getConstraintOfIndexedAccess(type) :
                getBaseConstraintOfType(type);
    }
    function getConstraintOfTypeParameter(typeParameter) {
        return hasNonCircularBaseConstraint(typeParameter) ? getConstraintFromTypeParameter(typeParameter) : undefined;
    }
    function getConstraintOfIndexedAccess(type) {
        let transformed = getTransformedIndexedAccessType(type);
        if (transformed) {
            return transformed;
        }
        let baseObjectType = getBaseConstraintOfType(type.objectType);
        let baseIndexType = getBaseConstraintOfType(type.indexType);
        return baseObjectType || baseIndexType ? getIndexedAccessType(baseObjectType || type.objectType, baseIndexType || type.indexType) : undefined;
    }
    function getBaseConstraintOfType(type) {
        if (type.flags & (540672 /* TypeVariable */ | 196608 /* UnionOrIntersection */)) {
            let constraint = getResolvedBaseConstraint(type);
            if (constraint !== noConstraintType && constraint !== circularConstraintType) {
                return constraint;
            }
        }
        else if (type.flags & 262144 /* Index */) {
            return stringType;
        }
        return undefined;
    }
    function hasNonCircularBaseConstraint(type) {
        return getResolvedBaseConstraint(type) !== circularConstraintType;
    }
    /**
     * Return the resolved base constraint of a type variable. The noConstraintType singleton is returned if the
     * type variable has no constraint, and the circularConstraintType singleton is returned if the constraint
     * circularly references the type variable.
     */
    function getResolvedBaseConstraint(type) {
        let typeStack;
        let circular;
        if (!type.resolvedBaseConstraint) {
            typeStack = [];
            let constraint = getBaseConstraint(type);
            type.resolvedBaseConstraint = circular ? circularConstraintType : getTypeWithThisArgument(constraint || noConstraintType, type);
        }
        return type.resolvedBaseConstraint;
        function getBaseConstraint(t) {
            if (ts.contains(typeStack, t)) {
                circular = true;
                return undefined;
            }
            typeStack.push(t);
            let result = computeBaseConstraint(t);
            typeStack.pop();
            return result;
        }
        function computeBaseConstraint(t) {
            if (t.flags & 16384 /* TypeParameter */) {
                let constraint = getConstraintFromTypeParameter(t);
                return t.isThisType ? constraint :
                    constraint ? getBaseConstraint(constraint) : undefined;
            }
            if (t.flags & 196608 /* UnionOrIntersection */) {
                let types = t.types;
                let baseTypes = [];
                for (let _i = 0, types_3 = types; _i < types_3.length; _i++) {
                    let type_2 = types_3[_i];
                    let baseType = getBaseConstraint(type_2);
                    if (baseType) {
                        baseTypes.push(baseType);
                    }
                }
                return t.flags & 65536 /* Union */ && baseTypes.length === types.length ? getUnionType(baseTypes) :
                    t.flags & 131072 /* Intersection */ && baseTypes.length ? getIntersectionType(baseTypes) :
                        undefined;
            }
            if (t.flags & 262144 /* Index */) {
                return stringType;
            }
            if (t.flags & 524288 /* IndexedAccess */) {
                let transformed = getTransformedIndexedAccessType(t);
                if (transformed) {
                    return getBaseConstraint(transformed);
                }
                let baseObjectType = getBaseConstraint(t.objectType);
                let baseIndexType = getBaseConstraint(t.indexType);
                let baseIndexedAccess = baseObjectType && baseIndexType ? getIndexedAccessType(baseObjectType, baseIndexType) : undefined;
                return baseIndexedAccess && baseIndexedAccess !== unknownType ? getBaseConstraint(baseIndexedAccess) : undefined;
            }
            if (isGenericMappedType(t)) {
                return emptyObjectType;
            }
            return t;
        }
    }
    function getApparentTypeOfIntersectionType(type) {
        return type.resolvedApparentType || (type.resolvedApparentType = getTypeWithThisArgument(type, type));
    }
    function getResolvedTypeParameterDefault(typeParameter) {
        if (!typeParameter.default) {
            if (typeParameter.target) {
                let targetDefault = getResolvedTypeParameterDefault(typeParameter.target);
                typeParameter.default = targetDefault ? instantiateType(targetDefault, typeParameter.mapper) : noConstraintType;
            }
            else {
                // To block recursion, set the initial value to the resolvingDefaultType.
                typeParameter.default = resolvingDefaultType;
                let defaultDeclaration = typeParameter.symbol && ts.forEach(typeParameter.symbol.declarations, function (decl) { return ts.isTypeParameterDeclaration(decl) && decl.default; });
                let defaultType = defaultDeclaration ? getTypeFromTypeNode(defaultDeclaration) : noConstraintType;
                if (typeParameter.default === resolvingDefaultType) {
                    // If we have not been called recursively, set the correct default type.
                    typeParameter.default = defaultType;
                }
            }
        }
        else if (typeParameter.default === resolvingDefaultType) {
            // If we are called recursively for this type parameter, mark the default as circular.
            typeParameter.default = circularConstraintType;
        }
        return typeParameter.default;
    }
    /**
     * Gets the default type for a type parameter.
     *
     * If the type parameter is the result of an instantiation, this gets the instantiated
     * default type of its target. If the type parameter has no default type or the default is
     * circular, `undefined` is returned.
     */
    function getDefaultFromTypeParameter(typeParameter) {
        let defaultType = getResolvedTypeParameterDefault(typeParameter);
        return defaultType !== noConstraintType && defaultType !== circularConstraintType ? defaultType : undefined;
    }
    function hasNonCircularTypeParameterDefault(typeParameter) {
        return getResolvedTypeParameterDefault(typeParameter) !== circularConstraintType;
    }
    /**
     * Indicates whether the declaration of a typeParameter has a default type.
     */
    function hasTypeParameterDefault(typeParameter) {
        return !!(typeParameter.symbol && ts.forEach(typeParameter.symbol.declarations, function (decl) { return ts.isTypeParameterDeclaration(decl) && decl.default; }));
    }
    /**
     * For a type parameter, return the base constraint of the type parameter. For the string, number,
     * boolean, and symbol primitive types, return the corresponding object types. Otherwise return the
     * type itself. Note that the apparent type of a union type is the union type itself.
     */
    function getApparentType(type) {
        let t = type.flags & 540672 /* TypeVariable */ ? getBaseConstraintOfType(type) || emptyObjectType : type;
        return t.flags & 131072 /* Intersection */ ? getApparentTypeOfIntersectionType(t) :
            t.flags & 262178 /* StringLike */ ? globalStringType :
                t.flags & 84 /* NumberLike */ ? globalNumberType :
                    t.flags & 136 /* BooleanLike */ ? globalBooleanType :
                        t.flags & 512 /* ESSymbol */ ? getGlobalESSymbolType(/*reportErrors*/ languageVersion >= 2 /* ES2015 */) :
                            t.flags & 16777216 /* NonPrimitive */ ? emptyObjectType :
                                t;
    }
    function createUnionOrIntersectionProperty(containingType, name) {
        let props;
        let types = containingType.types;
        let isUnion = containingType.flags & 65536 /* Union */;
        let excludeModifiers = isUnion ? 24 /* NonPublicAccessibilityModifier */ : 0;
        // Flags we want to propagate to the result if they exist in all source symbols
        let commonFlags = isUnion ? 0 /* None */ : 16777216 /* Optional */;
        let syntheticFlag = 4 /* SyntheticMethod */;
        let checkFlags = 0;
        for (let _i = 0, types_4 = types; _i < types_4.length; _i++) {
            let current = types_4[_i];
            let type = getApparentType(current);
            if (type !== unknownType) {
                let prop = getPropertyOfType(type, name);
                let modifiers = prop ? ts.getDeclarationModifierFlagsFromSymbol(prop) : 0;
                if (prop && !(modifiers & excludeModifiers)) {
                    commonFlags &= prop.flags;
                    props = ts.appendIfUnique(props, prop);
                    checkFlags |= (isReadonlySymbol(prop) ? 8 /* Readonly */ : 0) |
                        (!(modifiers & 24 /* NonPublicAccessibilityModifier */) ? 64 /* ContainsPublic */ : 0) |
                        (modifiers & 16 /* Protected */ ? 128 /* ContainsProtected */ : 0) |
                        (modifiers & 8 /* Private */ ? 256 /* ContainsPrivate */ : 0) |
                        (modifiers & ModifierFlags.Static ? 512 /* ContainsStatic */ : 0);
                    if (!isMethodLike(prop)) {
                        syntheticFlag = 2 /* SyntheticProperty */;
                    }
                }
                else if (isUnion) {
                    checkFlags |= 16 /* Partial */;
                }
            }
        }
        if (!props) {
            return undefined;
        }
        if (props.length === 1 && !(checkFlags & 16 /* Partial */)) {
            return props[0];
        }
        let propTypes = [];
        let declarations = [];
        let commonType = undefined;
        for (let _a = 0, props_1 = props; _a < props_1.length; _a++) {
            let prop = props_1[_a];
            if (prop.declarations) {
                ts.addRange(declarations, prop.declarations);
            }
            let type = getTypeOfSymbol(prop);
            if (!commonType) {
                commonType = type;
            }
            else if (type !== commonType) {
                checkFlags |= 32 /* HasNonUniformType */;
            }
            propTypes.push(type);
        }
        let result = createSymbol(SymbolFlags.Property | commonFlags, name);
        result.checkFlags = syntheticFlag | checkFlags;
        result.containingType = containingType;
        result.declarations = declarations;
        result.type = isUnion ? getUnionType(propTypes) : getIntersectionType(propTypes);
        return result;
    }
    // Return the symbol for a given property in a union or intersection type, or undefined if the property
    // does not exist in any constituent type. Note that the returned property may only be present in some
    // constituents, in which case the isPartial flag is set when the containing type is union type. We need
    // these partial properties when identifying discriminant properties, but otherwise they are filtered out
    // and do not appear to be present in the union type.
    function getUnionOrIntersectionProperty(type, name) {
        let properties = type.propertyCache || (type.propertyCache = ts.createSymbolTable());
        let property = properties.get(name);
        if (!property) {
            property = createUnionOrIntersectionProperty(type, name);
            if (property) {
                properties.set(name, property);
            }
        }
        return property;
    }
    function getPropertyOfUnionOrIntersectionType(type, name) {
        let property = getUnionOrIntersectionProperty(type, name);
        // We need to filter out partial properties in union types
        return property && !(ts.getCheckFlags(property) & 16 /* Partial */) ? property : undefined;
    }
    /**
     * Return the symbol for the property with the given name in the given type. Creates synthetic union properties when
     * necessary, maps primitive types and type parameters are to their apparent types, and augments with properties from
     * Object and Function as appropriate.
     *
     * @param type a type to look up property from
     * @param name a name of property to look up in a given type
     */
    function getPropertyOfType(type, name) {
        type = getApparentType(type);
        if (type.flags & TypeFlags.Object) {
            let resolved = resolveStructuredTypeMembers(type);
            let symbol = resolved.members.get(name);
            if (symbol && symbolIsValue(symbol)) {
                return symbol;
            }
            if (resolved === anyFunctionType || resolved.callSignatures.length || resolved.constructSignatures.length) {
                let symbol_1 = getPropertyOfObjectType(globalFunctionType, name);
                if (symbol_1) {
                    return symbol_1;
                }
            }
            return getPropertyOfObjectType(globalObjectType, name);
        }
        if (type.flags & 196608 /* UnionOrIntersection */) {
            return getPropertyOfUnionOrIntersectionType(type, name);
        }
        return undefined;
    }
    function getSignaturesOfStructuredType(type, kind) {
        if (type.flags & 229376 /* StructuredType */) {
            let resolved = resolveStructuredTypeMembers(type);
            return kind === 0 /* Call */ ? resolved.callSignatures : resolved.constructSignatures;
        }
        return ts.emptyArray;
    }
    /**
     * Return the signatures of the given kind in the given type. Creates synthetic union signatures when necessary and
     * maps primitive types and type parameters are to their apparent types.
     */
    function getSignaturesOfType(type, kind) {
        return getSignaturesOfStructuredType(getApparentType(type), kind);
    }
    function getIndexInfoOfStructuredType(type, kind) {
        if (type.flags & 229376 /* StructuredType */) {
            let resolved = resolveStructuredTypeMembers(type);
            return kind === 0 /* String */ ? resolved.stringIndexInfo : resolved.numberIndexInfo;
        }
    }
    function getIndexTypeOfStructuredType(type, kind) {
        let info = getIndexInfoOfStructuredType(type, kind);
        return info && info.type;
    }
    // Return the indexing info of the given kind in the given type. Creates synthetic union index types when necessary and
    // maps primitive types and type parameters are to their apparent types.
    function getIndexInfoOfType(type, kind) {
        return getIndexInfoOfStructuredType(getApparentType(type), kind);
    }
    // Return the index type of the given kind in the given type. Creates synthetic union index types when necessary and
    // maps primitive types and type parameters are to their apparent types.
    function getIndexTypeOfType(type, kind) {
        return getIndexTypeOfStructuredType(getApparentType(type), kind);
    }
    function getImplicitIndexTypeOfType(type, kind) {
        if (isObjectTypeWithInferableIndex(type)) {
            let propTypes = [];
            for (let _i = 0, _a = getPropertiesOfType(type); _i < _a.length; _i++) {
                let prop = _a[_i];
                if (kind === 0 /* String */ || isNumericLiteralName(prop.escapedName)) {
                    propTypes.push(getTypeOfSymbol(prop));
                }
            }
            if (propTypes.length) {
                return getUnionType(propTypes, /*subtypeReduction*/ true);
            }
        }
        return undefined;
    }
    // Return list of type parameters with duplicates removed (duplicate identifier errors are generated in the actual
    // type checking functions).
    function getTypeParametersFromDeclaration(declaration) {
        let result;
        ts.forEach(ts.getEffectiveTypeParameterDeclarations(declaration), function (node) {
            let tp = getDeclaredTypeOfTypeParameter(node.symbol);
            result = ts.appendIfUnique(result, tp);
        });
        return result;
    }
    function symbolsToArray(symbols) {
        let result = [];
        symbols.forEach(function (symbol, id) {
            if (!isReservedMemberName(id)) {
                result.push(symbol);
            }
        });
        return result;
    }
    function isJSDocOptionalParameter(node) {
        if (ts.isInJavaScriptFile(node)) {
            if (node.type && node.type.kind === 275 /* JSDocOptionalType */) {
                return true;
            }
            let paramTags = ts.getJSDocParameterTags(node);
            if (paramTags) {
                for (let _i = 0, paramTags_1 = paramTags; _i < paramTags_1.length; _i++) {
                    let paramTag = paramTags_1[_i];
                    if (paramTag.isBracketed) {
                        return true;
                    }
                    if (paramTag.typeExpression) {
                        return paramTag.typeExpression.type.kind === 275 /* JSDocOptionalType */;
                    }
                }
            }
        }
    }
    function tryFindAmbientModule(moduleName, withAugmentations) {
        if (ts.isExternalModuleNameRelative(moduleName)) {
            return undefined;
        }
        let symbol = getSymbol(globals, '"' + moduleName + '"', 512 /* ValueModule */);
        // merged symbol is module declaration symbol combined with all augmentations
        return symbol && withAugmentations ? getMergedSymbol(symbol) : symbol;
    }
    function isOptionalParameter(node) {
        if (ts.hasQuestionToken(node) || isJSDocOptionalParameter(node)) {
            return true;
        }
        if (node.initializer) {
            let signatureDeclaration = node.parent;
            let signature = getSignatureFromDeclaration(signatureDeclaration);
            let parameterIndex = ts.indexOf(signatureDeclaration.parameters, node);
            ts.Debug.assert(parameterIndex >= 0);
            return parameterIndex >= signature.minArgumentCount;
        }
        let iife = ts.getImmediatelyInvokedFunctionExpression(node.parent);
        if (iife) {
            return !node.type &&
                !node.dotDotDotToken &&
                ts.indexOf(node.parent.parameters, node) >= iife.arguments.length;
        }
        return false;
    }
    function createTypePredicateFromTypePredicateNode(node) {
        let parameterName = node.parameterName;
        if (parameterName.kind === 71 /* Identifier */) {
            return {
                kind: 1 /* Identifier */,
                parameterName: parameterName ? parameterName.escapedText : undefined,
                parameterIndex: parameterName ? getTypePredicateParameterIndex(node.parent.parameters, parameterName) : undefined,
                type: getTypeFromTypeNode(node.type)
            };
        }
        else {
            return {
                kind: 0 /* This */,
                type: getTypeFromTypeNode(node.type)
            };
        }
    }
    /**
     * Gets the minimum number of type arguments needed to satisfy all non-optional type
     * parameters.
     */
    function getMinTypeArgumentCount(typeParameters) {
        let minTypeArgumentCount = 0;
        if (typeParameters) {
            for (let i = 0; i < typeParameters.length; i++) {
                if (!hasTypeParameterDefault(typeParameters[i])) {
                    minTypeArgumentCount = i + 1;
                }
            }
        }
        return minTypeArgumentCount;
    }
    /**
     * Fill in default types for unsupplied type arguments. If `typeArguments` is undefined
     * when a default type is supplied, a new array will be created and returned.
     *
     * @param typeArguments The supplied type arguments.
     * @param typeParameters The requested type parameters.
     * @param minTypeArgumentCount The minimum number of required type arguments.
     */
    function fillMissingTypeArguments(typeArguments, typeParameters, minTypeArgumentCount, isJavaScript) {
        let numTypeParameters = ts.length(typeParameters);
        if (numTypeParameters) {
            let numTypeArguments = ts.length(typeArguments);
            if ((isJavaScript || numTypeArguments >= minTypeArgumentCount) && numTypeArguments <= numTypeParameters) {
                if (!typeArguments) {
                    typeArguments = [];
                }
                // Map an unsatisfied type parameter with a default type.
                // If a type parameter does not have a default type, or if the default type
                // is a forward reference, the empty object type is used.
                for (let i = numTypeArguments; i < numTypeParameters; i++) {
                    typeArguments[i] = getDefaultTypeArgumentType(isJavaScript);
                }
                for (let i = numTypeArguments; i < numTypeParameters; i++) {
                    let mapper = createTypeMapper(typeParameters, typeArguments);
                    let defaultType = getDefaultFromTypeParameter(typeParameters[i]);
                    typeArguments[i] = defaultType ? instantiateType(defaultType, mapper) : getDefaultTypeArgumentType(isJavaScript);
                }
            }
        }
        return typeArguments;
    }
    function getSignatureFromDeclaration(declaration) {
        let links = getNodeLinks(declaration);
        if (!links.resolvedSignature) {
            let parameters = [];
            let hasLiteralTypes = false;
            let minArgumentCount = 0;
            let thisParameter = undefined;
            let hasThisParameter = void 0;
            let iife = ts.getImmediatelyInvokedFunctionExpression(declaration);
            let isJSConstructSignature = ts.isJSDocConstructSignature(declaration);
            let isUntypedSignatureInJSFile = !iife && !isJSConstructSignature && ts.isInJavaScriptFile(declaration) && !ts.hasJSDocParameterTags(declaration);
            // If this is a JSDoc construct signature, then skip the first parameter in the
            // parameter list.  The first parameter represents the return type of the construct
            // signature.
            for (let i = isJSConstructSignature ? 1 : 0; i < declaration.parameters.length; i++) {
                let param = declaration.parameters[i];
                let paramSymbol = param.symbol;
                // Include parameter symbol instead of property symbol in the signature
                if (paramSymbol && !!(paramSymbol.flags & SymbolFlags.Property) && !ts.isBindingPattern(param.name)) {
                    let resolvedSymbol = resolveName(param, paramSymbol.escapedName, SymbolFlags.Value, undefined, undefined, /*isUse*/ false);
                    paramSymbol = resolvedSymbol;
                }
                if (i === 0 && paramSymbol.escapedName === "this") {
                    hasThisParameter = true;
                    thisParameter = param.symbol;
                }
                else {
                    parameters.push(paramSymbol);
                }
                if (param.type && param.type.kind === 173 /* LiteralType */) {
                    hasLiteralTypes = true;
                }
                // Record a new minimum argument count if this is not an optional parameter
                let isOptionalParameter_1 = param.initializer || param.questionToken || param.dotDotDotToken ||
                    iife && parameters.length > iife.arguments.length && !param.type ||
                    isJSDocOptionalParameter(param) ||
                    isUntypedSignatureInJSFile;
                if (!isOptionalParameter_1) {
                    minArgumentCount = parameters.length;
                }
            }
            // If only one accessor includes a this-type annotation, the other behaves as if it had the same type annotation
            if ((declaration.kind === 153 /* GetAccessor */ || declaration.kind === 154 /* SetAccessor */) &&
                !ts.hasDynamicName(declaration) &&
                (!hasThisParameter || !thisParameter)) {
                let otherKind = declaration.kind === 153 /* GetAccessor */ ? 154 /* SetAccessor */ : 153 /* GetAccessor */;
                let other = ts.getDeclarationOfKind(declaration.symbol, otherKind);
                if (other) {
                    thisParameter = getAnnotatedAccessorThisParameter(other);
                }
            }
            let classType = declaration.kind === 152 /* Constructor */ ?
                getDeclaredTypeOfClassOrInterface(getMergedSymbol(declaration.parent.symbol))
                : undefined;
            let typeParameters = classType ? classType.localTypeParameters : getTypeParametersFromDeclaration(declaration);
            let returnType = getSignatureReturnTypeFromDeclaration(declaration, isJSConstructSignature, classType);
            let typePredicate = declaration.type && declaration.type.kind === 158 /* TypePredicate */ ?
                createTypePredicateFromTypePredicateNode(declaration.type) :
                undefined;
            // JS functions get a free rest parameter if they reference `arguments`
            let hasRestLikeParameter = ts.hasRestParameter(declaration);
            if (!hasRestLikeParameter && ts.isInJavaScriptFile(declaration) && containsArgumentsReference(declaration)) {
                hasRestLikeParameter = true;
                let syntheticArgsSymbol = createSymbol(3 /* Variable */, "args");
                syntheticArgsSymbol.type = anyArrayType;
                syntheticArgsSymbol.isRestParameter = true;
                parameters.push(syntheticArgsSymbol);
            }
            links.resolvedSignature = createSignature(declaration, typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, hasRestLikeParameter, hasLiteralTypes);
        }
        return links.resolvedSignature;
    }
    function getSignatureReturnTypeFromDeclaration(declaration, isJSConstructSignature, classType) {
        if (isJSConstructSignature) {
            return getTypeFromTypeNode(declaration.parameters[0].type);
        }
        else if (classType) {
            return classType;
        }
        let typeNode = ts.getEffectiveReturnTypeNode(declaration);
        if (typeNode) {
            return getTypeFromTypeNode(typeNode);
        }
        // TypeScript 1.0 spec (April 2014):
        // If only one accessor includes a type annotation, the other behaves as if it had the same type annotation.
        if (declaration.kind === 153 /* GetAccessor */ && !ts.hasDynamicName(declaration)) {
            let setter = ts.getDeclarationOfKind(declaration.symbol, 154 /* SetAccessor */);
            return getAnnotatedAccessorType(setter);
        }
        if (ts.nodeIsMissing(declaration.body)) {
            return anyType;
        }
    }
    function containsArgumentsReference(declaration) {
        let links = getNodeLinks(declaration);
        if (links.containsArgumentsReference === undefined) {
            if (links.flags & 8192 /* CaptureArguments */) {
                links.containsArgumentsReference = true;
            }
            else {
                links.containsArgumentsReference = traverse(declaration.body);
            }
        }
        return links.containsArgumentsReference;
        function traverse(node) {
            if (!node)
                return false;
            switch (node.kind) {
                case 71 /* Identifier */:
                    return node.escapedText === "arguments" && ts.isPartOfExpression(node);
                case SyntaxKind.PropertyDeclaration:
                case SyntaxKind.MethodDeclaration:
                case 153 /* GetAccessor */:
                case 154 /* SetAccessor */:
                    return node.name.kind === 144 /* ComputedPropertyName */
                        && traverse(node.name);
                default:
                    return !ts.nodeStartsNewLexicalEnvironment(node) && !ts.isPartOfTypeNode(node) && ts.forEachChild(node, traverse);
            }
        }
    }
    function getSignaturesOfSymbol(symbol) {
        if (!symbol)
            return ts.emptyArray;
        let result = [];
        for (let i = 0; i < symbol.declarations.length; i++) {
            let node = symbol.declarations[i];
            switch (node.kind) {
                case 160 /* FunctionType */:
                case 161 /* ConstructorType */:
                case 228 /* FunctionDeclaration */:
                case SyntaxKind.MethodDeclaration:
                case 150 /* MethodSignature */:
                case 152 /* Constructor */:
                case 155 /* CallSignature */:
                case 156 /* ConstructSignature */:
                case 157 /* IndexSignature */:
                case 153 /* GetAccessor */:
                case 154 /* SetAccessor */:
                case 186 /* FunctionExpression */:
                case 187 /* ArrowFunction */:
                case 276 /* JSDocFunctionType */:
                    // Don't include signature if node is the implementation of an overloaded function. A node is considered
                    // an implementation node if it has a body and the previous node is of the same kind and immediately
                    // precedes the implementation node (i.e. has the same parent and ends where the implementation starts).
                    if (i > 0 && node.body) {
                        let previous = symbol.declarations[i - 1];
                        if (node.parent === previous.parent && node.kind === previous.kind && node.pos === previous.end) {
                            break;
                        }
                    }
                    result.push(getSignatureFromDeclaration(node));
            }
        }
        return result;
    }
    function resolveExternalModuleTypeByLiteral(name) {
        let moduleSym = resolveExternalModuleName(name, name);
        if (moduleSym) {
            let resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
            if (resolvedModuleSymbol) {
                return getTypeOfSymbol(resolvedModuleSymbol);
            }
        }
        return anyType;
    }
    function getThisTypeOfSignature(signature) {
        if (signature.thisParameter) {
            return getTypeOfSymbol(signature.thisParameter);
        }
    }
    function getReturnTypeOfSignature(signature) {
        if (!signature.resolvedReturnType) {
            if (!pushTypeResolution(signature, 3 /* ResolvedReturnType */)) {
                return unknownType;
            }
            let type = void 0;
            if (signature.target) {
                type = instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper);
            }
            else if (signature.unionSignatures) {
                type = getUnionType(ts.map(signature.unionSignatures, getReturnTypeOfSignature), /*subtypeReduction*/ true);
            }
            else {
                type = getReturnTypeFromBody(signature.declaration);
            }
            if (!popTypeResolution()) {
                type = anyType;
                if (noImplicitAny) {
                    let declaration = signature.declaration;
                    let name = ts.getNameOfDeclaration(declaration);
                    if (name) {
                        error(name, ts.Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, ts.declarationNameToString(name));
                    }
                    else {
                        error(declaration, ts.Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions);
                    }
                }
            }
            signature.resolvedReturnType = type;
        }
        return signature.resolvedReturnType;
    }
    function isResolvingReturnTypeOfSignature(signature) {
        return !signature.resolvedReturnType && findResolutionCycleStartIndex(signature, 3 /* ResolvedReturnType */) >= 0;
    }
    function getRestTypeOfSignature(signature) {
        if (signature.hasRestParameter) {
            let type = getTypeOfSymbol(ts.lastOrUndefined(signature.parameters));
            if (getObjectFlags(type) & 4 /* Reference */ && type.target === globalArrayType) {
                return type.typeArguments[0];
            }
        }
        return anyType;
    }
    function getSignatureInstantiation(signature, typeArguments, isJavascript) {
        typeArguments = fillMissingTypeArguments(typeArguments, signature.typeParameters, getMinTypeArgumentCount(signature.typeParameters), isJavascript);
        let instantiations = signature.instantiations || (signature.instantiations = ts.createMap());
        let id = getTypeListId(typeArguments);
        let instantiation = instantiations.get(id);
        if (!instantiation) {
            instantiations.set(id, instantiation = createSignatureInstantiation(signature, typeArguments));
        }
        return instantiation;
    }
    function createSignatureInstantiation(signature, typeArguments) {
        return instantiateSignature(signature, createTypeMapper(signature.typeParameters, typeArguments), /*eraseTypeParameters*/ true);
    }
    function getErasedSignature(signature) {
        return signature.typeParameters ?
            signature.erasedSignatureCache || (signature.erasedSignatureCache = createErasedSignature(signature)) :
            signature;
    }
    function createErasedSignature(signature) {
        // Create an instantiation of the signature where all type arguments are the any type.
        return instantiateSignature(signature, createTypeEraser(signature.typeParameters), /*eraseTypeParameters*/ true);
    }
    function getCanonicalSignature(signature) {
        return signature.typeParameters ?
            signature.canonicalSignatureCache || (signature.canonicalSignatureCache = createCanonicalSignature(signature)) :
            signature;
    }
    function createCanonicalSignature(signature) {
        // Create an instantiation of the signature where each unconstrained type parameter is replaced with
        // its original. When a generic class or interface is instantiated, each generic method in the class or
        // interface is instantiated with a fresh set of cloned type parameters (which we need to handle scenarios
        // where different generations of the same type parameter are in scope). This leads to a lot of new type
        // identities, and potentially a lot of work comparing those identities, so here we create an instantiation
        // that uses the original type identities for all unconstrained type parameters.
        return getSignatureInstantiation(signature, ts.map(signature.typeParameters, function (tp) { return tp.target && !getConstraintOfTypeParameter(tp.target) ? tp.target : tp; }), ts.isInJavaScriptFile(signature.declaration));
    }
    function getOrCreateTypeFromSignature(signature) {
        // There are two ways to declare a construct signature, one is by declaring a class constructor
        // using the constructor keyword, and the other is declaring a bare construct signature in an
        // object type literal or interface (using the new keyword). Each way of declaring a constructor
        // will result in a different declaration kind.
        if (!signature.isolatedSignatureType) {
            let isConstructor = signature.declaration.kind === 152 /* Constructor */ || signature.declaration.kind === 156 /* ConstructSignature */;
            let type = createObjectType(16 /* Anonymous */);
            type.members = emptySymbols;
            type.properties = ts.emptyArray;
            type.callSignatures = !isConstructor ? [signature] : ts.emptyArray;
            type.constructSignatures = isConstructor ? [signature] : ts.emptyArray;
            signature.isolatedSignatureType = type;
        }
        return signature.isolatedSignatureType;
    }
    function getIndexSymbol(symbol) {
        return symbol.members.get("__index" /* Index */);
    }
    function getIndexDeclarationOfSymbol(symbol, kind) {
        let syntaxKind = kind === 1 /* Number */ ? 133 /* NumberKeyword */ : 136 /* StringKeyword */;
        let indexSymbol = getIndexSymbol(symbol);
        if (indexSymbol) {
            for (let _i = 0, _a = indexSymbol.declarations; _i < _a.length; _i++) {
                let decl = _a[_i];
                let node = decl;
                if (node.parameters.length === 1) {
                    let parameter = node.parameters[0];
                    if (parameter && parameter.type && parameter.type.kind === syntaxKind) {
                        return node;
                    }
                }
            }
        }
        return undefined;
    }
    function createIndexInfo(type, isReadonly, declaration) {
        return { type: type, isReadonly: isReadonly, declaration: declaration };
    }
    function getIndexInfoOfSymbol(symbol, kind) {
        let declaration = getIndexDeclarationOfSymbol(symbol, kind);
        if (declaration) {
            return createIndexInfo(declaration.type ? getTypeFromTypeNode(declaration.type) : anyType, ts.hasModifier(declaration, 64 /* Readonly */), declaration);
        }
        return undefined;
    }
    function getConstraintDeclaration(type) {
        return type.symbol && ts.getDeclarationOfKind(type.symbol, SyntaxKind.TypeParameter).constraint;
    }
    function getConstraintFromTypeParameter(typeParameter) {
        if (!typeParameter.constraint) {
            if (typeParameter.target) {
                let targetConstraint = getConstraintOfTypeParameter(typeParameter.target);
                typeParameter.constraint = targetConstraint ? instantiateType(targetConstraint, typeParameter.mapper) : noConstraintType;
            }
            else {
                let constraintDeclaration = getConstraintDeclaration(typeParameter);
                typeParameter.constraint = constraintDeclaration ? getTypeFromTypeNode(constraintDeclaration) : noConstraintType;
            }
        }
        return typeParameter.constraint === noConstraintType ? undefined : typeParameter.constraint;
    }
    function getParentSymbolOfTypeParameter(typeParameter) {
        return getSymbolOfNode(ts.getDeclarationOfKind(typeParameter.symbol, SyntaxKind.TypeParameter).parent);
    }
    function getTypeListId(types) {
        let result = "";
        if (types) {
            let length_4 = types.length;
            let i = 0;
            while (i < length_4) {
                let startId = types[i].id;
                let count = 1;
                while (i + count < length_4 && types[i + count].id === startId + count) {
                    count++;
                }
                if (result.length) {
                    result += ",";
                }
                result += startId;
                if (count > 1) {
                    result += ":" + count;
                }
                i += count;
            }
        }
        return result;
    }
    // This function is used to propagate certain flags when creating new object type references and union types.
    // It is only necessary to do so if a constituent type might be the undefined type, the null type, the type
    // of an object literal or the anyFunctionType. This is because there are operations in the type checker
    // that care about the presence of such types at arbitrary depth in a containing type.
    function getPropagatingFlagsOfTypes(types, excludeKinds) {
        let result = 0;
        for (let _i = 0, types_5 = types; _i < types_5.length; _i++) {
            let type = types_5[_i];
            if (!(type.flags & excludeKinds)) {
                result |= type.flags;
            }
        }
        return result & 14680064 /* PropagatingFlags */;
    }
    function createTypeReference(target, typeArguments) {
        let id = getTypeListId(typeArguments);
        let type = target.instantiations.get(id);
        if (!type) {
            type = createObjectType(4 /* Reference */, target.symbol);
            target.instantiations.set(id, type);
            type.flags |= typeArguments ? getPropagatingFlagsOfTypes(typeArguments, /*excludeKinds*/ 0) : 0;
            type.target = target;
            type.typeArguments = typeArguments;
        }
        return type;
    }
    function cloneTypeReference(source) {
        let type = createType(source.flags);
        type.symbol = source.symbol;
        type.objectFlags = source.objectFlags;
        type.target = source.target;
        type.typeArguments = source.typeArguments;
        return type;
    }
    function getTypeReferenceArity(type) {
        return ts.length(type.target.typeParameters);
    }
    /**
     * Get type from type-reference that reference to class or interface
     */
    function getTypeFromClassOrInterfaceReference(node, symbol, typeArgs) {
        let type = getDeclaredTypeOfSymbol(getMergedSymbol(symbol));
        let typeParameters = type.localTypeParameters;
        if (typeParameters) {
            let numTypeArguments = ts.length(node.typeArguments);
            let minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
            let isJavascript = ts.isInJavaScriptFile(node);
            if (!isJavascript && (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length)) {
                error(node, minTypeArgumentCount === typeParameters.length
                    ? ts.Diagnostics.Generic_type_0_requires_1_type_argument_s
                    : ts.Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments, typeToString(type, /*enclosingDeclaration*/ undefined, 1 /* WriteArrayAsGenericType */), minTypeArgumentCount, typeParameters.length);
                return unknownType;
            }
            // In a type reference, the outer type parameters of the referenced class or interface are automatically
            // supplied as type arguments and the type reference only specifies arguments for the local type parameters
            // of the class or interface.
            let typeArguments = ts.concatenate(type.outerTypeParameters, fillMissingTypeArguments(typeArgs, typeParameters, minTypeArgumentCount, isJavascript));
            return createTypeReference(type, typeArguments);
        }
        if (node.typeArguments) {
            error(node, ts.Diagnostics.Type_0_is_not_generic, typeToString(type));
            return unknownType;
        }
        return type;
    }
    function getTypeAliasInstantiation(symbol, typeArguments) {
        let type = getDeclaredTypeOfSymbol(symbol);
        let links = getSymbolLinks(symbol);
        let typeParameters = links.typeParameters;
        let id = getTypeListId(typeArguments);
        let instantiation = links.instantiations.get(id);
        if (!instantiation) {
            links.instantiations.set(id, instantiation = instantiateType(type, createTypeMapper(typeParameters, fillMissingTypeArguments(typeArguments, typeParameters, getMinTypeArgumentCount(typeParameters), ts.isInJavaScriptFile(symbol.valueDeclaration)))));
        }
        return instantiation;
    }
    /**
     * Get type from reference to type alias. When a type alias is generic, the declared type of the type alias may include
     * references to the type parameters of the alias. We replace those with the actual type arguments by instantiating the
     * declared type. Instantiations are cached using the type identities of the type arguments as the key.
     */
    function getTypeFromTypeAliasReference(node, symbol, typeArguments) {
        let type = getDeclaredTypeOfSymbol(symbol);
        let typeParameters = getSymbolLinks(symbol).typeParameters;
        if (typeParameters) {
            let numTypeArguments = ts.length(node.typeArguments);
            let minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
            if (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length) {
                error(node, minTypeArgumentCount === typeParameters.length
                    ? ts.Diagnostics.Generic_type_0_requires_1_type_argument_s
                    : ts.Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments, symbolToString(symbol), minTypeArgumentCount, typeParameters.length);
                return unknownType;
            }
            return getTypeAliasInstantiation(symbol, typeArguments);
        }
        if (node.typeArguments) {
            error(node, ts.Diagnostics.Type_0_is_not_generic, symbolToString(symbol));
            return unknownType;
        }
        return type;
    }
    function getTypeReferenceName(node) {
        switch (node.kind) {
            case 159 /* TypeReference */:
                return node.typeName;
            case 201 /* ExpressionWithTypeArguments */:
                // We only support expressions that are simple qualified names. For other
                // expressions this produces undefined.
                let expr = node.expression;
                if (ts.isEntityNameExpression(expr)) {
                    return expr;
                }
        }
        return undefined;
    }
    function resolveTypeReferenceName(typeReferenceName, meaning) {
        if (!typeReferenceName) {
            return unknownSymbol;
        }
        return resolveEntityName(typeReferenceName, meaning) || unknownSymbol;
    }
    function getTypeReferenceType(node, symbol) {
        let typeArguments = typeArgumentsFromTypeReferenceNode(node); // Do unconditionally so we mark type arguments as referenced.
        if (symbol === unknownSymbol) {
            return unknownType;
        }
        let type = getTypeReferenceTypeWorker(node, symbol, typeArguments);
        if (type) {
            return type;
        }
        // Get type from reference to named type that cannot be generic (enum or type parameter)
        let res = tryGetDeclaredTypeOfSymbol(symbol);
        if (res !== undefined) {
            if (typeArguments) {
                error(node, ts.Diagnostics.Type_0_is_not_generic, symbolToString(symbol));
                return unknownType;
            }
            return res;
        }
        if (!(symbol.flags & SymbolFlags.Value && isJSDocTypeReference(node))) {
            return unknownType;
        }
        // A jsdoc TypeReference may have resolved to a value (as opposed to a type). If
        // the symbol is a constructor function, return the inferred class type; otherwise,
        // the type of this reference is just the type of the value we resolved to.
        let valueType = getTypeOfSymbol(symbol);
        if (valueType.symbol && !isInferredClassType(valueType)) {
            let referenceType = getTypeReferenceTypeWorker(node, valueType.symbol, typeArguments);
            if (referenceType) {
                return referenceType;
            }
        }
        // Resolve the type reference as a Type for the purpose of reporting errors.
        resolveTypeReferenceName(getTypeReferenceName(node), SymbolFlags.Type);
        return valueType;
    }
    function getTypeReferenceTypeWorker(node, symbol, typeArguments) {
        if (symbol.flags & (32 /* Class */ | 64 /* Interface */)) {
            return getTypeFromClassOrInterfaceReference(node, symbol, typeArguments);
        }
        if (symbol.flags & 524288 /* TypeAlias */) {
            return getTypeFromTypeAliasReference(node, symbol, typeArguments);
        }
        if (symbol.flags & 16 /* Function */ &&
            isJSDocTypeReference(node) &&
            (symbol.members || ts.getJSDocClassTag(symbol.valueDeclaration))) {
            return getInferredClassType(symbol);
        }
    }
    function isJSDocTypeReference(node) {
        return node.flags & 1048576 /* JSDoc */ && node.kind === 159 /* TypeReference */;
    }
    function getIntendedTypeFromJSDocTypeReference(node) {
        if (ts.isIdentifier(node.typeName)) {
            if (node.typeName.escapedText === "Object") {
                if (ts.isJSDocIndexSignature(node)) {
                    let indexed = getTypeFromTypeNode(node.typeArguments[0]);
                    let target = getTypeFromTypeNode(node.typeArguments[1]);
                    let index = createIndexInfo(target, /*isReadonly*/ false);
                    return createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, indexed === stringType && index, indexed === numberType && index);
                }
                return anyType;
            }
            switch (node.typeName.escapedText) {
                case "String":
                    return stringType;
                case "Number":
                    return numberType;
                case "Boolean":
                    return booleanType;
                case "Void":
                    return voidType;
                case "Undefined":
                    return undefinedType;
                case "Null":
                    return nullType;
                case "Function":
                case "function":
                    return globalFunctionType;
                case "Array":
                case "array":
                    return !node.typeArguments || !node.typeArguments.length ? anyArrayType : undefined;
                case "Promise":
                case "promise":
                    return !node.typeArguments || !node.typeArguments.length ? createPromiseType(anyType) : undefined;
            }
        }
    }
    function getTypeFromJSDocNullableTypeNode(node) {
        let type = getTypeFromTypeNode(node.type);
        return strictNullChecks ? getUnionType([type, nullType]) : type;
    }
    function getTypeFromTypeReference(node) {
        let links = getNodeLinks(node);
        if (!links.resolvedType) {
            let symbol = void 0;
            let type = void 0;
            let meaning = SymbolFlags.Type;
            if (isJSDocTypeReference(node)) {
                type = getIntendedTypeFromJSDocTypeReference(node);
                meaning |= SymbolFlags.Value;
            }
            if (!type) {
                symbol = resolveTypeReferenceName(getTypeReferenceName(node), meaning);
                type = getTypeReferenceType(node, symbol);
            }
            // Cache both the resolved symbol and the resolved type. The resolved symbol is needed in when we check the
            // type reference in checkTypeReferenceOrExpressionWithTypeArguments.
            links.resolvedSymbol = symbol;
            links.resolvedType = type;
        }
        return links.resolvedType;
    }
    function typeArgumentsFromTypeReferenceNode(node) {
        return ts.map(node.typeArguments, getTypeFromTypeNode);
    }
    function getTypeFromTypeQueryNode(node) {
        let links = getNodeLinks(node);
        if (!links.resolvedType) {
            // TypeScript 1.0 spec (April 2014): 3.6.3
            // The expression is processed as an identifier expression (section 4.3)
            // or property access expression(section 4.10),
            // the widened type(section 3.9) of which becomes the result.
            links.resolvedType = getWidenedType(checkExpression(node.exprName));
        }
        return links.resolvedType;
    }
    function getTypeOfGlobalSymbol(symbol, arity) {
        function getTypeDeclaration(symbol) {
            let declarations = symbol.declarations;
            for (let _i = 0, declarations_3 = declarations; _i < declarations_3.length; _i++) {
                let declaration = declarations_3[_i];
                switch (declaration.kind) {
                    case SyntaxKind.ClassDeclaration:
                    case SyntaxKind.InterfaceDeclaration:
                    case SyntaxKind.EnumDeclaration:
                        return declaration;
                }
            }
        }
        if (!symbol) {
            return arity ? emptyGenericType : emptyObjectType;
        }
        let type = getDeclaredTypeOfSymbol(symbol);
        if (!(type.flags & TypeFlags.Object)) {
            error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_be_a_class_or_interface_type, ts.symbolName(symbol));
            return arity ? emptyGenericType : emptyObjectType;
        }
        if (ts.length(type.typeParameters) !== arity) {
            error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_have_1_type_parameter_s, ts.symbolName(symbol), arity);
            return arity ? emptyGenericType : emptyObjectType;
        }
        return type;
    }
    function getGlobalValueSymbol(name, reportErrors) {
        return getGlobalSymbol(name, SymbolFlags.Value, reportErrors ? ts.Diagnostics.Cannot_find_global_value_0 : undefined);
    }
    function getGlobalTypeSymbol(name, reportErrors) {
        return getGlobalSymbol(name, SymbolFlags.Type, reportErrors ? ts.Diagnostics.Cannot_find_global_type_0 : undefined);
    }
    function getGlobalSymbol(name, meaning, diagnostic) {
        // Don't track references for global symbols anyway, so value if `isReference` is arbitrary
        return resolveName(undefined, name, meaning, diagnostic, name, /*isUse*/ false);
    }
    function getGlobalType(name, arity, reportErrors) {
        let symbol = getGlobalTypeSymbol(name, reportErrors);
        return symbol || reportErrors ? getTypeOfGlobalSymbol(symbol, arity) : undefined;
    }
    function getGlobalTypedPropertyDescriptorType() {
        return deferredGlobalTypedPropertyDescriptorType || (deferredGlobalTypedPropertyDescriptorType = getGlobalType("TypedPropertyDescriptor", /*arity*/ 1, /*reportErrors*/ true)) || emptyGenericType;
    }
    function getGlobalTemplateStringsArrayType() {
        return deferredGlobalTemplateStringsArrayType || (deferredGlobalTemplateStringsArrayType = getGlobalType("TemplateStringsArray", /*arity*/ 0, /*reportErrors*/ true)) || emptyObjectType;
    }
    function getGlobalESSymbolConstructorSymbol(reportErrors) {
        return deferredGlobalESSymbolConstructorSymbol || (deferredGlobalESSymbolConstructorSymbol = getGlobalValueSymbol("Symbol", reportErrors));
    }
    function getGlobalESSymbolType(reportErrors) {
        return deferredGlobalESSymbolType || (deferredGlobalESSymbolType = getGlobalType("Symbol", /*arity*/ 0, reportErrors)) || emptyObjectType;
    }
    function getGlobalPromiseType(reportErrors) {
        return deferredGlobalPromiseType || (deferredGlobalPromiseType = getGlobalType("Promise", /*arity*/ 1, reportErrors)) || emptyGenericType;
    }
    function getGlobalPromiseConstructorSymbol(reportErrors) {
        return deferredGlobalPromiseConstructorSymbol || (deferredGlobalPromiseConstructorSymbol = getGlobalValueSymbol("Promise", reportErrors));
    }
    function getGlobalPromiseConstructorLikeType(reportErrors) {
        return deferredGlobalPromiseConstructorLikeType || (deferredGlobalPromiseConstructorLikeType = getGlobalType("PromiseConstructorLike", /*arity*/ 0, reportErrors)) || emptyObjectType;
    }
    function getGlobalAsyncIterableType(reportErrors) {
        return deferredGlobalAsyncIterableType || (deferredGlobalAsyncIterableType = getGlobalType("AsyncIterable", /*arity*/ 1, reportErrors)) || emptyGenericType;
    }
    function getGlobalAsyncIteratorType(reportErrors) {
        return deferredGlobalAsyncIteratorType || (deferredGlobalAsyncIteratorType = getGlobalType("AsyncIterator", /*arity*/ 1, reportErrors)) || emptyGenericType;
    }
    function getGlobalAsyncIterableIteratorType(reportErrors) {
        return deferredGlobalAsyncIterableIteratorType || (deferredGlobalAsyncIterableIteratorType = getGlobalType("AsyncIterableIterator", /*arity*/ 1, reportErrors)) || emptyGenericType;
    }
    function getGlobalIterableType(reportErrors) {
        return deferredGlobalIterableType || (deferredGlobalIterableType = getGlobalType("Iterable", /*arity*/ 1, reportErrors)) || emptyGenericType;
    }
    function getGlobalIteratorType(reportErrors) {
        return deferredGlobalIteratorType || (deferredGlobalIteratorType = getGlobalType("Iterator", /*arity*/ 1, reportErrors)) || emptyGenericType;
    }
    function getGlobalIterableIteratorType(reportErrors) {
        return deferredGlobalIterableIteratorType || (deferredGlobalIterableIteratorType = getGlobalType("IterableIterator", /*arity*/ 1, reportErrors)) || emptyGenericType;
    }
    function getGlobalTypeOrUndefined(name, arity) {
        if (arity === void 0) { arity = 0; }
        let symbol = getGlobalSymbol(name, SymbolFlags.Type, /*diagnostic*/ undefined);
        return symbol && getTypeOfGlobalSymbol(symbol, arity);
    }
    /**
     * Returns a type that is inside a namespace at the global scope, e.g.
     * getExportedTypeFromNamespace('JSX', 'Element') returns the JSX.Element type
     */
    function getExportedTypeFromNamespace(namespace, name) {
        let namespaceSymbol = getGlobalSymbol(namespace, SymbolFlags.Namespace, /*diagnosticMessage*/ undefined);
        let typeSymbol = namespaceSymbol && getSymbol(namespaceSymbol.exports, name, SymbolFlags.Type);
        return typeSymbol && getDeclaredTypeOfSymbol(typeSymbol);
    }
    /**
     * Instantiates a global type that is generic with some element type, and returns that instantiation.
     */
    function createTypeFromGenericGlobalType(genericGlobalType, typeArguments) {
        return genericGlobalType !== emptyGenericType ? createTypeReference(genericGlobalType, typeArguments) : emptyObjectType;
    }
    function createTypedPropertyDescriptorType(propertyType) {
        return createTypeFromGenericGlobalType(getGlobalTypedPropertyDescriptorType(), [propertyType]);
    }
    function createAsyncIterableType(iteratedType) {
        return createTypeFromGenericGlobalType(getGlobalAsyncIterableType(/*reportErrors*/ true), [iteratedType]);
    }
    function createAsyncIterableIteratorType(iteratedType) {
        return createTypeFromGenericGlobalType(getGlobalAsyncIterableIteratorType(/*reportErrors*/ true), [iteratedType]);
    }
    function createIterableType(iteratedType) {
        return createTypeFromGenericGlobalType(getGlobalIterableType(/*reportErrors*/ true), [iteratedType]);
    }
    function createIterableIteratorType(iteratedType) {
        return createTypeFromGenericGlobalType(getGlobalIterableIteratorType(/*reportErrors*/ true), [iteratedType]);
    }
    function createArrayType(elementType) {
        return createTypeFromGenericGlobalType(globalArrayType, [elementType]);
    }
    function getTypeFromArrayTypeNode(node) {
        let links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = createArrayType(getTypeFromTypeNode(node.elementType));
        }
        return links.resolvedType;
    }
    // We represent tuple types as type references to synthesized generic interface types created by
    // this function. The types are of the form:
    //
    //   interface Tuple<T0, T1, T2, ...> extends Array<T0 | T1 | T2 | ...> { 0: T0, 1: T1, 2: T2, ... }
    //
    // Note that the generic type created by this function has no symbol associated with it. The same
    // is true for each of the synthesized type parameters.
    function createTupleTypeOfArity(arity) {
        let typeParameters = [];
        let properties = [];
        for (let i = 0; i < arity; i++) {
            let typeParameter = createType(16384 /* TypeParameter */);
            typeParameters.push(typeParameter);
            let property = createSymbol(SymbolFlags.Property, "" + i);
            property.type = typeParameter;
            properties.push(property);
        }
        let type = createObjectType(8 /* Tuple */ | 4 /* Reference */);
        type.typeParameters = typeParameters;
        type.outerTypeParameters = undefined;
        type.localTypeParameters = typeParameters;
        type.instantiations = ts.createMap();
        type.instantiations.set(getTypeListId(type.typeParameters), type);
        type.target = type;
        type.typeArguments = type.typeParameters;
        type.thisType = createType(16384 /* TypeParameter */);
        type.thisType.isThisType = true;
        type.thisType.constraint = type;
        type.declaredProperties = properties;
        type.declaredCallSignatures = ts.emptyArray;
        type.declaredConstructSignatures = ts.emptyArray;
        type.declaredStringIndexInfo = undefined;
        type.declaredNumberIndexInfo = undefined;
        return type;
    }
    function getTupleTypeOfArity(arity) {
        return tupleTypes[arity] || (tupleTypes[arity] = createTupleTypeOfArity(arity));
    }
    function createTupleType(elementTypes) {
        return createTypeReference(getTupleTypeOfArity(elementTypes.length), elementTypes);
    }
    function getTypeFromTupleTypeNode(node) {
        let links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = createTupleType(ts.map(node.elementTypes, getTypeFromTypeNode));
        }
        return links.resolvedType;
    }
    function binarySearchTypes(types, type) {
        let low = 0;
        let high = types.length - 1;
        let typeId = type.id;
        while (low <= high) {
            let middle = low + ((high - low) >> 1);
            let id = types[middle].id;
            if (id === typeId) {
                return middle;
            }
            else if (id > typeId) {
                high = middle - 1;
            }
            else {
                low = middle + 1;
            }
        }
        return ~low;
    }
    function containsType(types, type) {
        return binarySearchTypes(types, type) >= 0;
    }
    // Return true if the given intersection type contains (a) more than one unit type or (b) an object
    // type and a nullable type (null or undefined).
    function isEmptyIntersectionType(type) {
        let combined = 0;
        for (let _i = 0, _a = type.types; _i < _a.length; _i++) {
            let t = _a[_i];
            if (t.flags & 6368 /* Unit */ && combined & 6368 /* Unit */) {
                return true;
            }
            combined |= t.flags;
            if (combined & 6144 /* Nullable */ && combined & (TypeFlags.Object | 16777216 /* NonPrimitive */)) {
                return true;
            }
        }
        return false;
    }
    function addTypeToUnion(typeSet, type) {
        let flags = type.flags;
        if (flags & 65536 /* Union */) {
            addTypesToUnion(typeSet, type.types);
        }
        else if (flags & 1 /* Any */) {
            typeSet.containsAny = true;
        }
        else if (!strictNullChecks && flags & 6144 /* Nullable */) {
            if (flags & 2048 /* Undefined */)
                typeSet.containsUndefined = true;
            if (flags & 4096 /* Null */)
                typeSet.containsNull = true;
            if (!(flags & 2097152 /* ContainsWideningType */))
                typeSet.containsNonWideningType = true;
        }
        else if (!(flags & 8192 /* Never */ || flags & 131072 /* Intersection */ && isEmptyIntersectionType(type))) {
            // We ignore 'never' types in unions. Likewise, we ignore intersections of unit types as they are
            // another form of 'never' (in that they have an empty value domain). We could in theory turn
            // intersections of unit types into 'never' upon construction, but deferring the reduction makes it
            // easier to reason about their origin.
            if (flags & 2 /* String */)
                typeSet.containsString = true;
            if (flags & 4 /* Number */)
                typeSet.containsNumber = true;
            if (flags & 96 /* StringOrNumberLiteral */)
                typeSet.containsStringOrNumberLiteral = true;
            let len = typeSet.length;
            let index = len && type.id > typeSet[len - 1].id ? ~len : binarySearchTypes(typeSet, type);
            if (index < 0) {
                if (!(flags & TypeFlags.Object && type.objectFlags & 16 /* Anonymous */ &&
                    type.symbol && type.symbol.flags & (16 /* Function */ | 8192 /* Method */) && containsIdenticalType(typeSet, type))) {
                    typeSet.splice(~index, 0, type);
                }
            }
        }
    }
    // Add the given types to the given type set. Order is preserved, duplicates are removed,
    // and nested types of the given kind are flattened into the set.
    function addTypesToUnion(typeSet, types) {
        for (let _i = 0, types_6 = types; _i < types_6.length; _i++) {
            let type = types_6[_i];
            addTypeToUnion(typeSet, type);
        }
    }
    function containsIdenticalType(types, type) {
        for (let _i = 0, types_7 = types; _i < types_7.length; _i++) {
            let t = types_7[_i];
            if (isTypeIdenticalTo(t, type)) {
                return true;
            }
        }
        return false;
    }
    function isSubtypeOfAny(candidate, types) {
        for (let _i = 0, types_8 = types; _i < types_8.length; _i++) {
            let type = types_8[_i];
            if (candidate !== type && isTypeSubtypeOf(candidate, type)) {
                return true;
            }
        }
        return false;
    }
    function isSetOfLiteralsFromSameEnum(types) {
        let first = types[0];
        if (first.flags & 256 /* EnumLiteral */) {
            let firstEnum = getParentOfSymbol(first.symbol);
            for (let i = 1; i < types.length; i++) {
                let other = types[i];
                if (!(other.flags & 256 /* EnumLiteral */) || (firstEnum !== getParentOfSymbol(other.symbol))) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    function removeSubtypes(types) {
        if (types.length === 0 || isSetOfLiteralsFromSameEnum(types)) {
            return;
        }
        let i = types.length;
        while (i > 0) {
            i--;
            if (isSubtypeOfAny(types[i], types)) {
                ts.orderedRemoveItemAt(types, i);
            }
        }
    }
    function removeRedundantLiteralTypes(types) {
        let i = types.length;
        while (i > 0) {
            i--;
            let t = types[i];
            let remove = t.flags & 32 /* StringLiteral */ && types.containsString ||
                t.flags & 64 /* NumberLiteral */ && types.containsNumber ||
                t.flags & 96 /* StringOrNumberLiteral */ && t.flags & 1048576 /* FreshLiteral */ && containsType(types, t.regularType);
            if (remove) {
                ts.orderedRemoveItemAt(types, i);
            }
        }
    }
    // We sort and deduplicate the constituent types based on object identity. If the subtypeReduction
    // flag is specified we also reduce the constituent type set to only include types that aren't subtypes
    // of other types. Subtype reduction is expensive for large union types and is possible only when union
    // types are known not to circularly reference themselves (as is the case with union types created by
    // expression constructs such as array literals and the || and ?: operators). Named types can
    // circularly reference themselves and therefore cannot be subtype reduced during their declaration.
    // For example, "type Item = string | (() => Item" is a named type that circularly references itself.
    function getUnionType(types, subtypeReduction, aliasSymbol, aliasTypeArguments) {
        if (types.length === 0) {
            return neverType;
        }
        if (types.length === 1) {
            return types[0];
        }
        let typeSet = [];
        addTypesToUnion(typeSet, types);
        if (typeSet.containsAny) {
            return anyType;
        }
        if (subtypeReduction) {
            removeSubtypes(typeSet);
        }
        else if (typeSet.containsStringOrNumberLiteral) {
            removeRedundantLiteralTypes(typeSet);
        }
        if (typeSet.length === 0) {
            return typeSet.containsNull ? typeSet.containsNonWideningType ? nullType : nullWideningType :
                typeSet.containsUndefined ? typeSet.containsNonWideningType ? undefinedType : undefinedWideningType :
                    neverType;
        }
        return getUnionTypeFromSortedList(typeSet, aliasSymbol, aliasTypeArguments);
    }
    // This function assumes the constituent type list is sorted and deduplicated.
    function getUnionTypeFromSortedList(types, aliasSymbol, aliasTypeArguments) {
        if (types.length === 0) {
            return neverType;
        }
        if (types.length === 1) {
            return types[0];
        }
        let id = getTypeListId(types);
        let type = unionTypes.get(id);
        if (!type) {
            let propagatedFlags = getPropagatingFlagsOfTypes(types, /*excludeKinds*/ 6144 /* Nullable */);
            type = createType(65536 /* Union */ | propagatedFlags);
            unionTypes.set(id, type);
            type.types = types;
            /*
            Note: This is the alias symbol (or lack thereof) that we see when we first encounter this union type.
            For aliases of identical unions, eg `type T = A | B; type U = A | B`, the symbol of the first alias encountered is the aliasSymbol.
            (In the language service, the order may depend on the order in which a user takes actions, such as hovering over symbols.)
            It's important that we create equivalent union types only once, so that's an unfortunate side effect.
            */
            type.aliasSymbol = aliasSymbol;
            type.aliasTypeArguments = aliasTypeArguments;
        }
        return type;
    }
    function getTypeFromUnionTypeNode(node) {
        let links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = getUnionType(ts.map(node.types, getTypeFromTypeNode), /*subtypeReduction*/ false, getAliasSymbolForTypeNode(node), getAliasTypeArgumentsForTypeNode(node));
        }
        return links.resolvedType;
    }
    function addTypeToIntersection(typeSet, type) {
        if (type.flags & 131072 /* Intersection */) {
            addTypesToIntersection(typeSet, type.types);
        }
        else if (type.flags & 1 /* Any */) {
            typeSet.containsAny = true;
        }
        else if (type.flags & 8192 /* Never */) {
            typeSet.containsNever = true;
        }
        else if (getObjectFlags(type) & 16 /* Anonymous */ && isEmptyObjectType(type)) {
            typeSet.containsEmptyObject = true;
        }
        else if ((strictNullChecks || !(type.flags & 6144 /* Nullable */)) && !ts.contains(typeSet, type)) {
            if (type.flags & TypeFlags.Object) {
                typeSet.containsObjectType = true;
            }
            if (type.flags & 65536 /* Union */ && typeSet.unionIndex === undefined) {
                typeSet.unionIndex = typeSet.length;
            }
            if (!(type.flags & TypeFlags.Object && type.objectFlags & 16 /* Anonymous */ &&
                type.symbol && type.symbol.flags & (16 /* Function */ | 8192 /* Method */) && containsIdenticalType(typeSet, type))) {
                typeSet.push(type);
            }
        }
    }
    // Add the given types to the given type set. Order is preserved, duplicates are removed,
    // and nested types of the given kind are flattened into the set.
    function addTypesToIntersection(typeSet, types) {
        for (let _i = 0, types_9 = types; _i < types_9.length; _i++) {
            let type = types_9[_i];
            addTypeToIntersection(typeSet, type);
        }
    }
    // We normalize combinations of intersection and union types based on the distributive property of the '&'
    // operator. Specifically, because X & (A | B) is equivalent to X & A | X & B, we can transform intersection
    // types with union type constituents into equivalent union types with intersection type constituents and
    // effectively ensure that union types are always at the top level in type representations.
    //
    // We do not perform structural deduplication on intersection types. Intersection types are created only by the &
    // type operator and we can't reduce those because we want to support recursive intersection types. For example,
    // a type alias of the form "type List<T> = T & { next: List<T> }" cannot be reduced during its declaration.
    // Also, unlike union types, the order of the constituent types is preserved in order that overload resolution
    // for intersections of types with signatures can be deterministic.
    function getIntersectionType(types, aliasSymbol, aliasTypeArguments) {
        if (types.length === 0) {
            return emptyObjectType;
        }
        let typeSet = [];
        addTypesToIntersection(typeSet, types);
        if (typeSet.containsNever) {
            return neverType;
        }
        if (typeSet.containsAny) {
            return anyType;
        }
        if (typeSet.containsEmptyObject && !typeSet.containsObjectType) {
            typeSet.push(emptyObjectType);
        }
        if (typeSet.length === 1) {
            return typeSet[0];
        }
        let unionIndex = typeSet.unionIndex;
        if (unionIndex !== undefined) {
            // We are attempting to construct a type of the form X & (A | B) & Y. Transform this into a type of
            // the form X & A & Y | X & B & Y and recursively reduce until no union type constituents remain.
            let unionType = typeSet[unionIndex];
            return getUnionType(ts.map(unionType.types, function (t) { return getIntersectionType(ts.replaceElement(typeSet, unionIndex, t)); }),
            /*subtypeReduction*/ false, aliasSymbol, aliasTypeArguments);
        }
        let id = getTypeListId(typeSet);
        let type = intersectionTypes.get(id);
        if (!type) {
            let propagatedFlags = getPropagatingFlagsOfTypes(typeSet, /*excludeKinds*/ 6144 /* Nullable */);
            type = createType(131072 /* Intersection */ | propagatedFlags);
            intersectionTypes.set(id, type);
            type.types = typeSet;
            type.aliasSymbol = aliasSymbol; // See comment in `getUnionTypeFromSortedList`.
            type.aliasTypeArguments = aliasTypeArguments;
        }
        return type;
    }
    function getTypeFromIntersectionTypeNode(node) {
        let links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = getIntersectionType(ts.map(node.types, getTypeFromTypeNode), getAliasSymbolForTypeNode(node), getAliasTypeArgumentsForTypeNode(node));
        }
        return links.resolvedType;
    }
    function getIndexTypeForGenericType(type) {
        if (!type.resolvedIndexType) {
            type.resolvedIndexType = createType(262144 /* Index */);
            type.resolvedIndexType.type = type;
        }
        return type.resolvedIndexType;
    }
    function getLiteralTypeFromPropertyName(prop) {
        return ts.getDeclarationModifierFlagsFromSymbol(prop) & 24 /* NonPublicAccessibilityModifier */ || ts.startsWith(prop.escapedName, "__@") ?
            neverType :
            getLiteralType(ts.symbolName(prop));
    }
    function getLiteralTypeFromPropertyNames(type) {
        return getUnionType(ts.map(getPropertiesOfType(type), getLiteralTypeFromPropertyName));
    }
    function getIndexType(type) {
        return maybeTypeOfKind(type, 540672 /* TypeVariable */) ? getIndexTypeForGenericType(type) :
            getObjectFlags(type) & 32 /* Mapped */ ? getConstraintTypeFromMappedType(type) :
                type.flags & 1 /* Any */ || getIndexInfoOfType(type, 0 /* String */) ? stringType :
                    getLiteralTypeFromPropertyNames(type);
    }
    function getIndexTypeOrString(type) {
        let indexType = getIndexType(type);
        return indexType !== neverType ? indexType : stringType;
    }
    function getTypeFromTypeOperatorNode(node) {
        let links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = getIndexType(getTypeFromTypeNode(node.type));
        }
        return links.resolvedType;
    }
    function createIndexedAccessType(objectType, indexType) {
        let type = createType(524288 /* IndexedAccess */);
        type.objectType = objectType;
        type.indexType = indexType;
        return type;
    }
    function getPropertyTypeForIndexType(objectType, indexType, accessNode, cacheSymbol) {
        let accessExpression = accessNode && accessNode.kind === 180 /* ElementAccessExpression */ ? accessNode : undefined;
        let propName = indexType.flags & 96 /* StringOrNumberLiteral */ ?
            ts.escapeLeadingUnderscores("" + indexType.value) :
            accessExpression && checkThatExpressionIsProperSymbolReference(accessExpression.argumentExpression, indexType, /*reportError*/ false) ?
                ts.getPropertyNameForKnownSymbolName(ts.idText(accessExpression.argumentExpression.name)) :
                undefined;
        if (propName !== undefined) {
            let prop = getPropertyOfType(objectType, propName);
            if (prop) {
                if (accessExpression) {
                    if (ts.isAssignmentTarget(accessExpression) && (isReferenceToReadonlyEntity(accessExpression, prop) || isReferenceThroughNamespaceImport(accessExpression))) {
                        error(accessExpression.argumentExpression, ts.Diagnostics.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, symbolToString(prop));
                        return unknownType;
                    }
                    if (cacheSymbol) {
                        getNodeLinks(accessNode).resolvedSymbol = prop;
                    }
                }
                return getTypeOfSymbol(prop);
            }
        }
        if (!(indexType.flags & 6144 /* Nullable */) && isTypeAssignableToKind(indexType, 262178 /* StringLike */ | 84 /* NumberLike */ | 512 /* ESSymbol */)) {
            if (isTypeAny(objectType)) {
                return anyType;
            }
            let indexInfo = isTypeAssignableToKind(indexType, 84 /* NumberLike */) && getIndexInfoOfType(objectType, 1 /* Number */) ||
                getIndexInfoOfType(objectType, 0 /* String */) ||
                undefined;
            if (indexInfo) {
                if (accessExpression && indexInfo.isReadonly && (ts.isAssignmentTarget(accessExpression) || ts.isDeleteTarget(accessExpression))) {
                    error(accessExpression, ts.Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
                }
                return indexInfo.type;
            }
            if (accessExpression && !isConstEnumObjectType(objectType)) {
                if (noImplicitAny && !compilerOptions.suppressImplicitAnyIndexErrors) {
                    if (getIndexTypeOfType(objectType, 1 /* Number */)) {
                        error(accessExpression.argumentExpression, ts.Diagnostics.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number);
                    }
                    else {
                        error(accessExpression, ts.Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature, typeToString(objectType));
                    }
                }
                return anyType;
            }
        }
        if (accessNode) {
            let indexNode = accessNode.kind === 180 /* ElementAccessExpression */ ? accessNode.argumentExpression : accessNode.indexType;
            if (indexType.flags & (32 /* StringLiteral */ | 64 /* NumberLiteral */)) {
                error(indexNode, ts.Diagnostics.Property_0_does_not_exist_on_type_1, "" + indexType.value, typeToString(objectType));
            }
            else if (indexType.flags & (2 /* String */ | 4 /* Number */)) {
                error(indexNode, ts.Diagnostics.Type_0_has_no_matching_index_signature_for_type_1, typeToString(objectType), typeToString(indexType));
            }
            else {
                error(indexNode, ts.Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
            }
            return unknownType;
        }
        return anyType;
    }
    function isGenericObjectType(type) {
        return type.flags & 540672 /* TypeVariable */ ? true :
            getObjectFlags(type) & 32 /* Mapped */ ? isGenericIndexType(getConstraintTypeFromMappedType(type)) :
                type.flags & 196608 /* UnionOrIntersection */ ? ts.forEach(type.types, isGenericObjectType) :
                    false;
    }
    function isGenericIndexType(type) {
        return type.flags & (540672 /* TypeVariable */ | 262144 /* Index */) ? true :
            type.flags & 196608 /* UnionOrIntersection */ ? ts.forEach(type.types, isGenericIndexType) :
                false;
    }
    // Return true if the given type is a non-generic object type with a string index signature and no
    // other members.
    function isStringIndexOnlyType(type) {
        if (type.flags & TypeFlags.Object && !isGenericMappedType(type)) {
            let t = resolveStructuredTypeMembers(type);
            return t.properties.length === 0 &&
                t.callSignatures.length === 0 && t.constructSignatures.length === 0 &&
                t.stringIndexInfo && !t.numberIndexInfo;
        }
        return false;
    }
    // Transform an indexed access to a simpler form, if possible. Return the simpler form, or return
    // undefined if no transformation is possible.
    function getTransformedIndexedAccessType(type) {
        let objectType = type.objectType;
        // Given an indexed access type T[K], if T is an intersection containing one or more generic types and one or
        // more object types with only a string index signature, e.g. '(U & V & { [x: string]: D })[K]', return a
        // transformed type of the form '(U & V)[K] | D'. This allows us to properly reason about higher order indexed
        // access types with default property values as expressed by D.
        if (objectType.flags & 131072 /* Intersection */ && isGenericObjectType(objectType) && ts.some(objectType.types, isStringIndexOnlyType)) {
            let regularTypes = [];
            let stringIndexTypes = [];
            for (let _i = 0, _a = objectType.types; _i < _a.length; _i++) {
                let t = _a[_i];
                if (isStringIndexOnlyType(t)) {
                    stringIndexTypes.push(getIndexTypeOfType(t, 0 /* String */));
                }
                else {
                    regularTypes.push(t);
                }
            }
            return getUnionType([
                getIndexedAccessType(getIntersectionType(regularTypes), type.indexType),
                getIntersectionType(stringIndexTypes)
            ]);
        }
        // If the object type is a mapped type { [P in K]: E }, where K is generic, instantiate E using a mapper
        // that substitutes the index type for P. For example, for an index access { [P in K]: Box<T[P]> }[X], we
        // construct the type Box<T[X]>.
        if (isGenericMappedType(objectType)) {
            let mapper = createTypeMapper([getTypeParameterFromMappedType(objectType)], [type.indexType]);
            let objectTypeMapper = objectType.mapper;
            let templateMapper = objectTypeMapper ? combineTypeMappers(objectTypeMapper, mapper) : mapper;
            return instantiateType(getTemplateTypeFromMappedType(objectType), templateMapper);
        }
        return undefined;
    }
    function getIndexedAccessType(objectType, indexType, accessNode) {
        // If the index type is generic, or if the object type is generic and doesn't originate in an expression,
        // we are performing a higher-order index access where we cannot meaningfully access the properties of the
        // object type. Note that for a generic T and a non-generic K, we eagerly resolve T[K] if it originates in
        // an expression. This is to preserve backwards compatibility. For example, an element access 'this["foo"]'
        // has always been resolved eagerly using the constraint type of 'this' at the given location.
        if (isGenericIndexType(indexType) || !(accessNode && accessNode.kind === 180 /* ElementAccessExpression */) && isGenericObjectType(objectType)) {
            if (objectType.flags & 1 /* Any */) {
                return objectType;
            }
            // Defer the operation by creating an indexed access type.
            let id = objectType.id + "," + indexType.id;
            let type = indexedAccessTypes.get(id);
            if (!type) {
                indexedAccessTypes.set(id, type = createIndexedAccessType(objectType, indexType));
            }
            return type;
        }
        // In the following we resolve T[K] to the type of the property in T selected by K.
        // We treat boolean as different from other unions to improve errors;
        // skipping straight to getPropertyTypeForIndexType gives errors with 'boolean' instead of 'true'.
        let apparentObjectType = getApparentType(objectType);
        if (indexType.flags & 65536 /* Union */ && !(indexType.flags & 8 /* Boolean */)) {
            let propTypes = [];
            for (let _i = 0, _a = indexType.types; _i < _a.length; _i++) {
                let t = _a[_i];
                let propType = getPropertyTypeForIndexType(apparentObjectType, t, accessNode, /*cacheSymbol*/ false);
                if (propType === unknownType) {
                    return unknownType;
                }
                propTypes.push(propType);
            }
            return getUnionType(propTypes);
        }
        return getPropertyTypeForIndexType(apparentObjectType, indexType, accessNode, /*cacheSymbol*/ true);
    }
    function getTypeFromIndexedAccessTypeNode(node) {
        let links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = getIndexedAccessType(getTypeFromTypeNode(node.objectType), getTypeFromTypeNode(node.indexType), node);
        }
        return links.resolvedType;
    }
    function getTypeFromMappedTypeNode(node) {
        let links = getNodeLinks(node);
        if (!links.resolvedType) {
            let type = createObjectType(32 /* Mapped */, node.symbol);
            type.declaration = node;
            type.aliasSymbol = getAliasSymbolForTypeNode(node);
            type.aliasTypeArguments = getAliasTypeArgumentsForTypeNode(node);
            links.resolvedType = type;
            // Eagerly resolve the constraint type which forces an error if the constraint type circularly
            // references itself through one or more type aliases.
            getConstraintTypeFromMappedType(type);
        }
        return links.resolvedType;
    }
    function getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node) {
        let links = getNodeLinks(node);
        if (!links.resolvedType) {
            // Deferred resolution of members is handled by resolveObjectTypeMembers
            let aliasSymbol = getAliasSymbolForTypeNode(node);
            if (node.symbol.members.size === 0 && !aliasSymbol) {
                links.resolvedType = emptyTypeLiteralType;
            }
            else {
                let type = createObjectType(16 /* Anonymous */, node.symbol);
                type.aliasSymbol = aliasSymbol;
                type.aliasTypeArguments = getAliasTypeArgumentsForTypeNode(node);
                if (ts.isJSDocTypeLiteral(node) && node.isArrayType) {
                    type = createArrayType(type);
                }
                links.resolvedType = type;
            }
        }
        return links.resolvedType;
    }
    function getAliasSymbolForTypeNode(node) {
        return node.parent.kind === 231 /* TypeAliasDeclaration */ ? getSymbolOfNode(node.parent) : undefined;
    }
    function getAliasTypeArgumentsForTypeNode(node) {
        let symbol = getAliasSymbolForTypeNode(node);
        return symbol ? getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol) : undefined;
    }
    /**
     * Since the source of spread types are object literals, which are not binary,
     * this function should be called in a left folding style, with left = previous result of getSpreadType
     * and right = the new element to be spread.
     */
    function getSpreadType(left, right, symbol, propagatedFlags) {
        if (left.flags & 1 /* Any */ || right.flags & 1 /* Any */) {
            return anyType;
        }
        if (left.flags & 8192 /* Never */) {
            return right;
        }
        if (right.flags & 8192 /* Never */) {
            return left;
        }
        if (left.flags & 65536 /* Union */) {
            return mapType(left, function (t) { return getSpreadType(t, right, symbol, propagatedFlags); });
        }
        if (right.flags & 65536 /* Union */) {
            return mapType(right, function (t) { return getSpreadType(left, t, symbol, propagatedFlags); });
        }
        if (right.flags & 16777216 /* NonPrimitive */) {
            return nonPrimitiveType;
        }
        if (right.flags & (136 /* BooleanLike */ | 84 /* NumberLike */ | 262178 /* StringLike */ | 272 /* EnumLike */)) {
            return left;
        }
        let members = ts.createSymbolTable();
        let skippedPrivateMembers = ts.createUnderscoreEscapedMap();
        let stringIndexInfo;
        let numberIndexInfo;
        if (left === emptyObjectType) {
            // for the first spread element, left === emptyObjectType, so take the right's string indexer
            stringIndexInfo = getIndexInfoOfType(right, 0 /* String */);
            numberIndexInfo = getIndexInfoOfType(right, 1 /* Number */);
        }
        else {
            stringIndexInfo = unionSpreadIndexInfos(getIndexInfoOfType(left, 0 /* String */), getIndexInfoOfType(right, 0 /* String */));
            numberIndexInfo = unionSpreadIndexInfos(getIndexInfoOfType(left, 1 /* Number */), getIndexInfoOfType(right, 1 /* Number */));
        }
        for (let _i = 0, _a = getPropertiesOfType(right); _i < _a.length; _i++) {
            let rightProp = _a[_i];
            // we approximate own properties as non-methods plus methods that are inside the object literal
            let isSetterWithoutGetter = rightProp.flags & 65536 /* SetAccessor */ && !(rightProp.flags & 32768 /* GetAccessor */);
            if (ts.getDeclarationModifierFlagsFromSymbol(rightProp) & (8 /* Private */ | 16 /* Protected */)) {
                skippedPrivateMembers.set(rightProp.escapedName, true);
            }
            else if (!isClassMethod(rightProp) && !isSetterWithoutGetter) {
                members.set(rightProp.escapedName, getNonReadonlySymbol(rightProp));
            }
        }
        for (let _b = 0, _c = getPropertiesOfType(left); _b < _c.length; _b++) {
            let leftProp = _c[_b];
            if (leftProp.flags & 65536 /* SetAccessor */ && !(leftProp.flags & 32768 /* GetAccessor */)
                || skippedPrivateMembers.has(leftProp.escapedName)
                || isClassMethod(leftProp)) {
                continue;
            }
            if (members.has(leftProp.escapedName)) {
                let rightProp = members.get(leftProp.escapedName);
                let rightType = getTypeOfSymbol(rightProp);
                if (rightProp.flags & 16777216 /* Optional */) {
                    let declarations = ts.concatenate(leftProp.declarations, rightProp.declarations);
                    let flags = SymbolFlags.Property | (leftProp.flags & 16777216 /* Optional */);
                    let result = createSymbol(flags, leftProp.escapedName);
                    result.type = getUnionType([getTypeOfSymbol(leftProp), getTypeWithFacts(rightType, 131072 /* NEUndefined */)]);
                    result.leftSpread = leftProp;
                    result.rightSpread = rightProp;
                    result.declarations = declarations;
                    members.set(leftProp.escapedName, result);
                }
            }
            else {
                members.set(leftProp.escapedName, getNonReadonlySymbol(leftProp));
            }
        }
        let spread = createAnonymousType(undefined, members, ts.emptyArray, ts.emptyArray, stringIndexInfo, numberIndexInfo);
        spread.flags |= propagatedFlags;
        spread.flags |= 1048576 /* FreshLiteral */ | 4194304 /* ContainsObjectLiteral */;
        spread.objectFlags |= 128 /* ObjectLiteral */;
        spread.symbol = symbol;
        return spread;
    }
    function getNonReadonlySymbol(prop) {
        if (!isReadonlySymbol(prop)) {
            return prop;
        }
        let flags = SymbolFlags.Property | (prop.flags & 16777216 /* Optional */);
        let result = createSymbol(flags, prop.escapedName);
        result.type = getTypeOfSymbol(prop);
        result.declarations = prop.declarations;
        result.syntheticOrigin = prop;
        return result;
    }
    function isClassMethod(prop) {
        return prop.flags & 8192 /* Method */ && ts.find(prop.declarations, function (decl) { return ts.isClassLike(decl.parent); });
    }
    function createLiteralType(flags, value, symbol) {
        let type = createType(flags);
        type.symbol = symbol;
        type.value = value;
        return type;
    }
    function getFreshTypeOfLiteralType(type) {
        if (type.flags & 96 /* StringOrNumberLiteral */ && !(type.flags & 1048576 /* FreshLiteral */)) {
            if (!type.freshType) {
                let freshType = createLiteralType(type.flags | 1048576 /* FreshLiteral */, type.value, type.symbol);
                freshType.regularType = type;
                type.freshType = freshType;
            }
            return type.freshType;
        }
        return type;
    }
    function getRegularTypeOfLiteralType(type) {
        return type.flags & 96 /* StringOrNumberLiteral */ && type.flags & 1048576 /* FreshLiteral */ ? type.regularType : type;
    }
    function getLiteralType(value, enumId, symbol) {
        // We store all literal types in a single map with keys of the form '#NNN' and '@SSS',
        // where NNN is the text representation of a numeric literal and SSS are the characters
        // of a string literal. For literal enum members we use 'EEE#NNN' and 'EEE@SSS', where
        // EEE is a unique id for the containing enum type.
        let qualifier = typeof value === "number" ? "#" : "@";
        let key = enumId ? enumId + qualifier + value : qualifier + value;
        let type = literalTypes.get(key);
        if (!type) {
            let flags = (typeof value === "number" ? 64 /* NumberLiteral */ : 32 /* StringLiteral */) | (enumId ? 256 /* EnumLiteral */ : 0);
            literalTypes.set(key, type = createLiteralType(flags, value, symbol));
        }
        return type;
    }
    function getTypeFromLiteralTypeNode(node) {
        let links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = getRegularTypeOfLiteralType(checkExpression(node.literal));
        }
        return links.resolvedType;
    }
    function getTypeFromJSDocVariadicType(node) {
        let links = getNodeLinks(node);
        if (!links.resolvedType) {
            let type = getTypeFromTypeNode(node.type);
            links.resolvedType = type ? createArrayType(type) : unknownType;
        }
        return links.resolvedType;
    }
    function getThisType(node) {
        let container = ts.getThisContainer(node, /*includeArrowFunctions*/ false);
        let parent = container && container.parent;
        if (parent && (ts.isClassLike(parent) || parent.kind === SyntaxKind.InterfaceDeclaration)) {
            if (!ts.hasModifier(container, ModifierFlags.Static) &&
                (container.kind !== 152 /* Constructor */ || ts.isNodeDescendantOf(node, container.body))) {
                return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent)).thisType;
            }
        }
        error(node, ts.Diagnostics.A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface);
        return unknownType;
    }
    function getTypeFromThisTypeNode(node) {
        let links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = getThisType(node);
        }
        return links.resolvedType;
    }
    function getTypeFromTypeNode(node) {
        switch (node.kind) {
            case 119 /* AnyKeyword */:
            case 271 /* JSDocAllType */:
            case 272 /* JSDocUnknownType */:
                return anyType;
            case 136 /* StringKeyword */:
                return stringType;
            case 133 /* NumberKeyword */:
                return numberType;
            case 122 /* BooleanKeyword */:
                return booleanType;
            case 137 /* SymbolKeyword */:
                return esSymbolType;
            case 105 /* VoidKeyword */:
                return voidType;
            case 139 /* UndefinedKeyword */:
                return undefinedType;
            case 95 /* NullKeyword */:
                return nullType;
            case 130 /* NeverKeyword */:
                return neverType;
            case 134 /* ObjectKeyword */:
                return node.flags & 65536 /* JavaScriptFile */ ? anyType : nonPrimitiveType;
            case 169 /* ThisType */:
            case 99 /* ThisKeyword */:
                return getTypeFromThisTypeNode(node);
            case 173 /* LiteralType */:
                return getTypeFromLiteralTypeNode(node);
            case 159 /* TypeReference */:
                return getTypeFromTypeReference(node);
            case 158 /* TypePredicate */:
                return booleanType;
            case 201 /* ExpressionWithTypeArguments */:
                return getTypeFromTypeReference(node);
            case 162 /* TypeQuery */:
                return getTypeFromTypeQueryNode(node);
            case 164 /* ArrayType */:
                return getTypeFromArrayTypeNode(node);
            case 165 /* TupleType */:
                return getTypeFromTupleTypeNode(node);
            case 166 /* UnionType */:
                return getTypeFromUnionTypeNode(node);
            case 167 /* IntersectionType */:
                return getTypeFromIntersectionTypeNode(node);
            case 273 /* JSDocNullableType */:
                return getTypeFromJSDocNullableTypeNode(node);
            case 168 /* ParenthesizedType */:
            case 274 /* JSDocNonNullableType */:
            case 275 /* JSDocOptionalType */:
            case 270 /* JSDocTypeExpression */:
                return getTypeFromTypeNode(node.type);
            case 160 /* FunctionType */:
            case 161 /* ConstructorType */:
            case 163 /* TypeLiteral */:
            case 288 /* JSDocTypeLiteral */:
            case 276 /* JSDocFunctionType */:
                return getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);
            case 170 /* TypeOperator */:
                return getTypeFromTypeOperatorNode(node);
            case 171 /* IndexedAccessType */:
                return getTypeFromIndexedAccessTypeNode(node);
            case 172 /* MappedType */:
                return getTypeFromMappedTypeNode(node);
            // This function assumes that an identifier or qualified name is a type expression
            // Callers should first ensure this by calling isTypeNode
            case 71 /* Identifier */:
            case 143 /* QualifiedName */:
                let symbol = getSymbolAtLocation(node);
                return symbol && getDeclaredTypeOfSymbol(symbol);
            case 277 /* JSDocVariadicType */:
                return getTypeFromJSDocVariadicType(node);
            default:
                return unknownType;
        }
    }
    function instantiateList(items, mapper, instantiator) {
        if (items && items.length) {
            let result = [];
            for (let _i = 0, items_1 = items; _i < items_1.length; _i++) {
                let v = items_1[_i];
                result.push(instantiator(v, mapper));
            }
            return result;
        }
        return items;
    }
    function instantiateTypes(types, mapper) {
        return instantiateList(types, mapper, instantiateType);
    }
    function instantiateSignatures(signatures, mapper) {
        return instantiateList(signatures, mapper, instantiateSignature);
    }
    function makeUnaryTypeMapper(source, target) {
        return function (t) { return t === source ? target : t; };
    }
    function makeBinaryTypeMapper(source1, target1, source2, target2) {
        return function (t) { return t === source1 ? target1 : t === source2 ? target2 : t; };
    }
    function makeArrayTypeMapper(sources, targets) {
        return function (t) {
            for (let i = 0; i < sources.length; i++) {
                if (t === sources[i]) {
                    return targets ? targets[i] : anyType;
                }
            }
            return t;
        };
    }
    function createTypeMapper(sources, targets) {
        ts.Debug.assert(targets === undefined || sources.length === targets.length);
        return sources.length === 1 ? makeUnaryTypeMapper(sources[0], targets ? targets[0] : anyType) :
            sources.length === 2 ? makeBinaryTypeMapper(sources[0], targets ? targets[0] : anyType, sources[1], targets ? targets[1] : anyType) :
                makeArrayTypeMapper(sources, targets);
    }
    function createTypeEraser(sources) {
        return createTypeMapper(sources, /*targets*/ undefined);
    }
    /**
     * Maps forward-references to later types parameters to the empty object type.
     * This is used during inference when instantiating type parameter defaults.
     */
    function createBackreferenceMapper(typeParameters, index) {
        return function (t) { return ts.indexOf(typeParameters, t) >= index ? emptyObjectType : t; };
    }
    function isInferenceContext(mapper) {
        return !!mapper.signature;
    }
    function cloneTypeMapper(mapper) {
        return mapper && isInferenceContext(mapper) ?
            createInferenceContext(mapper.signature, mapper.flags | 2 /* NoDefault */, mapper.compareTypes, mapper.inferences) :
            mapper;
    }
    function combineTypeMappers(mapper1, mapper2) {
        return function (t) { return instantiateType(mapper1(t), mapper2); };
    }
    function createReplacementMapper(source, target, baseMapper) {
        return function (t) { return t === source ? target : baseMapper(t); };
    }
    function cloneTypeParameter(typeParameter) {
        let result = createType(16384 /* TypeParameter */);
        result.symbol = typeParameter.symbol;
        result.target = typeParameter;
        return result;
    }
    function cloneTypePredicate(predicate, mapper) {
        if (ts.isIdentifierTypePredicate(predicate)) {
            return {
                kind: 1 /* Identifier */,
                parameterName: predicate.parameterName,
                parameterIndex: predicate.parameterIndex,
                type: instantiateType(predicate.type, mapper)
            };
        }
        else {
            return {
                kind: 0 /* This */,
                type: instantiateType(predicate.type, mapper)
            };
        }
    }
    function instantiateSignature(signature, mapper, eraseTypeParameters) {
        let freshTypeParameters;
        let freshTypePredicate;
        if (signature.typeParameters && !eraseTypeParameters) {
            // First create a fresh set of type parameters, then include a mapping from the old to the
            // new type parameters in the mapper function. Finally store this mapper in the new type
            // parameters such that we can use it when instantiating constraints.
            freshTypeParameters = ts.map(signature.typeParameters, cloneTypeParameter);
            mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper);
            for (let _i = 0, freshTypeParameters_1 = freshTypeParameters; _i < freshTypeParameters_1.length; _i++) {
                let tp = freshTypeParameters_1[_i];
                tp.mapper = mapper;
            }
        }
        if (signature.typePredicate) {
            freshTypePredicate = cloneTypePredicate(signature.typePredicate, mapper);
        }
        let result = createSignature(signature.declaration, freshTypeParameters, signature.thisParameter && instantiateSymbol(signature.thisParameter, mapper), instantiateList(signature.parameters, mapper, instantiateSymbol),
        /*resolvedReturnType*/ undefined, freshTypePredicate, signature.minArgumentCount, signature.hasRestParameter, signature.hasLiteralTypes);
        result.target = signature;
        result.mapper = mapper;
        return result;
    }
    function instantiateSymbol(symbol, mapper) {
        if (ts.getCheckFlags(symbol) & CheckFlags.Instantiated) {
            let links = getSymbolLinks(symbol);
            // If symbol being instantiated is itself a instantiation, fetch the original target and combine the
            // type mappers. This ensures that original type identities are properly preserved and that aliases
            // always reference a non-aliases.
            symbol = links.target;
            mapper = combineTypeMappers(links.mapper, mapper);
        }
        // Keep the flags from the symbol we're instantiating.  Mark that is instantiated, and
        // also transient so that we can just store data on it directly.
        let result = createSymbol(symbol.flags, symbol.escapedName);
        result.checkFlags = CheckFlags.Instantiated;
        result.declarations = symbol.declarations;
        result.parent = symbol.parent;
        result.target = symbol;
        result.mapper = mapper;
        if (symbol.valueDeclaration) {
            result.valueDeclaration = symbol.valueDeclaration;
        }
        if (symbol.isRestParameter) {
            result.isRestParameter = symbol.isRestParameter;
        }
        return result;
    }
    function getAnonymousTypeInstantiation(type, mapper) {
        let target = type.objectFlags & 64 /* Instantiated */ ? type.target : type;
        let symbol = target.symbol;
        let links = getSymbolLinks(symbol);
        let typeParameters = links.typeParameters;
        if (!typeParameters) {
            // The first time an anonymous type is instantiated we compute and store a list of the type
            // parameters that are in scope (and therefore potentially referenced). For type literals that
            // aren't the right hand side of a generic type alias declaration we optimize by reducing the
            // set of type parameters to those that are possibly referenced in the literal.
            let declaration_1 = symbol.declarations[0];
            let outerTypeParameters = getOuterTypeParameters(declaration_1, /*includeThisTypes*/ true) || ts.emptyArray;
            typeParameters = symbol.flags & 2048 /* TypeLiteral */ && !target.aliasTypeArguments ?
                ts.filter(outerTypeParameters, function (tp) { return isTypeParameterPossiblyReferenced(tp, declaration_1); }) :
                outerTypeParameters;
            links.typeParameters = typeParameters;
            if (typeParameters.length) {
                links.instantiations = ts.createMap();
                links.instantiations.set(getTypeListId(typeParameters), target);
            }
        }
        if (typeParameters.length) {
            // We are instantiating an anonymous type that has one or more type parameters in scope. Apply the
            // mapper to the type parameters to produce the effective list of type arguments, and compute the
            // instantiation cache key from the type IDs of the type arguments.
            let combinedMapper = type.objectFlags & 64 /* Instantiated */ ? combineTypeMappers(type.mapper, mapper) : mapper;
            let typeArguments = ts.map(typeParameters, combinedMapper);
            let id = getTypeListId(typeArguments);
            let result = links.instantiations.get(id);
            if (!result) {
                let newMapper = createTypeMapper(typeParameters, typeArguments);
                result = target.objectFlags & 32 /* Mapped */ ? instantiateMappedType(target, newMapper) : instantiateAnonymousType(target, newMapper);
                links.instantiations.set(id, result);
            }
            return result;
        }
        return type;
    }
    function isTypeParameterPossiblyReferenced(tp, node) {
        // If the type parameter doesn't have exactly one declaration, if there are invening statement blocks
        // between the node and the type parameter declaration, if the node contains actual references to the
        // type parameter, or if the node contains type queries, we consider the type parameter possibly referenced.
        if (tp.symbol && tp.symbol.declarations && tp.symbol.declarations.length === 1) {
            let container_1 = tp.symbol.declarations[0].parent;
            if (ts.findAncestor(node, function (n) { return n.kind === 207 /* Block */ ? "quit" : n === container_1; })) {
                return ts.forEachChild(node, containsReference);
            }
        }
        return true;
        function containsReference(node) {
            switch (node.kind) {
                case 169 /* ThisType */:
                    return tp.isThisType;
                case 71 /* Identifier */:
                    return !tp.isThisType && ts.isPartOfTypeNode(node) && getTypeFromTypeNode(node) === tp;
                case 162 /* TypeQuery */:
                    return true;
            }
            return ts.forEachChild(node, containsReference);
        }
    }
    function instantiateMappedType(type, mapper) {
        // Check if we have a homomorphic mapped type, i.e. a type of the form { [P in keyof T]: X } for some
        // type variable T. If so, the mapped type is distributive over a union type and when T is instantiated
        // to a union type A | B, we produce { [P in keyof A]: X } | { [P in keyof B]: X }. Furthermore, for
        // homomorphic mapped types we leave primitive types alone. For example, when T is instantiated to a
        // union type A | undefined, we produce { [P in keyof A]: X } | undefined.
        let constraintType = getConstraintTypeFromMappedType(type);
        if (constraintType.flags & 262144 /* Index */) {
            let typeVariable_1 = constraintType.type;
            if (typeVariable_1.flags & 16384 /* TypeParameter */) {
                let mappedTypeVariable = instantiateType(typeVariable_1, mapper);
                if (typeVariable_1 !== mappedTypeVariable) {
                    return mapType(mappedTypeVariable, function (t) {
                        if (isMappableType(t)) {
                            return instantiateAnonymousType(type, createReplacementMapper(typeVariable_1, t, mapper));
                        }
                        return t;
                    });
                }
            }
        }
        return instantiateAnonymousType(type, mapper);
    }
    function isMappableType(type) {
        return type.flags & (1 /* Any */ | 16384 /* TypeParameter */ | TypeFlags.Object | 131072 /* Intersection */ | 524288 /* IndexedAccess */);
    }
    function instantiateAnonymousType(type, mapper) {
        let result = createObjectType(type.objectFlags | 64 /* Instantiated */, type.symbol);
        if (type.objectFlags & 32 /* Mapped */) {
            result.declaration = type.declaration;
        }
        result.target = type;
        result.mapper = mapper;
        result.aliasSymbol = type.aliasSymbol;
        result.aliasTypeArguments = instantiateTypes(type.aliasTypeArguments, mapper);
        return result;
    }
    function instantiateType(type, mapper) {
        if (type && mapper !== identityMapper) {
            if (type.flags & 16384 /* TypeParameter */) {
                return mapper(type);
            }
            if (type.flags & TypeFlags.Object) {
                if (type.objectFlags & 16 /* Anonymous */) {
                    // If the anonymous type originates in a declaration of a function, method, class, or
                    // interface, in an object type literal, or in an object literal expression, we may need
                    // to instantiate the type because it might reference a type parameter.
                    return type.symbol && type.symbol.flags & (16 /* Function */ | 8192 /* Method */ | 32 /* Class */ | 2048 /* TypeLiteral */ | 4096 /* ObjectLiteral */) && type.symbol.declarations ?
                        getAnonymousTypeInstantiation(type, mapper) : type;
                }
                if (type.objectFlags & 32 /* Mapped */) {
                    return getAnonymousTypeInstantiation(type, mapper);
                }
                if (type.objectFlags & 4 /* Reference */) {
                    return createTypeReference(type.target, instantiateTypes(type.typeArguments, mapper));
                }
            }
            if (type.flags & 65536 /* Union */ && !(type.flags & 8190 /* Primitive */)) {
                return getUnionType(instantiateTypes(type.types, mapper), /*subtypeReduction*/ false, type.aliasSymbol, instantiateTypes(type.aliasTypeArguments, mapper));
            }
            if (type.flags & 131072 /* Intersection */) {
                return getIntersectionType(instantiateTypes(type.types, mapper), type.aliasSymbol, instantiateTypes(type.aliasTypeArguments, mapper));
            }
            if (type.flags & 262144 /* Index */) {
                return getIndexType(instantiateType(type.type, mapper));
            }
            if (type.flags & 524288 /* IndexedAccess */) {
                return getIndexedAccessType(instantiateType(type.objectType, mapper), instantiateType(type.indexType, mapper));
            }
        }
        return type;
    }
    function instantiateIndexInfo(info, mapper) {
        return info && createIndexInfo(instantiateType(info.type, mapper), info.isReadonly, info.declaration);
    }
    // Returns true if the given expression contains (at any level of nesting) a function or arrow expression
    // that is subject to contextual typing.
    function isContextSensitive(node) {
        ts.Debug.assert(node.kind !== SyntaxKind.MethodDeclaration || ts.isObjectLiteralMethod(node));
        switch (node.kind) {
            case 186 /* FunctionExpression */:
            case 187 /* ArrowFunction */:
            case SyntaxKind.MethodDeclaration:
                return isContextSensitiveFunctionLikeDeclaration(node);
            case 178 /* ObjectLiteralExpression */:
                return ts.forEach(node.properties, isContextSensitive);
            case 177 /* ArrayLiteralExpression */:
                return ts.forEach(node.elements, isContextSensitive);
            case 195 /* ConditionalExpression */:
                return isContextSensitive(node.whenTrue) ||
                    isContextSensitive(node.whenFalse);
            case 194 /* BinaryExpression */:
                return node.operatorToken.kind === 54 /* BarBarToken */ &&
                    (isContextSensitive(node.left) || isContextSensitive(node.right));
            case 264 /* PropertyAssignment */:
                return isContextSensitive(node.initializer);
            case 185 /* ParenthesizedExpression */:
                return isContextSensitive(node.expression);
            case 257 /* JsxAttributes */:
                return ts.forEach(node.properties, isContextSensitive);
            case 256 /* JsxAttribute */:
                // If there is no initializer, JSX attribute has a boolean value of true which is not context sensitive.
                return node.initializer && isContextSensitive(node.initializer);
            case 259 /* JsxExpression */:
                // It is possible to that node.expression is undefined (e.g <div x={} />)
                return node.expression && isContextSensitive(node.expression);
        }
        return false;
    }
    function isContextSensitiveFunctionLikeDeclaration(node) {
        // Functions with type parameters are not context sensitive.
        if (node.typeParameters) {
            return false;
        }
        // Functions with any parameters that lack type annotations are context sensitive.
        if (ts.forEach(node.parameters, function (p) { return !ts.getEffectiveTypeAnnotationNode(p); })) {
            return true;
        }
        if (node.kind !== 187 /* ArrowFunction */) {
            // If the first parameter is not an explicit 'this' parameter, then the function has
            // an implicit 'this' parameter which is subject to contextual typing.
            let parameter = ts.firstOrUndefined(node.parameters);
            if (!(parameter && ts.parameterIsThisKeyword(parameter))) {
                return true;
            }
        }
        // TODO(anhans): A block should be context-sensitive if it has a context-sensitive return value.
        return node.body.kind === 207 /* Block */ ? false : isContextSensitive(node.body);
    }
    function isContextSensitiveFunctionOrObjectLiteralMethod(func) {
        return (isFunctionExpressionOrArrowFunction(func) || ts.isObjectLiteralMethod(func)) && isContextSensitiveFunctionLikeDeclaration(func);
    }
    function getTypeWithoutSignatures(type) {
        if (type.flags & TypeFlags.Object) {
            let resolved = resolveStructuredTypeMembers(type);
            if (resolved.constructSignatures.length) {
                let result = createObjectType(16 /* Anonymous */, type.symbol);
                result.members = resolved.members;
                result.properties = resolved.properties;
                result.callSignatures = ts.emptyArray;
                result.constructSignatures = ts.emptyArray;
                return result;
            }
        }
        else if (type.flags & 131072 /* Intersection */) {
            return getIntersectionType(ts.map(type.types, getTypeWithoutSignatures));
        }
        return type;
    }
    // TYPE CHECKING
    function isTypeIdenticalTo(source, target) {
        return isTypeRelatedTo(source, target, identityRelation);
    }
    function compareTypesIdentical(source, target) {
        return isTypeRelatedTo(source, target, identityRelation) ? -1 /* True */ : 0 /* False */;
    }
    function compareTypesAssignable(source, target) {
        return isTypeRelatedTo(source, target, assignableRelation) ? -1 /* True */ : 0 /* False */;
    }
    function isTypeSubtypeOf(source, target) {
        return isTypeRelatedTo(source, target, subtypeRelation);
    }
    function isTypeAssignableTo(source, target) {
        return isTypeRelatedTo(source, target, assignableRelation);
    }
    // A type S is considered to be an instance of a type T if S and T are the same type or if S is a
    // subtype of T but not structurally identical to T. This specifically means that two distinct but
    // structurally identical types (such as two classes) are not considered instances of each other.
    function isTypeInstanceOf(source, target) {
        return getTargetType(source) === getTargetType(target) || isTypeSubtypeOf(source, target) && !isTypeIdenticalTo(source, target);
    }
    /**
     * This is *not* a bi-directional relationship.
     * If one needs to check both directions for comparability, use a second call to this function or 'checkTypeComparableTo'.
     *
     * A type S is comparable to a type T if some (but not necessarily all) of the possible values of S are also possible values of T.
     * It is used to check following cases:
     *   - the types of the left and right sides of equality/inequality operators (`===`, `!==`, `==`, `!=`).
     *   - the types of `case` clause expressions and their respective `switch` expressions.
     *   - the type of an expression in a type assertion with the type being asserted.
     */
    function isTypeComparableTo(source, target) {
        return isTypeRelatedTo(source, target, comparableRelation);
    }
    function areTypesComparable(type1, type2) {
        return isTypeComparableTo(type1, type2) || isTypeComparableTo(type2, type1);
    }
    function checkTypeAssignableTo(source, target, errorNode, headMessage, containingMessageChain) {
        return checkTypeRelatedTo(source, target, assignableRelation, errorNode, headMessage, containingMessageChain);
    }
    /**
     * This is *not* a bi-directional relationship.
     * If one needs to check both directions for comparability, use a second call to this function or 'isTypeComparableTo'.
     */
    function checkTypeComparableTo(source, target, errorNode, headMessage, containingMessageChain) {
        return checkTypeRelatedTo(source, target, comparableRelation, errorNode, headMessage, containingMessageChain);
    }
    function isSignatureAssignableTo(source, target, ignoreReturnTypes) {
        return compareSignaturesRelated(source, target, 0 /* None */, ignoreReturnTypes, /*reportErrors*/ false,
        /*errorReporter*/ undefined, compareTypesAssignable) !== 0 /* False */;
    }
    /**
     * See signatureRelatedTo, compareSignaturesIdentical
     */
    function compareSignaturesRelated(source, target, callbackCheck, ignoreReturnTypes, reportErrors, errorReporter, compareTypes) {
        // TODO (drosen): De-duplicate code between related functions.
        if (source === target) {
            return -1 /* True */;
        }
        if (!target.hasRestParameter && source.minArgumentCount > target.parameters.length) {
            return 0 /* False */;
        }
        if (source.typeParameters && source.typeParameters !== target.typeParameters) {
            target = getCanonicalSignature(target);
            source = instantiateSignatureInContextOf(source, target, /*contextualMapper*/ undefined, compareTypes);
        }
        let kind = target.declaration ? target.declaration.kind : 0 /* Unknown */;
        let strictVariance = !callbackCheck && strictFunctionTypes && kind !== SyntaxKind.MethodDeclaration &&
            kind !== 150 /* MethodSignature */ && kind !== 152 /* Constructor */;
        let result = -1 /* True */;
        let sourceThisType = getThisTypeOfSignature(source);
        if (sourceThisType && sourceThisType !== voidType) {
            let targetThisType = getThisTypeOfSignature(target);
            if (targetThisType) {
                // void sources are assignable to anything.
                let related = !strictVariance && compareTypes(sourceThisType, targetThisType, /*reportErrors*/ false)
                    || compareTypes(targetThisType, sourceThisType, reportErrors);
                if (!related) {
                    if (reportErrors) {
                        errorReporter(ts.Diagnostics.The_this_types_of_each_signature_are_incompatible);
                    }
                    return 0 /* False */;
                }
                result &= related;
            }
        }
        let sourceMax = getNumNonRestParameters(source);
        let targetMax = getNumNonRestParameters(target);
        let checkCount = getNumParametersToCheckForSignatureRelatability(source, sourceMax, target, targetMax);
        let sourceParams = source.parameters;
        let targetParams = target.parameters;
        for (let i = 0; i < checkCount; i++) {
            let sourceType = i < sourceMax ? getTypeOfParameter(sourceParams[i]) : getRestTypeOfSignature(source);
            let targetType = i < targetMax ? getTypeOfParameter(targetParams[i]) : getRestTypeOfSignature(target);
            // In order to ensure that any generic type Foo<T> is at least co-variant with respect to T no matter
            // how Foo uses T, we need to relate parameters bi-variantly (given that parameters are input positions,
            // they naturally relate only contra-variantly). However, if the source and target parameters both have
            // function types with a single call signature, we know we are relating two callback parameters. In
            // that case it is sufficient to only relate the parameters of the signatures co-variantly because,
            // similar to return values, callback parameters are output positions. This means that a Promise<T>,
            // where T is used only in callback parameter positions, will be co-variant (as opposed to bi-variant)
            // with respect to T.
            let sourceSig = callbackCheck ? undefined : getSingleCallSignature(getNonNullableType(sourceType));
            let targetSig = callbackCheck ? undefined : getSingleCallSignature(getNonNullableType(targetType));
            let callbacks = sourceSig && targetSig && !sourceSig.typePredicate && !targetSig.typePredicate &&
                (getFalsyFlags(sourceType) & 6144 /* Nullable */) === (getFalsyFlags(targetType) & 6144 /* Nullable */);
            let related = callbacks ?
                compareSignaturesRelated(targetSig, sourceSig, strictVariance ? 2 /* Strict */ : 1 /* Bivariant */, /*ignoreReturnTypes*/ false, reportErrors, errorReporter, compareTypes) :
                !callbackCheck && !strictVariance && compareTypes(sourceType, targetType, /*reportErrors*/ false) || compareTypes(targetType, sourceType, reportErrors);
            if (!related) {
                if (reportErrors) {
                    errorReporter(ts.Diagnostics.Types_of_parameters_0_and_1_are_incompatible, ts.symbolName(sourceParams[i < sourceMax ? i : sourceMax]), ts.symbolName(targetParams[i < targetMax ? i : targetMax]));
                }
                return 0 /* False */;
            }
            result &= related;
        }
        if (!ignoreReturnTypes) {
            let targetReturnType = getReturnTypeOfSignature(target);
            if (targetReturnType === voidType) {
                return result;
            }
            let sourceReturnType = getReturnTypeOfSignature(source);
            // The following block preserves behavior forbidding boolean returning functions from being assignable to type guard returning functions
            if (target.typePredicate) {
                if (source.typePredicate) {
                    result &= compareTypePredicateRelatedTo(source.typePredicate, target.typePredicate, source.declaration, target.declaration, reportErrors, errorReporter, compareTypes);
                }
                else if (ts.isIdentifierTypePredicate(target.typePredicate)) {
                    if (reportErrors) {
                        errorReporter(ts.Diagnostics.Signature_0_must_be_a_type_predicate, signatureToString(source));
                    }
                    return 0 /* False */;
                }
            }
            else {
                // When relating callback signatures, we still need to relate return types bi-variantly as otherwise
                // the containing type wouldn't be co-variant. For example, interface Foo<T> { add(cb: () => T): void }
                // wouldn't be co-variant for T without this rule.
                result &= callbackCheck === 1 /* Bivariant */ && compareTypes(targetReturnType, sourceReturnType, /*reportErrors*/ false) ||
                    compareTypes(sourceReturnType, targetReturnType, reportErrors);
            }
        }
        return result;
    }
    function compareTypePredicateRelatedTo(source, target, sourceDeclaration, targetDeclaration, reportErrors, errorReporter, compareTypes) {
        if (source.kind !== target.kind) {
            if (reportErrors) {
                errorReporter(ts.Diagnostics.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard);
                errorReporter(ts.Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
            }
            return 0 /* False */;
        }
        if (source.kind === 1 /* Identifier */) {
            let sourcePredicate = source;
            let targetPredicate = target;
            let sourceIndex = sourcePredicate.parameterIndex - (ts.getThisParameter(sourceDeclaration) ? 1 : 0);
            let targetIndex = targetPredicate.parameterIndex - (ts.getThisParameter(targetDeclaration) ? 1 : 0);
            if (sourceIndex !== targetIndex) {
                if (reportErrors) {
                    errorReporter(ts.Diagnostics.Parameter_0_is_not_in_the_same_position_as_parameter_1, sourcePredicate.parameterName, targetPredicate.parameterName);
                    errorReporter(ts.Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
                }
                return 0 /* False */;
            }
        }
        let related = compareTypes(source.type, target.type, reportErrors);
        if (related === 0 /* False */ && reportErrors) {
            errorReporter(ts.Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
        }
        return related;
    }
    function isImplementationCompatibleWithOverload(implementation, overload) {
        let erasedSource = getErasedSignature(implementation);
        let erasedTarget = getErasedSignature(overload);
        // First see if the return types are compatible in either direction.
        let sourceReturnType = getReturnTypeOfSignature(erasedSource);
        let targetReturnType = getReturnTypeOfSignature(erasedTarget);
        if (targetReturnType === voidType
            || isTypeRelatedTo(targetReturnType, sourceReturnType, assignableRelation)
            || isTypeRelatedTo(sourceReturnType, targetReturnType, assignableRelation)) {
            return isSignatureAssignableTo(erasedSource, erasedTarget, /*ignoreReturnTypes*/ true);
        }
        return false;
    }
    function getNumNonRestParameters(signature) {
        let numParams = signature.parameters.length;
        return signature.hasRestParameter ?
            numParams - 1 :
            numParams;
    }
    function getNumParametersToCheckForSignatureRelatability(source, sourceNonRestParamCount, target, targetNonRestParamCount) {
        if (source.hasRestParameter === target.hasRestParameter) {
            if (source.hasRestParameter) {
                // If both have rest parameters, get the max and add 1 to
                // compensate for the rest parameter.
                return Math.max(sourceNonRestParamCount, targetNonRestParamCount) + 1;
            }
            else {
                return Math.min(sourceNonRestParamCount, targetNonRestParamCount);
            }
        }
        else {
            // Return the count for whichever signature doesn't have rest parameters.
            return source.hasRestParameter ?
                targetNonRestParamCount :
                sourceNonRestParamCount;
        }
    }
    function isEmptyResolvedType(t) {
        return t.properties.length === 0 &&
            t.callSignatures.length === 0 &&
            t.constructSignatures.length === 0 &&
            !t.stringIndexInfo &&
            !t.numberIndexInfo;
    }
    function isEmptyObjectType(type) {
        return type.flags & TypeFlags.Object ? isEmptyResolvedType(resolveStructuredTypeMembers(type)) :
            type.flags & 16777216 /* NonPrimitive */ ? true :
                type.flags & 65536 /* Union */ ? ts.forEach(type.types, isEmptyObjectType) :
                    type.flags & 131072 /* Intersection */ ? !ts.forEach(type.types, function (t) { return !isEmptyObjectType(t); }) :
                        false;
    }
    function isEnumTypeRelatedTo(sourceSymbol, targetSymbol, errorReporter) {
        if (sourceSymbol === targetSymbol) {
            return true;
        }
        let id = getSymbolId(sourceSymbol) + "," + getSymbolId(targetSymbol);
        let relation = enumRelation.get(id);
        if (relation !== undefined) {
            return relation;
        }
        if (sourceSymbol.escapedName !== targetSymbol.escapedName || !(sourceSymbol.flags & 256 /* RegularEnum */) || !(targetSymbol.flags & 256 /* RegularEnum */)) {
            enumRelation.set(id, false);
            return false;
        }
        let targetEnumType = getTypeOfSymbol(targetSymbol);
        for (let _i = 0, _a = getPropertiesOfType(getTypeOfSymbol(sourceSymbol)); _i < _a.length; _i++) {
            let property = _a[_i];
            if (property.flags & 8 /* EnumMember */) {
                let targetProperty = getPropertyOfType(targetEnumType, property.escapedName);
                if (!targetProperty || !(targetProperty.flags & 8 /* EnumMember */)) {
                    if (errorReporter) {
                        errorReporter(ts.Diagnostics.Property_0_is_missing_in_type_1, ts.symbolName(property), typeToString(getDeclaredTypeOfSymbol(targetSymbol), /*enclosingDeclaration*/ undefined, 256 /* UseFullyQualifiedType */));
                    }
                    enumRelation.set(id, false);
                    return false;
                }
            }
        }
        enumRelation.set(id, true);
        return true;
    }
    function isSimpleTypeRelatedTo(source, target, relation, errorReporter) {
        let s = source.flags;
        let t = target.flags;
        if (t & 8192 /* Never */)
            return false;
        if (t & 1 /* Any */ || s & 8192 /* Never */)
            return true;
        if (s & 262178 /* StringLike */ && t & 2 /* String */)
            return true;
        if (s & 32 /* StringLiteral */ && s & 256 /* EnumLiteral */ &&
            t & 32 /* StringLiteral */ && !(t & 256 /* EnumLiteral */) &&
            source.value === target.value)
            return true;
        if (s & 84 /* NumberLike */ && t & 4 /* Number */)
            return true;
        if (s & 64 /* NumberLiteral */ && s & 256 /* EnumLiteral */ &&
            t & 64 /* NumberLiteral */ && !(t & 256 /* EnumLiteral */) &&
            source.value === target.value)
            return true;
        if (s & 136 /* BooleanLike */ && t & 8 /* Boolean */)
            return true;
        if (s & 16 /* Enum */ && t & 16 /* Enum */ && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter))
            return true;
        if (s & 256 /* EnumLiteral */ && t & 256 /* EnumLiteral */) {
            if (s & 65536 /* Union */ && t & 65536 /* Union */ && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter))
                return true;
            if (s & 224 /* Literal */ && t & 224 /* Literal */ &&
                source.value === target.value &&
                isEnumTypeRelatedTo(getParentOfSymbol(source.symbol), getParentOfSymbol(target.symbol), errorReporter))
                return true;
        }
        if (s & 2048 /* Undefined */ && (!strictNullChecks || t & (2048 /* Undefined */ | 1024 /* Void */)))
            return true;
        if (s & 4096 /* Null */ && (!strictNullChecks || t & 4096 /* Null */))
            return true;
        if (s & TypeFlags.Object && t & 16777216 /* NonPrimitive */)
            return true;
        if (relation === assignableRelation || relation === comparableRelation) {
            if (s & 1 /* Any */)
                return true;
            // Type number or any numeric literal type is assignable to any numeric enum type or any
            // numeric enum literal type. This rule exists for backwards compatibility reasons because
            // bit-flag enum types sometimes look like literal enum types with numeric literal values.
            if (s & (4 /* Number */ | 64 /* NumberLiteral */) && !(s & 256 /* EnumLiteral */) && (t & 16 /* Enum */ || t & 64 /* NumberLiteral */ && t & 256 /* EnumLiteral */))
                return true;
        }
        return false;
    }
    function isTypeRelatedTo(source, target, relation) {
        if (source.flags & 96 /* StringOrNumberLiteral */ && source.flags & 1048576 /* FreshLiteral */) {
            source = source.regularType;
        }
        if (target.flags & 96 /* StringOrNumberLiteral */ && target.flags & 1048576 /* FreshLiteral */) {
            target = target.regularType;
        }
        if (source === target || relation !== identityRelation && isSimpleTypeRelatedTo(source, target, relation)) {
            return true;
        }
        if (source.flags & TypeFlags.Object && target.flags & TypeFlags.Object) {
            let related = relation.get(getRelationKey(source, target, relation));
            if (related !== undefined) {
                return related === 1 /* Succeeded */;
            }
        }
        if (source.flags & 1032192 /* StructuredOrTypeVariable */ || target.flags & 1032192 /* StructuredOrTypeVariable */) {
            return checkTypeRelatedTo(source, target, relation, /*errorNode*/ undefined);
        }
        return false;
    }
    /**
     * Checks if 'source' is related to 'target' (e.g.: is a assignable to).
     * @param source The left-hand-side of the relation.
     * @param target The right-hand-side of the relation.
     * @param relation The relation considered. One of 'identityRelation', 'subtypeRelation', 'assignableRelation', or 'comparableRelation'.
     * Used as both to determine which checks are performed and as a cache of previously computed results.
     * @param errorNode The suggested node upon which all errors will be reported, if defined. This may or may not be the actual node used.
     * @param headMessage If the error chain should be prepended by a head message, then headMessage will be used.
     * @param containingMessageChain A chain of errors to prepend any new errors found.
     */
    function checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain) {
        let errorInfo;
        let maybeKeys;
        let sourceStack;
        let targetStack;
        let maybeCount = 0;
        let depth = 0;
        let ExpandingFlags;
        (function (ExpandingFlags) {
            ExpandingFlags[ExpandingFlags["None"] = 0] = "None";
            ExpandingFlags[ExpandingFlags["Source"] = 1] = "Source";
            ExpandingFlags[ExpandingFlags["Target"] = 2] = "Target";
            ExpandingFlags[ExpandingFlags["Both"] = 3] = "Both";
        })(ExpandingFlags || (ExpandingFlags = {}));
        let expandingFlags = 0 /* None */;
        let overflow = false;
        let isIntersectionConstituent = false;
        ts.Debug.assert(relation !== identityRelation || !errorNode, "no error reporting in identity checking");
        let result = isRelatedTo(source, target, /*reportErrors*/ !!errorNode, headMessage);
        if (overflow) {
            error(errorNode, ts.Diagnostics.Excessive_stack_depth_comparing_types_0_and_1, typeToString(source), typeToString(target));
        }
        else if (errorInfo) {
            if (containingMessageChain) {
                errorInfo = ts.concatenateDiagnosticMessageChains(containingMessageChain, errorInfo);
            }
            diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(errorNode, errorInfo));
        }
        return result !== 0 /* False */;
        function reportError(message, arg0, arg1, arg2) {
            ts.Debug.assert(!!errorNode);
            errorInfo = ts.chainDiagnosticMessages(errorInfo, message, arg0, arg1, arg2);
        }
        function reportRelationError(message, source, target) {
            let sourceType = typeToString(source);
            let targetType = typeToString(target);
            if (sourceType === targetType) {
                sourceType = typeToString(source, /*enclosingDeclaration*/ undefined, 256 /* UseFullyQualifiedType */);
                targetType = typeToString(target, /*enclosingDeclaration*/ undefined, 256 /* UseFullyQualifiedType */);
            }
            if (!message) {
                if (relation === comparableRelation) {
                    message = ts.Diagnostics.Type_0_is_not_comparable_to_type_1;
                }
                else if (sourceType === targetType) {
                    message = ts.Diagnostics.Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated;
                }
                else {
                    message = ts.Diagnostics.Type_0_is_not_assignable_to_type_1;
                }
            }
            reportError(message, sourceType, targetType);
        }
        function tryElaborateErrorsForPrimitivesAndObjects(source, target) {
            let sourceType = typeToString(source);
            let targetType = typeToString(target);
            if ((globalStringType === source && stringType === target) ||
                (globalNumberType === source && numberType === target) ||
                (globalBooleanType === source && booleanType === target) ||
                (getGlobalESSymbolType(/*reportErrors*/ false) === source && esSymbolType === target)) {
                reportError(ts.Diagnostics._0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible, targetType, sourceType);
            }
        }
        function isUnionOrIntersectionTypeWithoutNullableConstituents(type) {
            if (!(type.flags & 196608 /* UnionOrIntersection */)) {
                return false;
            }
            // at this point we know that this is union or intersection type possibly with nullable constituents.
            // check if we still will have compound type if we ignore nullable components.
            let seenNonNullable = false;
            for (let _i = 0, _a = type.types; _i < _a.length; _i++) {
                let t = _a[_i];
                if (t.flags & 6144 /* Nullable */) {
                    continue;
                }
                if (seenNonNullable) {
                    return true;
                }
                seenNonNullable = true;
            }
            return false;
        }
        /**
         * Compare two types and return
         * * Ternary.True if they are related with no assumptions,
         * * Ternary.Maybe if they are related with assumptions of other relationships, or
         * * Ternary.False if they are not related.
         */
        function isRelatedTo(source, target, reportErrors, headMessage) {
            if (source.flags & 96 /* StringOrNumberLiteral */ && source.flags & 1048576 /* FreshLiteral */) {
                source = source.regularType;
            }
            if (target.flags & 96 /* StringOrNumberLiteral */ && target.flags & 1048576 /* FreshLiteral */) {
                target = target.regularType;
            }
            // both types are the same - covers 'they are the same primitive type or both are Any' or the same type parameter cases
            if (source === target)
                return -1 /* True */;
            if (relation === identityRelation) {
                return isIdenticalTo(source, target);
            }
            if (isSimpleTypeRelatedTo(source, target, relation, reportErrors ? reportError : undefined))
                return -1 /* True */;
            if (getObjectFlags(source) & 128 /* ObjectLiteral */ && source.flags & 1048576 /* FreshLiteral */) {
                if (hasExcessProperties(source, target, reportErrors)) {
                    if (reportErrors) {
                        reportRelationError(headMessage, source, target);
                    }
                    return 0 /* False */;
                }
                // Above we check for excess properties with respect to the entire target type. When union
                // and intersection types are further deconstructed on the target side, we don't want to
                // make the check again (as it might fail for a partial target type). Therefore we obtain
                // the regular source type and proceed with that.
                if (isUnionOrIntersectionTypeWithoutNullableConstituents(target)) {
                    source = getRegularTypeOfObjectLiteral(source);
                }
            }
            if (relation !== comparableRelation &&
                !(source.flags & 196608 /* UnionOrIntersection */) &&
                !(target.flags & 65536 /* Union */) &&
                !isIntersectionConstituent &&
                source !== globalObjectType &&
                (getPropertiesOfType(source).length > 0 ||
                    getSignaturesOfType(source, 0 /* Call */).length > 0 ||
                    getSignaturesOfType(source, 1 /* Construct */).length > 0) &&
                isWeakType(target) &&
                !hasCommonProperties(source, target)) {
                if (reportErrors) {
                    let calls = getSignaturesOfType(source, 0 /* Call */);
                    let constructs = getSignaturesOfType(source, 1 /* Construct */);
                    if (calls.length > 0 && isRelatedTo(getReturnTypeOfSignature(calls[0]), target, /*reportErrors*/ false) ||
                        constructs.length > 0 && isRelatedTo(getReturnTypeOfSignature(constructs[0]), target, /*reportErrors*/ false)) {
                        reportError(ts.Diagnostics.Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it, typeToString(source), typeToString(target));
                    }
                    else {
                        reportError(ts.Diagnostics.Type_0_has_no_properties_in_common_with_type_1, typeToString(source), typeToString(target));
                    }
                }
                return 0 /* False */;
            }
            let result = 0 /* False */;
            let saveErrorInfo = errorInfo;
            let saveIsIntersectionConstituent = isIntersectionConstituent;
            isIntersectionConstituent = false;
            // Note that these checks are specifically ordered to produce correct results. In particular,
            // we need to deconstruct unions before intersections (because unions are always at the top),
            // and we need to handle "each" relations before "some" relations for the same kind of type.
            if (source.flags & 65536 /* Union */) {
                result = relation === comparableRelation ?
                    someTypeRelatedToType(source, target, reportErrors && !(source.flags & 8190 /* Primitive */)) :
                    eachTypeRelatedToType(source, target, reportErrors && !(source.flags & 8190 /* Primitive */));
            }
            else {
                if (target.flags & 65536 /* Union */) {
                    result = typeRelatedToSomeType(source, target, reportErrors && !(source.flags & 8190 /* Primitive */) && !(target.flags & 8190 /* Primitive */));
                }
                else if (target.flags & 131072 /* Intersection */) {
                    isIntersectionConstituent = true;
                    result = typeRelatedToEachType(source, target, reportErrors);
                }
                else if (source.flags & 131072 /* Intersection */) {
                    // Check to see if any constituents of the intersection are immediately related to the target.
                    //
                    // Don't report errors though. Checking whether a constituent is related to the source is not actually
                    // useful and leads to some confusing error messages. Instead it is better to let the below checks
                    // take care of this, or to not elaborate at all. For instance,
                    //
                    //    - For an object type (such as 'C = A & B'), users are usually more interested in structural errors.
                    //
                    //    - For a union type (such as '(A | B) = (C & D)'), it's better to hold onto the whole intersection
                    //          than to report that 'D' is not assignable to 'A' or 'B'.
                    //
                    //    - For a primitive type or type parameter (such as 'number = A & B') there is no point in
                    //          breaking the intersection apart.
                    result = someTypeRelatedToType(source, target, /*reportErrors*/ false);
                }
                if (!result && (source.flags & 1032192 /* StructuredOrTypeVariable */ || target.flags & 1032192 /* StructuredOrTypeVariable */)) {
                    if (result = recursiveTypeRelatedTo(source, target, reportErrors)) {
                        errorInfo = saveErrorInfo;
                    }
                }
            }
            isIntersectionConstituent = saveIsIntersectionConstituent;
            if (!result && reportErrors) {
                if (source.flags & TypeFlags.Object && target.flags & 8190 /* Primitive */) {
                    tryElaborateErrorsForPrimitivesAndObjects(source, target);
                }
                else if (source.symbol && source.flags & TypeFlags.Object && globalObjectType === source) {
                    reportError(ts.Diagnostics.The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead);
                }
                reportRelationError(headMessage, source, target);
            }
            return result;
        }
        function isIdenticalTo(source, target) {
            let result;
            if (source.flags & TypeFlags.Object && target.flags & TypeFlags.Object) {
                return recursiveTypeRelatedTo(source, target, /*reportErrors*/ false);
            }
            if (source.flags & 65536 /* Union */ && target.flags & 65536 /* Union */ ||
                source.flags & 131072 /* Intersection */ && target.flags & 131072 /* Intersection */) {
                if (result = eachTypeRelatedToSomeType(source, target)) {
                    if (result &= eachTypeRelatedToSomeType(target, source)) {
                        return result;
                    }
                }
            }
            return 0 /* False */;
        }
        function hasExcessProperties(source, target, reportErrors) {
            if (maybeTypeOfKind(target, TypeFlags.Object) && !(getObjectFlags(target) & 512 /* ObjectLiteralPatternWithComputedProperties */)) {
                let isComparingJsxAttributes = !!(source.flags & 33554432 /* JsxAttributes */);
                if ((relation === assignableRelation || relation === comparableRelation) &&
                    (isTypeSubsetOf(globalObjectType, target) || (!isComparingJsxAttributes && isEmptyObjectType(target)))) {
                    return false;
                }
                if (target.flags & 65536 /* Union */) {
                    let discriminantType = findMatchingDiscriminantType(source, target);
                    if (discriminantType) {
                        // check excess properties against discriminant type only, not the entire union
                        return hasExcessProperties(source, discriminantType, reportErrors);
                    }
                }
                let _loop_4 = function (prop) {
                    if (!isKnownProperty(target, prop.escapedName, isComparingJsxAttributes)) {
                        if (reportErrors) {
                            // We know *exactly* where things went wrong when comparing the types.
                            // Use this property as the error node as this will be more helpful in
                            // reasoning about what went wrong.
                            ts.Debug.assert(!!errorNode);
                            if (ts.isJsxAttributes(errorNode) || ts.isJsxOpeningLikeElement(errorNode)) {
                                // JsxAttributes has an object-literal flag and undergo same type-assignablity check as normal object-literal.
                                // However, using an object-literal error message will be very confusing to the users so we give different a message.
                                reportError(ts.Diagnostics.Property_0_does_not_exist_on_type_1, symbolToString(prop), typeToString(target));
                            }
                            else {
                                // use the property's value declaration if the property is assigned inside the literal itself
                                let objectLiteralDeclaration_1 = source.symbol && ts.firstOrUndefined(source.symbol.declarations);
                                let suggestion = void 0;
                                if (prop.valueDeclaration && ts.findAncestor(prop.valueDeclaration, function (d) { return d === objectLiteralDeclaration_1; })) {
                                    let propDeclaration = prop.valueDeclaration;
                                    ts.Debug.assertNode(propDeclaration, ts.isObjectLiteralElementLike);
                                    errorNode = propDeclaration;
                                    if (ts.isIdentifier(propDeclaration.name)) {
                                        suggestion = getSuggestionForNonexistentProperty(propDeclaration.name, target);
                                    }
                                }
                                if (suggestion !== undefined) {
                                    reportError(ts.Diagnostics.Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2, symbolToString(prop), typeToString(target), suggestion);
                                }
                                else {
                                    reportError(ts.Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(prop), typeToString(target));
                                }
                            }
                        }
                        return { value: true };
                    }
                };
                for (let _i = 0, _a = getPropertiesOfObjectType(source); _i < _a.length; _i++) {
                    let prop = _a[_i];
                    let state_2 = _loop_4(prop);
                    if (typeof state_2 === "object")
                        return state_2.value;
                }
            }
            return false;
        }
        function eachTypeRelatedToSomeType(source, target) {
            let result = -1 /* True */;
            let sourceTypes = source.types;
            for (let _i = 0, sourceTypes_1 = sourceTypes; _i < sourceTypes_1.length; _i++) {
                let sourceType = sourceTypes_1[_i];
                let related = typeRelatedToSomeType(sourceType, target, /*reportErrors*/ false);
                if (!related) {
                    return 0 /* False */;
                }
                result &= related;
            }
            return result;
        }
        function typeRelatedToSomeType(source, target, reportErrors) {
            let targetTypes = target.types;
            if (target.flags & 65536 /* Union */ && containsType(targetTypes, source)) {
                return -1 /* True */;
            }
            for (let _i = 0, targetTypes_1 = targetTypes; _i < targetTypes_1.length; _i++) {
                let type = targetTypes_1[_i];
                let related = isRelatedTo(source, type, /*reportErrors*/ false);
                if (related) {
                    return related;
                }
            }
            if (reportErrors) {
                let discriminantType = findMatchingDiscriminantType(source, target);
                isRelatedTo(source, discriminantType || targetTypes[targetTypes.length - 1], /*reportErrors*/ true);
            }
            return 0 /* False */;
        }
        function findMatchingDiscriminantType(source, target) {
            let match;
            let sourceProperties = getPropertiesOfObjectType(source);
            if (sourceProperties) {
                let sourceProperty = findSingleDiscriminantProperty(sourceProperties, target);
                if (sourceProperty) {
                    let sourceType = getTypeOfSymbol(sourceProperty);
                    for (let _i = 0, _a = target.types; _i < _a.length; _i++) {
                        let type = _a[_i];
                        let targetType = getTypeOfPropertyOfType(type, sourceProperty.escapedName);
                        if (targetType && isRelatedTo(sourceType, targetType)) {
                            if (match) {
                                return undefined;
                            }
                            match = type;
                        }
                    }
                }
            }
            return match;
        }
        function typeRelatedToEachType(source, target, reportErrors) {
            let result = -1 /* True */;
            let targetTypes = target.types;
            for (let _i = 0, targetTypes_2 = targetTypes; _i < targetTypes_2.length; _i++) {
                let targetType = targetTypes_2[_i];
                let related = isRelatedTo(source, targetType, reportErrors);
                if (!related) {
                    return 0 /* False */;
                }
                result &= related;
            }
            return result;
        }
        function someTypeRelatedToType(source, target, reportErrors) {
            let sourceTypes = source.types;
            if (source.flags & 65536 /* Union */ && containsType(sourceTypes, target)) {
                return -1 /* True */;
            }
            let len = sourceTypes.length;
            for (let i = 0; i < len; i++) {
                let related = isRelatedTo(sourceTypes[i], target, reportErrors && i === len - 1);
                if (related) {
                    return related;
                }
            }
            return 0 /* False */;
        }
        function eachTypeRelatedToType(source, target, reportErrors) {
            let result = -1 /* True */;
            let sourceTypes = source.types;
            for (let _i = 0, sourceTypes_2 = sourceTypes; _i < sourceTypes_2.length; _i++) {
                let sourceType = sourceTypes_2[_i];
                let related = isRelatedTo(sourceType, target, reportErrors);
                if (!related) {
                    return 0 /* False */;
                }
                result &= related;
            }
            return result;
        }
        function typeArgumentsRelatedTo(source, target, variances, reportErrors) {
            let sources = source.typeArguments || ts.emptyArray;
            let targets = target.typeArguments || ts.emptyArray;
            if (sources.length !== targets.length && relation === identityRelation) {
                return 0 /* False */;
            }
            let length = sources.length <= targets.length ? sources.length : targets.length;
            let result = -1 /* True */;
            for (let i = 0; i < length; i++) {
                // When variance information isn't available we default to covariance. This happens
                // in the process of computing variance information for recursive types and when
                // comparing 'this' type arguments.
                let variance = i < variances.length ? variances[i] : 1 /* Covariant */;
                // We ignore arguments for independent type parameters (because they're never witnessed).
                if (variance !== 4 /* Independent */) {
                    let s = sources[i];
                    let t = targets[i];
                    let related = -1 /* True */;
                    if (variance === 1 /* Covariant */) {
                        related = isRelatedTo(s, t, reportErrors);
                    }
                    else if (variance === 2 /* Contravariant */) {
                        related = isRelatedTo(t, s, reportErrors);
                    }
                    else if (variance === 3 /* Bivariant */) {
                        // In the bivariant case we first compare contravariantly without reporting
                        // errors. Then, if that doesn't succeed, we compare covariantly with error
                        // reporting. Thus, error elaboration will be based on the the covariant check,
                        // which is generally easier to reason about.
                        related = isRelatedTo(t, s, /*reportErrors*/ false);
                        if (!related) {
                            related = isRelatedTo(s, t, reportErrors);
                        }
                    }
                    else {
                        // In the invariant case we first compare covariantly, and only when that
                        // succeeds do we proceed to compare contravariantly. Thus, error elaboration
                        // will typically be based on the covariant check.
                        related = isRelatedTo(s, t, reportErrors);
                        if (related) {
                            related &= isRelatedTo(t, s, reportErrors);
                        }
                    }
                    if (!related) {
                        return 0 /* False */;
                    }
                    result &= related;
                }
            }
            return result;
        }
        // Determine if possibly recursive types are related. First, check if the result is already available in the global cache.
        // Second, check if we have already started a comparison of the given two types in which case we assume the result to be true.
        // Third, check if both types are part of deeply nested chains of generic type instantiations and if so assume the types are
        // equal and infinitely expanding. Fourth, if we have reached a depth of 100 nested comparisons, assume we have runaway recursion
        // and issue an error. Otherwise, actually compare the structure of the two types.
        function recursiveTypeRelatedTo(source, target, reportErrors) {
            if (overflow) {
                return 0 /* False */;
            }
            let id = getRelationKey(source, target, relation);
            let related = relation.get(id);
            if (related !== undefined) {
                if (reportErrors && related === 2 /* Failed */) {
                    // We are elaborating errors and the cached result is an unreported failure. Record the result as a reported
                    // failure and continue computing the relation such that errors get reported.
                    relation.set(id, 3 /* FailedAndReported */);
                }
                else {
                    return related === 1 /* Succeeded */ ? -1 /* True */ : 0 /* False */;
                }
            }
            if (!maybeKeys) {
                maybeKeys = [];
                sourceStack = [];
                targetStack = [];
            }
            else {
                for (let i = 0; i < maybeCount; i++) {
                    // If source and target are already being compared, consider them related with assumptions
                    if (id === maybeKeys[i]) {
                        return 1 /* Maybe */;
                    }
                }
                if (depth === 100) {
                    overflow = true;
                    return 0 /* False */;
                }
            }
            let maybeStart = maybeCount;
            maybeKeys[maybeCount] = id;
            maybeCount++;
            sourceStack[depth] = source;
            targetStack[depth] = target;
            depth++;
            let saveExpandingFlags = expandingFlags;
            if (!(expandingFlags & 1 /* Source */) && isDeeplyNestedType(source, sourceStack, depth))
                expandingFlags |= 1 /* Source */;
            if (!(expandingFlags & 2 /* Target */) && isDeeplyNestedType(target, targetStack, depth))
                expandingFlags |= 2 /* Target */;
            let result = expandingFlags !== 3 /* Both */ ? structuredTypeRelatedTo(source, target, reportErrors) : 1 /* Maybe */;
            expandingFlags = saveExpandingFlags;
            depth--;
            if (result) {
                if (result === -1 /* True */ || depth === 0) {
                    // If result is definitely true, record all maybe keys as having succeeded
                    for (let i = maybeStart; i < maybeCount; i++) {
                        relation.set(maybeKeys[i], 1 /* Succeeded */);
                    }
                    maybeCount = maybeStart;
                }
            }
            else {
                // A false result goes straight into global cache (when something is false under
                // assumptions it will also be false without assumptions)
                relation.set(id, reportErrors ? 3 /* FailedAndReported */ : 2 /* Failed */);
                maybeCount = maybeStart;
            }
            return result;
        }
        function structuredTypeRelatedTo(source, target, reportErrors) {
            let result;
            let saveErrorInfo = errorInfo;
            if (target.flags & 16384 /* TypeParameter */) {
                // A source type { [P in keyof T]: X } is related to a target type T if X is related to T[P].
                if (getObjectFlags(source) & 32 /* Mapped */ && getConstraintTypeFromMappedType(source) === getIndexType(target)) {
                    if (!source.declaration.questionToken) {
                        let templateType = getTemplateTypeFromMappedType(source);
                        let indexedAccessType = getIndexedAccessType(target, getTypeParameterFromMappedType(source));
                        if (result = isRelatedTo(templateType, indexedAccessType, reportErrors)) {
                            return result;
                        }
                    }
                }
            }
            else if (target.flags & 262144 /* Index */) {
                // A keyof S is related to a keyof T if T is related to S.
                if (source.flags & 262144 /* Index */) {
                    if (result = isRelatedTo(target.type, source.type, /*reportErrors*/ false)) {
                        return result;
                    }
                }
                // A type S is assignable to keyof T if S is assignable to keyof C, where C is the
                // constraint of T.
                let constraint = getConstraintOfType(target.type);
                if (constraint) {
                    if (result = isRelatedTo(source, getIndexType(constraint), reportErrors)) {
                        return result;
                    }
                }
            }
            else if (target.flags & 524288 /* IndexedAccess */) {
                // A type S is related to a type T[K] if S is related to A[K], where K is string-like and
                // A is the apparent type of S.
                let constraint = getConstraintOfIndexedAccess(target);
                if (constraint) {
                    if (result = isRelatedTo(source, constraint, reportErrors)) {
                        errorInfo = saveErrorInfo;
                        return result;
                    }
                }
            }
            if (source.flags & 16384 /* TypeParameter */) {
                // A source type T is related to a target type { [P in keyof T]: X } if T[P] is related to X.
                if (getObjectFlags(target) & 32 /* Mapped */ && getConstraintTypeFromMappedType(target) === getIndexType(source)) {
                    let indexedAccessType = getIndexedAccessType(source, getTypeParameterFromMappedType(target));
                    let templateType = getTemplateTypeFromMappedType(target);
                    if (result = isRelatedTo(indexedAccessType, templateType, reportErrors)) {
                        errorInfo = saveErrorInfo;
                        return result;
                    }
                }
                else {
                    let constraint = getConstraintOfTypeParameter(source);
                    // A type parameter with no constraint is not related to the non-primitive object type.
                    if (constraint || !(target.flags & 16777216 /* NonPrimitive */)) {
                        if (!constraint || constraint.flags & 1 /* Any */) {
                            constraint = emptyObjectType;
                        }
                        // Report constraint errors only if the constraint is not the empty object type
                        let reportConstraintErrors = reportErrors && constraint !== emptyObjectType;
                        if (result = isRelatedTo(constraint, target, reportConstraintErrors)) {
                            errorInfo = saveErrorInfo;
                            return result;
                        }
                    }
                }
            }
            else if (source.flags & 524288 /* IndexedAccess */) {
                // A type S[K] is related to a type T if A[K] is related to T, where K is string-like and
                // A is the apparent type of S.
                let constraint = getConstraintOfIndexedAccess(source);
                if (constraint) {
                    if (result = isRelatedTo(constraint, target, reportErrors)) {
                        errorInfo = saveErrorInfo;
                        return result;
                    }
                }
                else if (target.flags & 524288 /* IndexedAccess */ && source.indexType === target.indexType) {
                    // if we have indexed access types with identical index types, see if relationship holds for
                    // the two object types.
                    if (result = isRelatedTo(source.objectType, target.objectType, reportErrors)) {
                        return result;
                    }
                }
            }
            else {
                if (getObjectFlags(source) & 4 /* Reference */ && getObjectFlags(target) & 4 /* Reference */ && source.target === target.target &&
                    !(source.flags & 67108864 /* MarkerType */ || target.flags & 67108864 /* MarkerType */)) {
                    // We have type references to the same generic type, and the type references are not marker
                    // type references (which are intended by be compared structurally). Obtain the variance
                    // information for the type parameters and relate the type arguments accordingly.
                    let variances = getVariances(source.target);
                    if (result = typeArgumentsRelatedTo(source, target, variances, reportErrors)) {
                        return result;
                    }
                    // The type arguments did not relate appropriately, but it may be because we have no variance
                    // information (in which case typeArgumentsRelatedTo defaulted to covariance for all type
                    // arguments). It might also be the case that the target type has a 'void' type argument for
                    // a covariant type parameter that is only used in return positions within the generic type
                    // (in which case any type argument is permitted on the source side). In those cases we proceed
                    // with a structural comparison. Otherwise, we know for certain the instantiations aren't
                    // related and we can return here.
                    if (variances !== ts.emptyArray && !hasCovariantVoidArgument(target, variances)) {
                        // In some cases generic types that are covariant in regular type checking mode become
                        // invariant in --strictFunctionTypes mode because one or more type parameters are used in
                        // both co- and contravariant positions. In order to make it easier to diagnose *why* such
                        // types are invariant, if any of the type parameters are invariant we reset the reported
                        // errors and instead force a structural comparison (which will include elaborations that
                        // reveal the reason).
                        if (!(reportErrors && ts.some(variances, function (v) { return v === 0 /* Invariant */; }))) {
                            return 0 /* False */;
                        }
                        errorInfo = saveErrorInfo;
                    }
                }
                // Even if relationship doesn't hold for unions, intersections, or generic type references,
                // it may hold in a structural comparison.
                let sourceIsPrimitive = !!(source.flags & 8190 /* Primitive */);
                if (relation !== identityRelation) {
                    source = getApparentType(source);
                }
                // In a check of the form X = A & B, we will have previously checked if A relates to X or B relates
                // to X. Failing both of those we want to check if the aggregation of A and B's members structurally
                // relates to X. Thus, we include intersection types on the source side here.
                if (source.flags & (TypeFlags.Object | 131072 /* Intersection */) && target.flags & TypeFlags.Object) {
                    // Report structural errors only if we haven't reported any errors yet
                    let reportStructuralErrors = reportErrors && errorInfo === saveErrorInfo && !sourceIsPrimitive;
                    // An empty object type is related to any mapped type that includes a '?' modifier.
                    if (isPartialMappedType(target) && !isGenericMappedType(source) && isEmptyObjectType(source)) {
                        result = -1 /* True */;
                    }
                    else if (isGenericMappedType(target)) {
                        result = isGenericMappedType(source) ? mappedTypeRelatedTo(source, target, reportStructuralErrors) : 0 /* False */;
                    }
                    else {
                        result = propertiesRelatedTo(source, target, reportStructuralErrors);
                        if (result) {
                            result &= signaturesRelatedTo(source, target, 0 /* Call */, reportStructuralErrors);
                            if (result) {
                                result &= signaturesRelatedTo(source, target, 1 /* Construct */, reportStructuralErrors);
                                if (result) {
                                    result &= indexTypesRelatedTo(source, target, 0 /* String */, sourceIsPrimitive, reportStructuralErrors);
                                    if (result) {
                                        result &= indexTypesRelatedTo(source, target, 1 /* Number */, sourceIsPrimitive, reportStructuralErrors);
                                    }
                                }
                            }
                        }
                    }
                    if (result) {
                        errorInfo = saveErrorInfo;
                        return result;
                    }
                }
            }
            return 0 /* False */;
        }
        // A type [P in S]: X is related to a type [Q in T]: Y if T is related to S and X' is
        // related to Y, where X' is an instantiation of X in which P is replaced with Q. Notice
        // that S and T are contra-variant whereas X and Y are co-variant.
        function mappedTypeRelatedTo(source, target, reportErrors) {
            let sourceReadonly = !!source.declaration.readonlyToken;
            let sourceOptional = !!source.declaration.questionToken;
            let targetReadonly = !!target.declaration.readonlyToken;
            let targetOptional = !!target.declaration.questionToken;
            let modifiersRelated = relation === identityRelation ?
                sourceReadonly === targetReadonly && sourceOptional === targetOptional :
                relation === comparableRelation || !sourceOptional || targetOptional;
            if (modifiersRelated) {
                let result_2;
                if (result_2 = isRelatedTo(getConstraintTypeFromMappedType(target), getConstraintTypeFromMappedType(source), reportErrors)) {
                    let mapper = createTypeMapper([getTypeParameterFromMappedType(source)], [getTypeParameterFromMappedType(target)]);
                    return result_2 & isRelatedTo(instantiateType(getTemplateTypeFromMappedType(source), mapper), getTemplateTypeFromMappedType(target), reportErrors);
                }
            }
            return 0 /* False */;
        }
        function propertiesRelatedTo(source, target, reportErrors) {
            if (relation === identityRelation) {
                return propertiesIdenticalTo(source, target);
            }
            let requireOptionalProperties = relation === subtypeRelation && !(getObjectFlags(source) & 128 /* ObjectLiteral */);
            let unmatchedProperty = getUnmatchedProperty(source, target, requireOptionalProperties);
            if (unmatchedProperty) {
                if (reportErrors) {
                    reportError(ts.Diagnostics.Property_0_is_missing_in_type_1, symbolToString(unmatchedProperty), typeToString(source));
                }
                return 0 /* False */;
            }
            let result = -1 /* True */;
            let properties = getPropertiesOfObjectType(target);
            for (let _i = 0, properties_3 = properties; _i < properties_3.length; _i++) {
                let targetProp = properties_3[_i];
                if (!(targetProp.flags & 4194304 /* Prototype */)) {
                    let sourceProp = getPropertyOfType(source, targetProp.escapedName);
                    if (sourceProp && sourceProp !== targetProp) {
                        let sourcePropFlags = ts.getDeclarationModifierFlagsFromSymbol(sourceProp);
                        let targetPropFlags = ts.getDeclarationModifierFlagsFromSymbol(targetProp);
                        if (sourcePropFlags & 8 /* Private */ || targetPropFlags & 8 /* Private */) {
                            if (ts.getCheckFlags(sourceProp) & 256 /* ContainsPrivate */) {
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Property_0_has_conflicting_declarations_and_is_inaccessible_in_type_1, symbolToString(sourceProp), typeToString(source));
                                }
                                return 0 /* False */;
                            }
                            if (sourceProp.valueDeclaration !== targetProp.valueDeclaration) {
                                if (reportErrors) {
                                    if (sourcePropFlags & 8 /* Private */ && targetPropFlags & 8 /* Private */) {
                                        reportError(ts.Diagnostics.Types_have_separate_declarations_of_a_private_property_0, symbolToString(targetProp));
                                    }
                                    else {
                                        reportError(ts.Diagnostics.Property_0_is_private_in_type_1_but_not_in_type_2, symbolToString(targetProp), typeToString(sourcePropFlags & 8 /* Private */ ? source : target), typeToString(sourcePropFlags & 8 /* Private */ ? target : source));
                                    }
                                }
                                return 0 /* False */;
                            }
                        }
                        else if (targetPropFlags & 16 /* Protected */) {
                            if (!isValidOverrideOf(sourceProp, targetProp)) {
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2, symbolToString(targetProp), typeToString(getDeclaringClass(sourceProp) || source), typeToString(getDeclaringClass(targetProp) || target));
                                }
                                return 0 /* False */;
                            }
                        }
                        else if (sourcePropFlags & 16 /* Protected */) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Property_0_is_protected_in_type_1_but_public_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target));
                            }
                            return 0 /* False */;
                        }
                        let related = isRelatedTo(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp), reportErrors);
                        if (!related) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Types_of_property_0_are_incompatible, symbolToString(targetProp));
                            }
                            return 0 /* False */;
                        }
                        result &= related;
                        // When checking for comparability, be more lenient with optional properties.
                        if (relation !== comparableRelation && sourceProp.flags & 16777216 /* Optional */ && !(targetProp.flags & 16777216 /* Optional */)) {
                            // TypeScript 1.0 spec (April 2014): 3.8.3
                            // S is a subtype of a type T, and T is a supertype of S if ...
                            // S' and T are object types and, for each member M in T..
                            // M is a property and S' contains a property N where
                            // if M is a required property, N is also a required property
                            // (M - property in T)
                            // (N - property in S)
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Property_0_is_optional_in_type_1_but_required_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target));
                            }
                            return 0 /* False */;
                        }
                    }
                }
            }
            return result;
        }
        /**
         * A type is 'weak' if it is an object type with at least one optional property
         * and no required properties, call/construct signatures or index signatures
         */
        function isWeakType(type) {
            if (type.flags & TypeFlags.Object) {
                let resolved = resolveStructuredTypeMembers(type);
                return resolved.callSignatures.length === 0 && resolved.constructSignatures.length === 0 &&
                    !resolved.stringIndexInfo && !resolved.numberIndexInfo &&
                    resolved.properties.length > 0 &&
                    ts.every(resolved.properties, function (p) { return !!(p.flags & 16777216 /* Optional */); });
            }
            if (type.flags & 131072 /* Intersection */) {
                return ts.every(type.types, isWeakType);
            }
            return false;
        }
        function hasCommonProperties(source, target) {
            let isComparingJsxAttributes = !!(source.flags & 33554432 /* JsxAttributes */);
            for (let _i = 0, _a = getPropertiesOfType(source); _i < _a.length; _i++) {
                let prop = _a[_i];
                if (isKnownProperty(target, prop.escapedName, isComparingJsxAttributes)) {
                    return true;
                }
            }
            return false;
        }
        function propertiesIdenticalTo(source, target) {
            if (!(source.flags & TypeFlags.Object && target.flags & TypeFlags.Object)) {
                return 0 /* False */;
            }
            let sourceProperties = getPropertiesOfObjectType(source);
            let targetProperties = getPropertiesOfObjectType(target);
            if (sourceProperties.length !== targetProperties.length) {
                return 0 /* False */;
            }
            let result = -1 /* True */;
            for (let _i = 0, sourceProperties_1 = sourceProperties; _i < sourceProperties_1.length; _i++) {
                let sourceProp = sourceProperties_1[_i];
                let targetProp = getPropertyOfObjectType(target, sourceProp.escapedName);
                if (!targetProp) {
                    return 0 /* False */;
                }
                let related = compareProperties(sourceProp, targetProp, isRelatedTo);
                if (!related) {
                    return 0 /* False */;
                }
                result &= related;
            }
            return result;
        }
        function signaturesRelatedTo(source, target, kind, reportErrors) {
            if (relation === identityRelation) {
                return signaturesIdenticalTo(source, target, kind);
            }
            if (target === anyFunctionType || source === anyFunctionType) {
                return -1 /* True */;
            }
            let sourceSignatures = getSignaturesOfType(source, kind);
            let targetSignatures = getSignaturesOfType(target, kind);
            if (kind === 1 /* Construct */ && sourceSignatures.length && targetSignatures.length) {
                if (isAbstractConstructorType(source) && !isAbstractConstructorType(target)) {
                    // An abstract constructor type is not assignable to a non-abstract constructor type
                    // as it would otherwise be possible to new an abstract class. Note that the assignability
                    // check we perform for an extends clause excludes construct signatures from the target,
                    // so this check never proceeds.
                    if (reportErrors) {
                        reportError(ts.Diagnostics.Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type);
                    }
                    return 0 /* False */;
                }
                if (!constructorVisibilitiesAreCompatible(sourceSignatures[0], targetSignatures[0], reportErrors)) {
                    return 0 /* False */;
                }
            }
            let result = -1 /* True */;
            let saveErrorInfo = errorInfo;
            if (getObjectFlags(source) & 64 /* Instantiated */ && getObjectFlags(target) & 64 /* Instantiated */ && source.symbol === target.symbol) {
                // We have instantiations of the same anonymous type (which typically will be the type of a
                // method). Simply do a pairwise comparison of the signatures in the two signature lists instead
                // of the much more expensive N * M comparison matrix we explore below. We erase type parameters
                // as they are known to always be the same.
                for (let i = 0; i < targetSignatures.length; i++) {
                    let related = signatureRelatedTo(sourceSignatures[i], targetSignatures[i], /*erase*/ true, reportErrors);
                    if (!related) {
                        return 0 /* False */;
                    }
                    result &= related;
                }
            }
            else if (sourceSignatures.length === 1 && targetSignatures.length === 1) {
                // For simple functions (functions with a single signature) we only erase type parameters for
                // the comparable relation. Otherwise, if the source signature is generic, we instantiate it
                // in the context of the target signature before checking the relationship. Ideally we'd do
                // this regardless of the number of signatures, but the potential costs are prohibitive due
                // to the quadratic nature of the logic below.
                let eraseGenerics = relation === comparableRelation || compilerOptions.noStrictGenericChecks;
                result = signatureRelatedTo(sourceSignatures[0], targetSignatures[0], eraseGenerics, reportErrors);
            }
            else {
                outer: for (let _i = 0, targetSignatures_1 = targetSignatures; _i < targetSignatures_1.length; _i++) {
                    let t = targetSignatures_1[_i];
                    // Only elaborate errors from the first failure
                    let shouldElaborateErrors = reportErrors;
                    for (let _a = 0, sourceSignatures_1 = sourceSignatures; _a < sourceSignatures_1.length; _a++) {
                        let s = sourceSignatures_1[_a];
                        let related = signatureRelatedTo(s, t, /*erase*/ true, shouldElaborateErrors);
                        if (related) {
                            result &= related;
                            errorInfo = saveErrorInfo;
                            continue outer;
                        }
                        shouldElaborateErrors = false;
                    }
                    if (shouldElaborateErrors) {
                        reportError(ts.Diagnostics.Type_0_provides_no_match_for_the_signature_1, typeToString(source), signatureToString(t, /*enclosingDeclaration*/ undefined, /*flags*/ undefined, kind));
                    }
                    return 0 /* False */;
                }
            }
            return result;
        }
        /**
         * See signatureAssignableTo, compareSignaturesIdentical
         */
        function signatureRelatedTo(source, target, erase, reportErrors) {
            return compareSignaturesRelated(erase ? getErasedSignature(source) : source, erase ? getErasedSignature(target) : target, 0 /* None */, /*ignoreReturnTypes*/ false, reportErrors, reportError, isRelatedTo);
        }
        function signaturesIdenticalTo(source, target, kind) {
            let sourceSignatures = getSignaturesOfType(source, kind);
            let targetSignatures = getSignaturesOfType(target, kind);
            if (sourceSignatures.length !== targetSignatures.length) {
                return 0 /* False */;
            }
            let result = -1 /* True */;
            for (let i = 0; i < sourceSignatures.length; i++) {
                let related = compareSignaturesIdentical(sourceSignatures[i], targetSignatures[i], /*partialMatch*/ false, /*ignoreThisTypes*/ false, /*ignoreReturnTypes*/ false, isRelatedTo);
                if (!related) {
                    return 0 /* False */;
                }
                result &= related;
            }
            return result;
        }
        function eachPropertyRelatedTo(source, target, kind, reportErrors) {
            let result = -1 /* True */;
            for (let _i = 0, _a = getPropertiesOfObjectType(source); _i < _a.length; _i++) {
                let prop = _a[_i];
                if (kind === 0 /* String */ || isNumericLiteralName(prop.escapedName)) {
                    let related = isRelatedTo(getTypeOfSymbol(prop), target, reportErrors);
                    if (!related) {
                        if (reportErrors) {
                            reportError(ts.Diagnostics.Property_0_is_incompatible_with_index_signature, symbolToString(prop));
                        }
                        return 0 /* False */;
                    }
                    result &= related;
                }
            }
            return result;
        }
        function indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors) {
            let related = isRelatedTo(sourceInfo.type, targetInfo.type, reportErrors);
            if (!related && reportErrors) {
                reportError(ts.Diagnostics.Index_signatures_are_incompatible);
            }
            return related;
        }
        function indexTypesRelatedTo(source, target, kind, sourceIsPrimitive, reportErrors) {
            if (relation === identityRelation) {
                return indexTypesIdenticalTo(source, target, kind);
            }
            let targetInfo = getIndexInfoOfType(target, kind);
            if (!targetInfo || targetInfo.type.flags & 1 /* Any */ && !sourceIsPrimitive) {
                // Index signature of type any permits assignment from everything but primitives
                return -1 /* True */;
            }
            let sourceInfo = getIndexInfoOfType(source, kind) ||
                kind === 1 /* Number */ && getIndexInfoOfType(source, 0 /* String */);
            if (sourceInfo) {
                return indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors);
            }
            if (isGenericMappedType(source)) {
                // A generic mapped type { [P in K]: T } is related to an index signature { [x: string]: U }
                // if T is related to U.
                return kind === 0 /* String */ && isRelatedTo(getTemplateTypeFromMappedType(source), targetInfo.type, reportErrors);
            }
            if (isObjectTypeWithInferableIndex(source)) {
                let related = -1 /* True */;
                if (kind === 0 /* String */) {
                    let sourceNumberInfo = getIndexInfoOfType(source, 1 /* Number */);
                    if (sourceNumberInfo) {
                        related = indexInfoRelatedTo(sourceNumberInfo, targetInfo, reportErrors);
                    }
                }
                if (related) {
                    related &= eachPropertyRelatedTo(source, targetInfo.type, kind, reportErrors);
                }
                return related;
            }
            if (reportErrors) {
                reportError(ts.Diagnostics.Index_signature_is_missing_in_type_0, typeToString(source));
            }
            return 0 /* False */;
        }
        function indexTypesIdenticalTo(source, target, indexKind) {
            let targetInfo = getIndexInfoOfType(target, indexKind);
            let sourceInfo = getIndexInfoOfType(source, indexKind);
            if (!sourceInfo && !targetInfo) {
                return -1 /* True */;
            }
            if (sourceInfo && targetInfo && sourceInfo.isReadonly === targetInfo.isReadonly) {
                return isRelatedTo(sourceInfo.type, targetInfo.type);
            }
            return 0 /* False */;
        }
        function constructorVisibilitiesAreCompatible(sourceSignature, targetSignature, reportErrors) {
            if (!sourceSignature.declaration || !targetSignature.declaration) {
                return true;
            }
            let sourceAccessibility = ts.getSelectedModifierFlags(sourceSignature.declaration, 24 /* NonPublicAccessibilityModifier */);
            let targetAccessibility = ts.getSelectedModifierFlags(targetSignature.declaration, 24 /* NonPublicAccessibilityModifier */);
            // A public, protected and private signature is assignable to a private signature.
            if (targetAccessibility === 8 /* Private */) {
                return true;
            }
            // A public and protected signature is assignable to a protected signature.
            if (targetAccessibility === 16 /* Protected */ && sourceAccessibility !== 8 /* Private */) {
                return true;
            }
            // Only a public signature is assignable to public signature.
            if (targetAccessibility !== 16 /* Protected */ && !sourceAccessibility) {
                return true;
            }
            if (reportErrors) {
                reportError(ts.Diagnostics.Cannot_assign_a_0_constructor_type_to_a_1_constructor_type, visibilityToString(sourceAccessibility), visibilityToString(targetAccessibility));
            }
            return false;
        }
    }
    // Return a type reference where the source type parameter is replaced with the target marker
    // type, and flag the result as a marker type reference.
    function getMarkerTypeReference(type, source, target) {
        let result = createTypeReference(type, ts.map(type.typeParameters, function (t) { return t === source ? target : t; }));
        result.flags |= 67108864 /* MarkerType */;
        return result;
    }
    // Return an array containing the variance of each type parameter. The variance is effectively
    // a digest of the type comparisons that occur for each type argument when instantiations of the
    // generic type are structurally compared. We infer the variance information by comparing
    // instantiations of the generic type for type arguments with known relations. The function
    // returns the emptyArray singleton if we're not in strictFunctionTypes mode or if the function
    // has been invoked recursively for the given generic type.
    function getVariances(type) {
        if (!strictFunctionTypes) {
            return ts.emptyArray;
        }
        let typeParameters = type.typeParameters || ts.emptyArray;
        let variances = type.variances;
        if (!variances) {
            if (type === globalArrayType || type === globalReadonlyArrayType) {
                // Arrays are known to be covariant, no need to spend time computing this
                variances = [1 /* Covariant */];
            }
            else {
                // The emptyArray singleton is used to signal a recursive invocation.
                type.variances = ts.emptyArray;
                variances = [];
                for (let _i = 0, typeParameters_1 = typeParameters; _i < typeParameters_1.length; _i++) {
                    let tp = typeParameters_1[_i];
                    // We first compare instantiations where the type parameter is replaced with
                    // marker types that have a known subtype relationship. From this we can infer
                    // invariance, covariance, contravariance or bivariance.
                    let typeWithSuper = getMarkerTypeReference(type, tp, markerSuperType);
                    let typeWithSub = getMarkerTypeReference(type, tp, markerSubType);
                    let variance = (isTypeAssignableTo(typeWithSub, typeWithSuper) ? 1 /* Covariant */ : 0) |
                        (isTypeAssignableTo(typeWithSuper, typeWithSub) ? 2 /* Contravariant */ : 0);
                    // If the instantiations appear to be related bivariantly it may be because the
                    // type parameter is independent (i.e. it isn't witnessed anywhere in the generic
                    // type). To determine this we compare instantiations where the type parameter is
                    // replaced with marker types that are known to be unrelated.
                    if (variance === 3 /* Bivariant */ && isTypeAssignableTo(getMarkerTypeReference(type, tp, markerOtherType), typeWithSuper)) {
                        variance = 4 /* Independent */;
                    }
                    variances.push(variance);
                }
            }
            type.variances = variances;
        }
        return variances;
    }
    // Return true if the given type reference has a 'void' type argument for a covariant type parameter.
    // See comment at call in recursiveTypeRelatedTo for when this case matters.
    function hasCovariantVoidArgument(type, variances) {
        for (let i = 0; i < variances.length; i++) {
            if (variances[i] === 1 /* Covariant */ && type.typeArguments[i].flags & 1024 /* Void */) {
                return true;
            }
        }
        return false;
    }
    function isUnconstrainedTypeParameter(type) {
        return type.flags & 16384 /* TypeParameter */ && !getConstraintFromTypeParameter(type);
    }
    function isTypeReferenceWithGenericArguments(type) {
        return getObjectFlags(type) & 4 /* Reference */ && ts.some(type.typeArguments, function (t) { return isUnconstrainedTypeParameter(t) || isTypeReferenceWithGenericArguments(t); });
    }
    /**
     * getTypeReferenceId(A<T, number, U>) returns "111=0-12=1"
     *   where A.id=111 and number.id=12
     */
    function getTypeReferenceId(type, typeParameters, depth) {
        if (depth === void 0) { depth = 0; }
        let result = "" + type.target.id;
        for (let _i = 0, _a = type.typeArguments; _i < _a.length; _i++) {
            let t = _a[_i];
            if (isUnconstrainedTypeParameter(t)) {
                let index = ts.indexOf(typeParameters, t);
                if (index < 0) {
                    index = typeParameters.length;
                    typeParameters.push(t);
                }
                result += "=" + index;
            }
            else if (depth < 4 && isTypeReferenceWithGenericArguments(t)) {
                result += "<" + getTypeReferenceId(t, typeParameters, depth + 1) + ">";
            }
            else {
                result += "-" + t.id;
            }
        }
        return result;
    }
    /**
     * To improve caching, the relation key for two generic types uses the target's id plus ids of the type parameters.
     * For other cases, the types ids are used.
     */
    function getRelationKey(source, target, relation) {
        if (relation === identityRelation && source.id > target.id) {
            let temp = source;
            source = target;
            target = temp;
        }
        if (isTypeReferenceWithGenericArguments(source) && isTypeReferenceWithGenericArguments(target)) {
            let typeParameters = [];
            return getTypeReferenceId(source, typeParameters) + "," + getTypeReferenceId(target, typeParameters);
        }
        return source.id + "," + target.id;
    }
    // Invoke the callback for each underlying property symbol of the given symbol and return the first
    // value that isn't undefined.
    function forEachProperty(prop, callback) {
        if (ts.getCheckFlags(prop) & 6 /* Synthetic */) {
            for (let _i = 0, _a = prop.containingType.types; _i < _a.length; _i++) {
                let t = _a[_i];
                let p = getPropertyOfType(t, prop.escapedName);
                let result = p && forEachProperty(p, callback);
                if (result) {
                    return result;
                }
            }
            return undefined;
        }
        return callback(prop);
    }
    // Return the declaring class type of a property or undefined if property not declared in class
    function getDeclaringClass(prop) {
        return prop.parent && prop.parent.flags & 32 /* Class */ ? getDeclaredTypeOfSymbol(getParentOfSymbol(prop)) : undefined;
    }
    // Return true if some underlying source property is declared in a class that derives
    // from the given base class.
    function isPropertyInClassDerivedFrom(prop, baseClass) {
        return forEachProperty(prop, function (sp) {
            let sourceClass = getDeclaringClass(sp);
            return sourceClass ? hasBaseType(sourceClass, baseClass) : false;
        });
    }
    // Return true if source property is a valid override of protected parts of target property.
    function isValidOverrideOf(sourceProp, targetProp) {
        return !forEachProperty(targetProp, function (tp) {
            return ts.getDeclarationModifierFlagsFromSymbol(tp) & 16 /* Protected */ ?
                !isPropertyInClassDerivedFrom(sourceProp, getDeclaringClass(tp)) : false;
        });
    }
    // Return true if the given class derives from each of the declaring classes of the protected
    // constituents of the given property.
    function isClassDerivedFromDeclaringClasses(checkClass, prop) {
        return forEachProperty(prop, function (p) {
            return ts.getDeclarationModifierFlagsFromSymbol(p) & 16 /* Protected */ ?
                !hasBaseType(checkClass, getDeclaringClass(p)) : false;
        }) ? undefined : checkClass;
    }
    // Return true if the given type is the constructor type for an abstract class
    function isAbstractConstructorType(type) {
        if (getObjectFlags(type) & 16 /* Anonymous */) {
            let symbol = type.symbol;
            if (symbol && symbol.flags & 32 /* Class */) {
                let declaration = getClassLikeDeclarationOfSymbol(symbol);
                if (declaration && ts.hasModifier(declaration, 128 /* Abstract */)) {
                    return true;
                }
            }
        }
        return false;
    }
    // Return true if the given type is deeply nested. We consider this to be the case when structural type comparisons
    // for 5 or more occurrences or instantiations of the type have been recorded on the given stack. It is possible,
    // though highly unlikely, for this test to be true in a situation where a chain of instantiations is not infinitely
    // expanding. Effectively, we will generate a false positive when two types are structurally equal to at least 5
    // levels, but unequal at some level beyond that.
    function isDeeplyNestedType(type, stack, depth) {
        // We track all object types that have an associated symbol (representing the origin of the type)
        if (depth >= 5 && type.flags & TypeFlags.Object) {
            let symbol = type.symbol;
            if (symbol) {
                let count = 0;
                for (let i = 0; i < depth; i++) {
                    let t = stack[i];
                    if (t.flags & TypeFlags.Object && t.symbol === symbol) {
                        count++;
                        if (count >= 5)
                            return true;
                    }
                }
            }
        }
        return false;
    }
    function isPropertyIdenticalTo(sourceProp, targetProp) {
        return compareProperties(sourceProp, targetProp, compareTypesIdentical) !== 0 /* False */;
    }
    function compareProperties(sourceProp, targetProp, compareTypes) {
        // Two members are considered identical when
        // - they are public properties with identical names, optionality, and types,
        // - they are private or protected properties originating in the same declaration and having identical types
        if (sourceProp === targetProp) {
            return -1 /* True */;
        }
        let sourcePropAccessibility = ts.getDeclarationModifierFlagsFromSymbol(sourceProp) & 24 /* NonPublicAccessibilityModifier */;
        let targetPropAccessibility = ts.getDeclarationModifierFlagsFromSymbol(targetProp) & 24 /* NonPublicAccessibilityModifier */;
        if (sourcePropAccessibility !== targetPropAccessibility) {
            return 0 /* False */;
        }
        if (sourcePropAccessibility) {
            if (getTargetSymbol(sourceProp) !== getTargetSymbol(targetProp)) {
                return 0 /* False */;
            }
        }
        else {
            if ((sourceProp.flags & 16777216 /* Optional */) !== (targetProp.flags & 16777216 /* Optional */)) {
                return 0 /* False */;
            }
        }
        if (isReadonlySymbol(sourceProp) !== isReadonlySymbol(targetProp)) {
            return 0 /* False */;
        }
        return compareTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));
    }
    function isMatchingSignature(source, target, partialMatch) {
        // A source signature matches a target signature if the two signatures have the same number of required,
        // optional, and rest parameters.
        if (source.parameters.length === target.parameters.length &&
            source.minArgumentCount === target.minArgumentCount &&
            source.hasRestParameter === target.hasRestParameter) {
            return true;
        }
        // A source signature partially matches a target signature if the target signature has no fewer required
        // parameters and no more overall parameters than the source signature (where a signature with a rest
        // parameter is always considered to have more overall parameters than one without).
        let sourceRestCount = source.hasRestParameter ? 1 : 0;
        let targetRestCount = target.hasRestParameter ? 1 : 0;
        if (partialMatch && source.minArgumentCount <= target.minArgumentCount && (sourceRestCount > targetRestCount ||
            sourceRestCount === targetRestCount && source.parameters.length >= target.parameters.length)) {
            return true;
        }
        return false;
    }
    /**
     * See signatureRelatedTo, compareSignaturesIdentical
     */
    function compareSignaturesIdentical(source, target, partialMatch, ignoreThisTypes, ignoreReturnTypes, compareTypes) {
        // TODO (drosen): De-duplicate code between related functions.
        if (source === target) {
            return -1 /* True */;
        }
        if (!(isMatchingSignature(source, target, partialMatch))) {
            return 0 /* False */;
        }
        // Check that the two signatures have the same number of type parameters. We might consider
        // also checking that any type parameter constraints match, but that would require instantiating
        // the constraints with a common set of type arguments to get relatable entities in places where
        // type parameters occur in the constraints. The complexity of doing that doesn't seem worthwhile,
        // particularly as we're comparing erased versions of the signatures below.
        if (ts.length(source.typeParameters) !== ts.length(target.typeParameters)) {
            return 0 /* False */;
        }
        // Spec 1.0 Section 3.8.3 & 3.8.4:
        // M and N (the signatures) are instantiated using type Any as the type argument for all type parameters declared by M and N
        source = getErasedSignature(source);
        target = getErasedSignature(target);
        let result = -1 /* True */;
        if (!ignoreThisTypes) {
            let sourceThisType = getThisTypeOfSignature(source);
            if (sourceThisType) {
                let targetThisType = getThisTypeOfSignature(target);
                if (targetThisType) {
                    let related = compareTypes(sourceThisType, targetThisType);
                    if (!related) {
                        return 0 /* False */;
                    }
                    result &= related;
                }
            }
        }
        let targetLen = target.parameters.length;
        for (let i = 0; i < targetLen; i++) {
            let s = isRestParameterIndex(source, i) ? getRestTypeOfSignature(source) : getTypeOfParameter(source.parameters[i]);
            let t = isRestParameterIndex(target, i) ? getRestTypeOfSignature(target) : getTypeOfParameter(target.parameters[i]);
            let related = compareTypes(s, t);
            if (!related) {
                return 0 /* False */;
            }
            result &= related;
        }
        if (!ignoreReturnTypes) {
            result &= compareTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
        }
        return result;
    }
    function isRestParameterIndex(signature, parameterIndex) {
        return signature.hasRestParameter && parameterIndex >= signature.parameters.length - 1;
    }
    function literalTypesWithSameBaseType(types) {
        let commonBaseType;
        for (let _i = 0, types_10 = types; _i < types_10.length; _i++) {
            let t = types_10[_i];
            let baseType = getBaseTypeOfLiteralType(t);
            if (!commonBaseType) {
                commonBaseType = baseType;
            }
            if (baseType === t || baseType !== commonBaseType) {
                return false;
            }
        }
        return true;
    }
    // When the candidate types are all literal types with the same base type, return a union
    // of those literal types. Otherwise, return the leftmost type for which no type to the
    // right is a supertype.
    function getSupertypeOrUnion(types) {
        return literalTypesWithSameBaseType(types) ?
            getUnionType(types) :
            ts.reduceLeft(types, function (s, t) { return isTypeSubtypeOf(s, t) ? t : s; });
    }
    function getCommonSupertype(types) {
        if (!strictNullChecks) {
            return getSupertypeOrUnion(types);
        }
        let primaryTypes = ts.filter(types, function (t) { return !(t.flags & 6144 /* Nullable */); });
        return primaryTypes.length ?
            getNullableType(getSupertypeOrUnion(primaryTypes), getFalsyFlagsOfTypes(types) & 6144 /* Nullable */) :
            getUnionType(types, /*subtypeReduction*/ true);
    }
    // Return the leftmost type for which no type to the right is a subtype.
    function getCommonSubtype(types) {
        return ts.reduceLeft(types, function (s, t) { return isTypeSubtypeOf(t, s) ? t : s; });
    }
    function isArrayType(type) {
        return getObjectFlags(type) & 4 /* Reference */ && type.target === globalArrayType;
    }
    function isArrayLikeType(type) {
        // A type is array-like if it is a reference to the global Array or global ReadonlyArray type,
        // or if it is not the undefined or null type and if it is assignable to ReadonlyArray<any>
        return getObjectFlags(type) & 4 /* Reference */ && (type.target === globalArrayType || type.target === globalReadonlyArrayType) ||
            !(type.flags & 6144 /* Nullable */) && isTypeAssignableTo(type, anyReadonlyArrayType);
    }
    function isTupleLikeType(type) {
        return !!getPropertyOfType(type, "0");
    }
    function isUnitType(type) {
        return !!(type.flags & 6368 /* Unit */);
    }
    function isLiteralType(type) {
        return type.flags & 8 /* Boolean */ ? true :
            type.flags & 65536 /* Union */ ? type.flags & 256 /* EnumLiteral */ ? true : !ts.forEach(type.types, function (t) { return !isUnitType(t); }) :
                isUnitType(type);
    }
    function getBaseTypeOfLiteralType(type) {
        return type.flags & 256 /* EnumLiteral */ ? getBaseTypeOfEnumLiteralType(type) :
            type.flags & 32 /* StringLiteral */ ? stringType :
                type.flags & 64 /* NumberLiteral */ ? numberType :
                    type.flags & 128 /* BooleanLiteral */ ? booleanType :
                        type.flags & 65536 /* Union */ ? getUnionType(ts.sameMap(type.types, getBaseTypeOfLiteralType)) :
                            type;
    }
    function getWidenedLiteralType(type) {
        return type.flags & 256 /* EnumLiteral */ ? getBaseTypeOfEnumLiteralType(type) :
            type.flags & 32 /* StringLiteral */ && type.flags & 1048576 /* FreshLiteral */ ? stringType :
                type.flags & 64 /* NumberLiteral */ && type.flags & 1048576 /* FreshLiteral */ ? numberType :
                    type.flags & 128 /* BooleanLiteral */ ? booleanType :
                        type.flags & 65536 /* Union */ ? getUnionType(ts.sameMap(type.types, getWidenedLiteralType)) :
                            type;
    }
    /**
     * Check if a Type was written as a tuple type literal.
     * Prefer using isTupleLikeType() unless the use of `elementTypes` is required.
     */
    function isTupleType(type) {
        return !!(getObjectFlags(type) & 4 /* Reference */ && type.target.objectFlags & 8 /* Tuple */);
    }
    function getFalsyFlagsOfTypes(types) {
        let result = 0;
        for (let _i = 0, types_11 = types; _i < types_11.length; _i++) {
            let t = types_11[_i];
            result |= getFalsyFlags(t);
        }
        return result;
    }
    // Returns the String, Number, Boolean, StringLiteral, NumberLiteral, BooleanLiteral, Void, Undefined, or Null
    // flags for the string, number, boolean, "", 0, false, void, undefined, or null types respectively. Returns
    // no flags for all other types (including non-falsy literal types).
    function getFalsyFlags(type) {
        return type.flags & 65536 /* Union */ ? getFalsyFlagsOfTypes(type.types) :
            type.flags & 32 /* StringLiteral */ ? type.value === "" ? 32 /* StringLiteral */ : 0 :
                type.flags & 64 /* NumberLiteral */ ? type.value === 0 ? 64 /* NumberLiteral */ : 0 :
                    type.flags & 128 /* BooleanLiteral */ ? type === falseType ? 128 /* BooleanLiteral */ : 0 :
                        type.flags & 7406 /* PossiblyFalsy */;
    }
    function removeDefinitelyFalsyTypes(type) {
        return getFalsyFlags(type) & 7392 /* DefinitelyFalsy */ ?
            filterType(type, function (t) { return !(getFalsyFlags(t) & 7392 /* DefinitelyFalsy */); }) :
            type;
    }
    function extractDefinitelyFalsyTypes(type) {
        return mapType(type, getDefinitelyFalsyPartOfType);
    }
    function getDefinitelyFalsyPartOfType(type) {
        return type.flags & 2 /* String */ ? emptyStringType :
            type.flags & 4 /* Number */ ? zeroType :
                type.flags & 8 /* Boolean */ || type === falseType ? falseType :
                    type.flags & (1024 /* Void */ | 2048 /* Undefined */ | 4096 /* Null */) ||
                        type.flags & 32 /* StringLiteral */ && type.value === "" ||
                        type.flags & 64 /* NumberLiteral */ && type.value === 0 ? type :
                        neverType;
    }
    /**
     * Add undefined or null or both to a type if they are missing.
     * @param type - type to add undefined and/or null to if not present
     * @param flags - Either TypeFlags.Undefined or TypeFlags.Null, or both
     */
    function getNullableType(type, flags) {
        let missing = (flags & ~type.flags) & (2048 /* Undefined */ | 4096 /* Null */);
        return missing === 0 ? type :
            missing === 2048 /* Undefined */ ? getUnionType([type, undefinedType]) :
                missing === 4096 /* Null */ ? getUnionType([type, nullType]) :
                    getUnionType([type, undefinedType, nullType]);
    }
    function getNonNullableType(type) {
        return strictNullChecks ? getTypeWithFacts(type, 524288 /* NEUndefinedOrNull */) : type;
    }
    /**
     * Return true if type was inferred from an object literal, written as an object type literal, or is the shape of a module
     * with no call or construct signatures.
     */
    function isObjectTypeWithInferableIndex(type) {
        return type.symbol && (type.symbol.flags & (4096 /* ObjectLiteral */ | 2048 /* TypeLiteral */ | 512 /* ValueModule */)) !== 0 &&
            getSignaturesOfType(type, 0 /* Call */).length === 0 &&
            getSignaturesOfType(type, 1 /* Construct */).length === 0;
    }
    function createSymbolWithType(source, type) {
        let symbol = createSymbol(source.flags, source.escapedName);
        symbol.declarations = source.declarations;
        symbol.parent = source.parent;
        symbol.type = type;
        symbol.target = source;
        if (source.valueDeclaration) {
            symbol.valueDeclaration = source.valueDeclaration;
        }
        return symbol;
    }
    function transformTypeOfMembers(type, f) {
        let members = ts.createSymbolTable();
        for (let _i = 0, _a = getPropertiesOfObjectType(type); _i < _a.length; _i++) {
            let property = _a[_i];
            let original = getTypeOfSymbol(property);
            let updated = f(original);
            members.set(property.escapedName, updated === original ? property : createSymbolWithType(property, updated));
        }
        return members;
    }
    /**
     * If the the provided object literal is subject to the excess properties check,
     * create a new that is exempt. Recursively mark object literal members as exempt.
     * Leave signatures alone since they are not subject to the check.
     */
    function getRegularTypeOfObjectLiteral(type) {
        if (!(getObjectFlags(type) & 128 /* ObjectLiteral */ && type.flags & 1048576 /* FreshLiteral */)) {
            return type;
        }
        let regularType = type.regularType;
        if (regularType) {
            return regularType;
        }
        let resolved = type;
        let members = transformTypeOfMembers(type, getRegularTypeOfObjectLiteral);
        let regularNew = createAnonymousType(resolved.symbol, members, resolved.callSignatures, resolved.constructSignatures, resolved.stringIndexInfo, resolved.numberIndexInfo);
        regularNew.flags = resolved.flags & ~1048576 /* FreshLiteral */;
        regularNew.objectFlags |= 128 /* ObjectLiteral */;
        type.regularType = regularNew;
        return regularNew;
    }
    function getWidenedProperty(prop) {
        let original = getTypeOfSymbol(prop);
        let widened = getWidenedType(original);
        return widened === original ? prop : createSymbolWithType(prop, widened);
    }
    function getWidenedTypeOfObjectLiteral(type) {
        let members = ts.createSymbolTable();
        for (let _i = 0, _a = getPropertiesOfObjectType(type); _i < _a.length; _i++) {
            let prop = _a[_i];
            // Since get accessors already widen their return value there is no need to
            // widen accessor based properties here.
            members.set(prop.escapedName, prop.flags & SymbolFlags.Property ? getWidenedProperty(prop) : prop);
        }
        let stringIndexInfo = getIndexInfoOfType(type, 0 /* String */);
        let numberIndexInfo = getIndexInfoOfType(type, 1 /* Number */);
        return createAnonymousType(type.symbol, members, ts.emptyArray, ts.emptyArray, stringIndexInfo && createIndexInfo(getWidenedType(stringIndexInfo.type), stringIndexInfo.isReadonly), numberIndexInfo && createIndexInfo(getWidenedType(numberIndexInfo.type), numberIndexInfo.isReadonly));
    }
    function getWidenedConstituentType(type) {
        return type.flags & 6144 /* Nullable */ ? type : getWidenedType(type);
    }
    function getWidenedType(type) {
        if (type.flags & 6291456 /* RequiresWidening */) {
            if (type.flags & 6144 /* Nullable */) {
                return anyType;
            }
            if (getObjectFlags(type) & 128 /* ObjectLiteral */) {
                return getWidenedTypeOfObjectLiteral(type);
            }
            if (type.flags & 65536 /* Union */) {
                return getUnionType(ts.sameMap(type.types, getWidenedConstituentType));
            }
            if (isArrayType(type) || isTupleType(type)) {
                return createTypeReference(type.target, ts.sameMap(type.typeArguments, getWidenedType));
            }
        }
        return type;
    }
    /**
     * Reports implicit any errors that occur as a result of widening 'null' and 'undefined'
     * to 'any'. A call to reportWideningErrorsInType is normally accompanied by a call to
     * getWidenedType. But in some cases getWidenedType is called without reporting errors
     * (type argument inference is an example).
     *
     * The return value indicates whether an error was in fact reported. The particular circumstances
     * are on a best effort basis. Currently, if the null or undefined that causes widening is inside
     * an object literal property (arbitrarily deeply), this function reports an error. If no error is
     * reported, reportImplicitAnyError is a suitable fallback to report a general error.
     */
    function reportWideningErrorsInType(type) {
        let errorReported = false;
        if (type.flags & 65536 /* Union */) {
            for (let _i = 0, _a = type.types; _i < _a.length; _i++) {
                let t = _a[_i];
                if (reportWideningErrorsInType(t)) {
                    errorReported = true;
                }
            }
        }
        if (isArrayType(type) || isTupleType(type)) {
            for (let _b = 0, _c = type.typeArguments; _b < _c.length; _b++) {
                let t = _c[_b];
                if (reportWideningErrorsInType(t)) {
                    errorReported = true;
                }
            }
        }
        if (getObjectFlags(type) & 128 /* ObjectLiteral */) {
            for (let _d = 0, _e = getPropertiesOfObjectType(type); _d < _e.length; _d++) {
                let p = _e[_d];
                let t = getTypeOfSymbol(p);
                if (t.flags & 2097152 /* ContainsWideningType */) {
                    if (!reportWideningErrorsInType(t)) {
                        error(p.valueDeclaration, ts.Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type, ts.symbolName(p), typeToString(getWidenedType(t)));
                    }
                    errorReported = true;
                }
            }
        }
        return errorReported;
    }
    function reportImplicitAnyError(declaration, type) {
        let typeAsString = typeToString(getWidenedType(type));
        let diagnostic;
        switch (declaration.kind) {
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.PropertySignature:
                diagnostic = ts.Diagnostics.Member_0_implicitly_has_an_1_type;
                break;
            case SyntaxKind.Parameter:
                diagnostic = declaration.dotDotDotToken ?
                    ts.Diagnostics.Rest_parameter_0_implicitly_has_an_any_type :
                    ts.Diagnostics.Parameter_0_implicitly_has_an_1_type;
                break;
            case 176 /* BindingElement */:
                diagnostic = ts.Diagnostics.Binding_element_0_implicitly_has_an_1_type;
                break;
            case 228 /* FunctionDeclaration */:
            case SyntaxKind.MethodDeclaration:
            case 150 /* MethodSignature */:
            case 153 /* GetAccessor */:
            case 154 /* SetAccessor */:
            case 186 /* FunctionExpression */:
            case 187 /* ArrowFunction */:
                if (!declaration.name) {
                    error(declaration, ts.Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);
                    return;
                }
                diagnostic = ts.Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type;
                break;
            default:
                diagnostic = ts.Diagnostics.Variable_0_implicitly_has_an_1_type;
        }
        error(declaration, diagnostic, ts.declarationNameToString(ts.getNameOfDeclaration(declaration)), typeAsString);
    }
    function reportErrorsFromWidening(declaration, type) {
        if (produceDiagnostics && noImplicitAny && type.flags & 2097152 /* ContainsWideningType */) {
            // Report implicit any error within type if possible, otherwise report error on declaration
            if (!reportWideningErrorsInType(type)) {
                reportImplicitAnyError(declaration, type);
            }
        }
    }
    function forEachMatchingParameterType(source, target, callback) {
        let sourceMax = source.parameters.length;
        let targetMax = target.parameters.length;
        let count;
        if (source.hasRestParameter && target.hasRestParameter) {
            count = Math.max(sourceMax, targetMax);
        }
        else if (source.hasRestParameter) {
            count = targetMax;
        }
        else if (target.hasRestParameter) {
            count = sourceMax;
        }
        else {
            count = Math.min(sourceMax, targetMax);
        }
        for (let i = 0; i < count; i++) {
            callback(getTypeAtPosition(source, i), getTypeAtPosition(target, i));
        }
    }
    function createInferenceContext(signature, flags, compareTypes, baseInferences) {
        let inferences = baseInferences ? ts.map(baseInferences, cloneInferenceInfo) : ts.map(signature.typeParameters, createInferenceInfo);
        let context = mapper;
        context.signature = signature;
        context.inferences = inferences;
        context.flags = flags;
        context.compareTypes = compareTypes || compareTypesAssignable;
        return context;
        function mapper(t) {
            for (let i = 0; i < inferences.length; i++) {
                if (t === inferences[i].typeParameter) {
                    inferences[i].isFixed = true;
                    return getInferredType(context, i);
                }
            }
            return t;
        }
    }
    function createInferenceInfo(typeParameter) {
        return {
            typeParameter: typeParameter,
            candidates: undefined,
            inferredType: undefined,
            priority: undefined,
            topLevel: true,
            isFixed: false
        };
    }
    function cloneInferenceInfo(inference) {
        return {
            typeParameter: inference.typeParameter,
            candidates: inference.candidates && inference.candidates.slice(),
            inferredType: inference.inferredType,
            priority: inference.priority,
            topLevel: inference.topLevel,
            isFixed: inference.isFixed
        };
    }
    // Return true if the given type could possibly reference a type parameter for which
    // we perform type inference (i.e. a type parameter of a generic function). We cache
    // results for union and intersection types for performance reasons.
    function couldContainTypeVariables(type) {
        let objectFlags = getObjectFlags(type);
        return !!(type.flags & (540672 /* TypeVariable */ | 262144 /* Index */) ||
            objectFlags & 4 /* Reference */ && ts.forEach(type.typeArguments, couldContainTypeVariables) ||
            objectFlags & 16 /* Anonymous */ && type.symbol && type.symbol.flags & (16 /* Function */ | 8192 /* Method */ | 2048 /* TypeLiteral */ | 32 /* Class */) ||
            objectFlags & 32 /* Mapped */ ||
            type.flags & 196608 /* UnionOrIntersection */ && couldUnionOrIntersectionContainTypeVariables(type));
    }
    function couldUnionOrIntersectionContainTypeVariables(type) {
        if (type.couldContainTypeVariables === undefined) {
            type.couldContainTypeVariables = ts.forEach(type.types, couldContainTypeVariables);
        }
        return type.couldContainTypeVariables;
    }
    function isTypeParameterAtTopLevel(type, typeParameter) {
        return type === typeParameter || type.flags & 196608 /* UnionOrIntersection */ && ts.forEach(type.types, function (t) { return isTypeParameterAtTopLevel(t, typeParameter); });
    }
    // Infer a suitable input type for a homomorphic mapped type { [P in keyof T]: X }. We construct
    // an object type with the same set of properties as the source type, where the type of each
    // property is computed by inferring from the source property type to X for the type
    // variable T[P] (i.e. we treat the type T[P] as the type variable we're inferring for).
    function inferTypeForHomomorphicMappedType(source, target) {
        let properties = getPropertiesOfType(source);
        let indexInfo = getIndexInfoOfType(source, 0 /* String */);
        if (properties.length === 0 && !indexInfo) {
            return undefined;
        }
        let typeParameter = getIndexedAccessType(getConstraintTypeFromMappedType(target).type, getTypeParameterFromMappedType(target));
        let inference = createInferenceInfo(typeParameter);
        let inferences = [inference];
        let templateType = getTemplateTypeFromMappedType(target);
        let readonlyMask = target.declaration.readonlyToken ? false : true;
        let optionalMask = target.declaration.questionToken ? 0 : 16777216 /* Optional */;
        let members = ts.createSymbolTable();
        for (let _i = 0, properties_4 = properties; _i < properties_4.length; _i++) {
            let prop = properties_4[_i];
            let inferredPropType = inferTargetType(getTypeOfSymbol(prop));
            if (!inferredPropType) {
                return undefined;
            }
            let inferredProp = createSymbol(SymbolFlags.Property | prop.flags & optionalMask, prop.escapedName);
            inferredProp.checkFlags = readonlyMask && isReadonlySymbol(prop) ? 8 /* Readonly */ : 0;
            inferredProp.declarations = prop.declarations;
            inferredProp.type = inferredPropType;
            members.set(prop.escapedName, inferredProp);
        }
        if (indexInfo) {
            let inferredIndexType = inferTargetType(indexInfo.type);
            if (!inferredIndexType) {
                return undefined;
            }
            indexInfo = createIndexInfo(inferredIndexType, readonlyMask && indexInfo.isReadonly);
        }
        return createAnonymousType(undefined, members, ts.emptyArray, ts.emptyArray, indexInfo, undefined);
        function inferTargetType(sourceType) {
            inference.candidates = undefined;
            inferTypes(inferences, sourceType, templateType);
            return inference.candidates && getUnionType(inference.candidates, /*subtypeReduction*/ true);
        }
    }
    function getUnmatchedProperty(source, target, requireOptionalProperties) {
        let properties = getPropertiesOfObjectType(target);
        for (let _i = 0, properties_5 = properties; _i < properties_5.length; _i++) {
            let targetProp = properties_5[_i];
            if (requireOptionalProperties || !(targetProp.flags & 16777216 /* Optional */)) {
                let sourceProp = getPropertyOfType(source, targetProp.escapedName);
                if (!sourceProp) {
                    return targetProp;
                }
            }
        }
        return undefined;
    }
    function inferTypes(inferences, originalSource, originalTarget, priority) {
        if (priority === void 0) { priority = 0; }
        let symbolStack;
        let visited;
        inferFromTypes(originalSource, originalTarget);
        function inferFromTypes(source, target) {
            if (!couldContainTypeVariables(target)) {
                return;
            }
            if (source.aliasSymbol && source.aliasTypeArguments && source.aliasSymbol === target.aliasSymbol) {
                // Source and target are types originating in the same generic type alias declaration.
                // Simply infer from source type arguments to target type arguments.
                let sourceTypes = source.aliasTypeArguments;
                let targetTypes = target.aliasTypeArguments;
                for (let i = 0; i < sourceTypes.length; i++) {
                    inferFromTypes(sourceTypes[i], targetTypes[i]);
                }
                return;
            }
            if (source.flags & 65536 /* Union */ && target.flags & 65536 /* Union */ && !(source.flags & 256 /* EnumLiteral */ && target.flags & 256 /* EnumLiteral */) ||
                source.flags & 131072 /* Intersection */ && target.flags & 131072 /* Intersection */) {
                // Source and target are both unions or both intersections. If source and target
                // are the same type, just relate each constituent type to itself.
                if (source === target) {
                    for (let _i = 0, _a = source.types; _i < _a.length; _i++) {
                        let t = _a[_i];
                        inferFromTypes(t, t);
                    }
                    return;
                }
                // Find each source constituent type that has an identically matching target constituent
                // type, and for each such type infer from the type to itself. When inferring from a
                // type to itself we effectively find all type parameter occurrences within that type
                // and infer themselves as their type arguments. We have special handling for numeric
                // and string literals because the number and string types are not represented as unions
                // of all their possible values.
                let matchingTypes = void 0;
                for (let _b = 0, _c = source.types; _b < _c.length; _b++) {
                    let t = _c[_b];
                    if (typeIdenticalToSomeType(t, target.types)) {
                        (matchingTypes || (matchingTypes = [])).push(t);
                        inferFromTypes(t, t);
                    }
                    else if (t.flags & (64 /* NumberLiteral */ | 32 /* StringLiteral */)) {
                        let b = getBaseTypeOfLiteralType(t);
                        if (typeIdenticalToSomeType(b, target.types)) {
                            (matchingTypes || (matchingTypes = [])).push(t, b);
                        }
                    }
                }
                // Next, to improve the quality of inferences, reduce the source and target types by
                // removing the identically matched constituents. For example, when inferring from
                // 'string | string[]' to 'string | T' we reduce the types to 'string[]' and 'T'.
                if (matchingTypes) {
                    source = removeTypesFromUnionOrIntersection(source, matchingTypes);
                    target = removeTypesFromUnionOrIntersection(target, matchingTypes);
                }
            }
            if (target.flags & 540672 /* TypeVariable */) {
                // If target is a type parameter, make an inference, unless the source type contains
                // the anyFunctionType (the wildcard type that's used to avoid contextually typing functions).
                // Because the anyFunctionType is internal, it should not be exposed to the user by adding
                // it as an inference candidate. Hopefully, a better candidate will come along that does
                // not contain anyFunctionType when we come back to this argument for its second round
                // of inference. Also, we exclude inferences for silentNeverType which is used as a wildcard
                // when constructing types from type parameters that had no inference candidates.
                if (source.flags & 8388608 /* ContainsAnyFunctionType */ || source === silentNeverType) {
                    return;
                }
                let inference = getInferenceInfoForType(target);
                if (inference) {
                    if (!inference.isFixed) {
                        if (!inference.candidates || priority < inference.priority) {
                            inference.candidates = [source];
                            inference.priority = priority;
                        }
                        else if (priority === inference.priority) {
                            inference.candidates.push(source);
                        }
                        if (!(priority & 8 /* ReturnType */) && target.flags & 16384 /* TypeParameter */ && !isTypeParameterAtTopLevel(originalTarget, target)) {
                            inference.topLevel = false;
                        }
                    }
                    return;
                }
            }
            else if (getObjectFlags(source) & 4 /* Reference */ && getObjectFlags(target) & 4 /* Reference */ && source.target === target.target) {
                // If source and target are references to the same generic type, infer from type arguments
                let sourceTypes = source.typeArguments || ts.emptyArray;
                let targetTypes = target.typeArguments || ts.emptyArray;
                let count = sourceTypes.length < targetTypes.length ? sourceTypes.length : targetTypes.length;
                let variances = getVariances(source.target);
                for (let i = 0; i < count; i++) {
                    if (i < variances.length && variances[i] === 2 /* Contravariant */) {
                        inferFromContravariantTypes(sourceTypes[i], targetTypes[i]);
                    }
                    else {
                        inferFromTypes(sourceTypes[i], targetTypes[i]);
                    }
                }
            }
            else if (source.flags & 262144 /* Index */ && target.flags & 262144 /* Index */) {
                inferFromTypes(source.type, target.type);
            }
            else if (source.flags & 524288 /* IndexedAccess */ && target.flags & 524288 /* IndexedAccess */) {
                inferFromTypes(source.objectType, target.objectType);
                inferFromTypes(source.indexType, target.indexType);
            }
            else if (target.flags & 196608 /* UnionOrIntersection */) {
                let targetTypes = target.types;
                let typeVariableCount = 0;
                let typeVariable = void 0;
                // First infer to each type in union or intersection that isn't a type variable
                for (let _d = 0, targetTypes_3 = targetTypes; _d < targetTypes_3.length; _d++) {
                    let t = targetTypes_3[_d];
                    if (getInferenceInfoForType(t)) {
                        typeVariable = t;
                        typeVariableCount++;
                    }
                    else {
                        inferFromTypes(source, t);
                    }
                }
                // Next, if target containings a single naked type variable, make a secondary inference to that type
                // variable. This gives meaningful results for union types in co-variant positions and intersection
                // types in contra-variant positions (such as callback parameters).
                if (typeVariableCount === 1) {
                    let savePriority = priority;
                    priority |= 2 /* NakedTypeVariable */;
                    inferFromTypes(source, typeVariable);
                    priority = savePriority;
                }
            }
            else if (source.flags & 65536 /* Union */) {
                // Source is a union or intersection type, infer from each constituent type
                let sourceTypes = source.types;
                for (let _e = 0, sourceTypes_3 = sourceTypes; _e < sourceTypes_3.length; _e++) {
                    let sourceType = sourceTypes_3[_e];
                    inferFromTypes(sourceType, target);
                }
            }
            else {
                source = getApparentType(source);
                if (source.flags & (TypeFlags.Object | 131072 /* Intersection */)) {
                    let key = source.id + "," + target.id;
                    if (visited && visited.get(key)) {
                        return;
                    }
                    (visited || (visited = ts.createMap())).set(key, true);
                    // If we are already processing another target type with the same associated symbol (such as
                    // an instantiation of the same generic type), we do not explore this target as it would yield
                    // no further inferences. We exclude the static side of classes from this check since it shares
                    // its symbol with the instance side which would lead to false positives.
                    let isNonConstructorObject = target.flags & TypeFlags.Object &&
                        !(getObjectFlags(target) & 16 /* Anonymous */ && target.symbol && target.symbol.flags & 32 /* Class */);
                    let symbol = isNonConstructorObject ? target.symbol : undefined;
                    if (symbol) {
                        if (ts.contains(symbolStack, symbol)) {
                            return;
                        }
                        (symbolStack || (symbolStack = [])).push(symbol);
                        inferFromObjectTypes(source, target);
                        symbolStack.pop();
                    }
                    else {
                        inferFromObjectTypes(source, target);
                    }
                }
            }
        }
        function inferFromContravariantTypes(source, target) {
            if (strictFunctionTypes) {
                priority ^= 1 /* Contravariant */;
                inferFromTypes(source, target);
                priority ^= 1 /* Contravariant */;
            }
            else {
                inferFromTypes(source, target);
            }
        }
        function getInferenceInfoForType(type) {
            if (type.flags & 540672 /* TypeVariable */) {
                for (let _i = 0, inferences_1 = inferences; _i < inferences_1.length; _i++) {
                    let inference = inferences_1[_i];
                    if (type === inference.typeParameter) {
                        return inference;
                    }
                }
            }
            return undefined;
        }
        function inferFromObjectTypes(source, target) {
            if (isGenericMappedType(source) && isGenericMappedType(target)) {
                // The source and target types are generic types { [P in S]: X } and { [P in T]: Y }, so we infer
                // from S to T and from X to Y.
                inferFromTypes(getConstraintTypeFromMappedType(source), getConstraintTypeFromMappedType(target));
                inferFromTypes(getTemplateTypeFromMappedType(source), getTemplateTypeFromMappedType(target));
            }
            if (getObjectFlags(target) & 32 /* Mapped */) {
                let constraintType = getConstraintTypeFromMappedType(target);
                if (constraintType.flags & 262144 /* Index */) {
                    // We're inferring from some source type S to a homomorphic mapped type { [P in keyof T]: X },
                    // where T is a type variable. Use inferTypeForHomomorphicMappedType to infer a suitable source
                    // type and then make a secondary inference from that type to T. We make a secondary inference
                    // such that direct inferences to T get priority over inferences to Partial<T>, for example.
                    let inference = getInferenceInfoForType(constraintType.type);
                    if (inference && !inference.isFixed) {
                        let inferredType = inferTypeForHomomorphicMappedType(source, target);
                        if (inferredType) {
                            let savePriority = priority;
                            priority |= 4 /* MappedType */;
                            inferFromTypes(inferredType, inference.typeParameter);
                            priority = savePriority;
                        }
                    }
                    return;
                }
                if (constraintType.flags & 16384 /* TypeParameter */) {
                    // We're inferring from some source type S to a mapped type { [P in T]: X }, where T is a type
                    // parameter. Infer from 'keyof S' to T and infer from a union of each property type in S to X.
                    inferFromTypes(getIndexType(source), constraintType);
                    inferFromTypes(getUnionType(ts.map(getPropertiesOfType(source), getTypeOfSymbol)), getTemplateTypeFromMappedType(target));
                    return;
                }
            }
            // Infer from the members of source and target only if the two types are possibly related. We check
            // in both directions because we may be inferring for a co-variant or a contra-variant position.
            if (!getUnmatchedProperty(source, target, /*requireOptionalProperties*/ false) || !getUnmatchedProperty(target, source, /*requireOptionalProperties*/ false)) {
                inferFromProperties(source, target);
                inferFromSignatures(source, target, 0 /* Call */);
                inferFromSignatures(source, target, 1 /* Construct */);
                inferFromIndexTypes(source, target);
            }
        }
        function inferFromProperties(source, target) {
            let properties = getPropertiesOfObjectType(target);
            for (let _i = 0, properties_6 = properties; _i < properties_6.length; _i++) {
                let targetProp = properties_6[_i];
                let sourceProp = getPropertyOfType(source, targetProp.escapedName);
                if (sourceProp) {
                    inferFromTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));
                }
            }
        }
        function inferFromSignatures(source, target, kind) {
            let sourceSignatures = getSignaturesOfType(source, kind);
            let targetSignatures = getSignaturesOfType(target, kind);
            let sourceLen = sourceSignatures.length;
            let targetLen = targetSignatures.length;
            let len = sourceLen < targetLen ? sourceLen : targetLen;
            for (let i = 0; i < len; i++) {
                inferFromSignature(getErasedSignature(sourceSignatures[sourceLen - len + i]), getErasedSignature(targetSignatures[targetLen - len + i]));
            }
        }
        function inferFromSignature(source, target) {
            forEachMatchingParameterType(source, target, inferFromContravariantTypes);
            if (source.typePredicate && target.typePredicate && source.typePredicate.kind === target.typePredicate.kind) {
                inferFromTypes(source.typePredicate.type, target.typePredicate.type);
            }
            else {
                inferFromTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
            }
        }
        function inferFromIndexTypes(source, target) {
            let targetStringIndexType = getIndexTypeOfType(target, 0 /* String */);
            if (targetStringIndexType) {
                let sourceIndexType = getIndexTypeOfType(source, 0 /* String */) ||
                    getImplicitIndexTypeOfType(source, 0 /* String */);
                if (sourceIndexType) {
                    inferFromTypes(sourceIndexType, targetStringIndexType);
                }
            }
            let targetNumberIndexType = getIndexTypeOfType(target, 1 /* Number */);
            if (targetNumberIndexType) {
                let sourceIndexType = getIndexTypeOfType(source, 1 /* Number */) ||
                    getIndexTypeOfType(source, 0 /* String */) ||
                    getImplicitIndexTypeOfType(source, 1 /* Number */);
                if (sourceIndexType) {
                    inferFromTypes(sourceIndexType, targetNumberIndexType);
                }
            }
        }
    }
    function typeIdenticalToSomeType(type, types) {
        for (let _i = 0, types_12 = types; _i < types_12.length; _i++) {
            let t = types_12[_i];
            if (isTypeIdenticalTo(t, type)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Return a new union or intersection type computed by removing a given set of types
     * from a given union or intersection type.
     */
    function removeTypesFromUnionOrIntersection(type, typesToRemove) {
        let reducedTypes = [];
        for (let _i = 0, _a = type.types; _i < _a.length; _i++) {
            let t = _a[_i];
            if (!typeIdenticalToSomeType(t, typesToRemove)) {
                reducedTypes.push(t);
            }
        }
        return type.flags & 65536 /* Union */ ? getUnionType(reducedTypes) : getIntersectionType(reducedTypes);
    }
    function hasPrimitiveConstraint(type) {
        let constraint = getConstraintOfTypeParameter(type);
        return constraint && maybeTypeOfKind(constraint, 8190 /* Primitive */ | 262144 /* Index */);
    }
    function getInferredType(context, index) {
        let inference = context.inferences[index];
        let inferredType = inference.inferredType;
        if (!inferredType) {
            if (inference.candidates) {
                // We widen inferred literal types if
                // all inferences were made to top-level ocurrences of the type parameter, and
                // the type parameter has no constraint or its constraint includes no primitive or literal types, and
                // the type parameter was fixed during inference or does not occur at top-level in the return type.
                let signature = context.signature;
                let widenLiteralTypes = inference.topLevel &&
                    !hasPrimitiveConstraint(inference.typeParameter) &&
                    (inference.isFixed || !isTypeParameterAtTopLevel(getReturnTypeOfSignature(signature), inference.typeParameter));
                let baseCandidates = widenLiteralTypes ? ts.sameMap(inference.candidates, getWidenedLiteralType) : inference.candidates;
                // If all inferences were made from contravariant positions, infer a common subtype. Otherwise, if
                // union types were requested or if all inferences were made from the return type position, infer a
                // union type. Otherwise, infer a common supertype.
                let unwidenedType = inference.priority & 1 /* Contravariant */ ? getCommonSubtype(baseCandidates) :
                    context.flags & 1 /* InferUnionTypes */ || inference.priority & 8 /* ReturnType */ ? getUnionType(baseCandidates, /*subtypeReduction*/ true) :
                        getCommonSupertype(baseCandidates);
                inferredType = getWidenedType(unwidenedType);
            }
            else if (context.flags & 2 /* NoDefault */) {
                // We use silentNeverType as the wildcard that signals no inferences.
                inferredType = silentNeverType;
            }
            else {
                // Infer either the default or the empty object type when no inferences were
                // made. It is important to remember that in this case, inference still
                // succeeds, meaning there is no error for not having inference candidates. An
                // inference error only occurs when there are *conflicting* candidates, i.e.
                // candidates with no common supertype.
                let defaultType = getDefaultFromTypeParameter(inference.typeParameter);
                if (defaultType) {
                    // Instantiate the default type. Any forward reference to a type
                    // parameter should be instantiated to the empty object type.
                    inferredType = instantiateType(defaultType, combineTypeMappers(createBackreferenceMapper(context.signature.typeParameters, index), context));
                }
                else {
                    inferredType = getDefaultTypeArgumentType(!!(context.flags & 4 /* AnyDefault */));
                }
            }
            inference.inferredType = inferredType;
            let constraint = getConstraintOfTypeParameter(context.signature.typeParameters[index]);
            if (constraint) {
                let instantiatedConstraint = instantiateType(constraint, context);
                if (!context.compareTypes(inferredType, getTypeWithThisArgument(instantiatedConstraint, inferredType))) {
                    inference.inferredType = inferredType = instantiatedConstraint;
                }
            }
        }
        return inferredType;
    }
    function getDefaultTypeArgumentType(isInJavaScriptFile) {
        return isInJavaScriptFile ? anyType : emptyObjectType;
    }
    function getInferredTypes(context) {
        let result = [];
        for (let i = 0; i < context.inferences.length; i++) {
            result.push(getInferredType(context, i));
        }
        return result;
    }
    // EXPRESSION TYPE CHECKING
    function getResolvedSymbol(node) {
        let links = getNodeLinks(node);
        if (!links.resolvedSymbol) {
            links.resolvedSymbol = !ts.nodeIsMissing(node) &&
                resolveName(node, node.escapedText, SymbolFlags.Value | 1048576 /* ExportValue */, ts.Diagnostics.Cannot_find_name_0, node, !ts.isWriteOnlyAccess(node), ts.Diagnostics.Cannot_find_name_0_Did_you_mean_1) || unknownSymbol;
        }
        return links.resolvedSymbol;
    }
    function isInTypeQuery(node) {
        // TypeScript 1.0 spec (April 2014): 3.6.3
        // A type query consists of the keyword typeof followed by an expression.
        // The expression is restricted to a single identifier or a sequence of identifiers separated by periods
        return !!ts.findAncestor(node, function (n) { return n.kind === 162 /* TypeQuery */ ? true : n.kind === 71 /* Identifier */ || n.kind === 143 /* QualifiedName */ ? false : "quit"; });
    }
    // Return the flow cache key for a "dotted name" (i.e. a sequence of identifiers
    // separated by dots). The key consists of the id of the symbol referenced by the
    // leftmost identifier followed by zero or more property names separated by dots.
    // The result is undefined if the reference isn't a dotted name. We prefix nodes
    // occurring in an apparent type position with '@' because the control flow type
    // of such nodes may be based on the apparent type instead of the declared type.
    function getFlowCacheKey(node) {
        if (node.kind === 71 /* Identifier */) {
            let symbol = getResolvedSymbol(node);
            return symbol !== unknownSymbol ? (isApparentTypePosition(node) ? "@" : "") + getSymbolId(symbol) : undefined;
        }
        if (node.kind === 99 /* ThisKeyword */) {
            return "0";
        }
        if (node.kind === 179 /* PropertyAccessExpression */) {
            let key = getFlowCacheKey(node.expression);
            return key && key + "." + ts.idText(node.name);
        }
        if (node.kind === 176 /* BindingElement */) {
            let container = node.parent.parent;
            let key = container.kind === 176 /* BindingElement */ ? getFlowCacheKey(container) : (container.initializer && getFlowCacheKey(container.initializer));
            let text = getBindingElementNameText(node);
            let result = key && text && (key + "." + text);
            return result;
        }
        return undefined;
    }
    function getBindingElementNameText(element) {
        if (element.parent.kind === 174 /* ObjectBindingPattern */) {
            let name = element.propertyName || element.name;
            switch (name.kind) {
                case 71 /* Identifier */:
                    return ts.idText(name);
                case 144 /* ComputedPropertyName */:
                    return ts.isStringOrNumericLiteral(name.expression) ? name.expression.text : undefined;
                case 9 /* StringLiteral */:
                case 8 /* NumericLiteral */:
                    return name.text;
                default:
                    // Per types, array and object binding patterns remain, however they should never be present if propertyName is not defined
                    ts.Debug.fail("Unexpected name kind for binding element name");
            }
        }
        else {
            return "" + element.parent.elements.indexOf(element);
        }
    }
    function isMatchingReference(source, target) {
        switch (source.kind) {
            case 71 /* Identifier */:
                return target.kind === 71 /* Identifier */ && getResolvedSymbol(source) === getResolvedSymbol(target) ||
                    (target.kind === SyntaxKind.VariableDeclaration || target.kind === 176 /* BindingElement */) &&
                    getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(source)) === getSymbolOfNode(target);
            case 99 /* ThisKeyword */:
                return target.kind === 99 /* ThisKeyword */;
            case 97 /* SuperKeyword */:
                return target.kind === 97 /* SuperKeyword */;
            case 179 /* PropertyAccessExpression */:
                return target.kind === 179 /* PropertyAccessExpression */ &&
                    source.name.escapedText === target.name.escapedText &&
                    isMatchingReference(source.expression, target.expression);
            case 176 /* BindingElement */:
                if (target.kind !== 179 /* PropertyAccessExpression */)
                    return false;
                let t = target;
                if (t.name.escapedText !== getBindingElementNameText(source))
                    return false;
                if (source.parent.parent.kind === 176 /* BindingElement */ && isMatchingReference(source.parent.parent, t.expression)) {
                    return true;
                }
                if (source.parent.parent.kind === SyntaxKind.VariableDeclaration) {
                    let maybeId = source.parent.parent.initializer;
                    return maybeId && isMatchingReference(maybeId, t.expression);
                }
        }
        return false;
    }
    function containsMatchingReference(source, target) {
        while (source.kind === 179 /* PropertyAccessExpression */) {
            source = source.expression;
            if (isMatchingReference(source, target)) {
                return true;
            }
        }
        return false;
    }
    // Return true if target is a property access xxx.yyy, source is a property access xxx.zzz, the declared
    // type of xxx is a union type, and yyy is a property that is possibly a discriminant. We consider a property
    // a possible discriminant if its type differs in the constituents of containing union type, and if every
    // choice is a unit type or a union of unit types.
    function containsMatchingReferenceDiscriminant(source, target) {
        return target.kind === 179 /* PropertyAccessExpression */ &&
            containsMatchingReference(source, target.expression) &&
            isDiscriminantProperty(getDeclaredTypeOfReference(target.expression), target.name.escapedText);
    }
    function getDeclaredTypeOfReference(expr) {
        if (expr.kind === 71 /* Identifier */) {
            return getTypeOfSymbol(getResolvedSymbol(expr));
        }
        if (expr.kind === 179 /* PropertyAccessExpression */) {
            let type = getDeclaredTypeOfReference(expr.expression);
            return type && getTypeOfPropertyOfType(type, expr.name.escapedText);
        }
        return undefined;
    }
    function isDiscriminantProperty(type, name) {
        if (type && type.flags & 65536 /* Union */) {
            let prop = getUnionOrIntersectionProperty(type, name);
            if (prop && ts.getCheckFlags(prop) & 2 /* SyntheticProperty */) {
                if (prop.isDiscriminantProperty === undefined) {
                    prop.isDiscriminantProperty = prop.checkFlags & 32 /* HasNonUniformType */ && isLiteralType(getTypeOfSymbol(prop));
                }
                return prop.isDiscriminantProperty;
            }
        }
        return false;
    }
    function findSingleDiscriminantProperty(sourceProperties, target) {
        let result;
        for (let _i = 0, sourceProperties_2 = sourceProperties; _i < sourceProperties_2.length; _i++) {
            let sourceProperty = sourceProperties_2[_i];
            if (isDiscriminantProperty(target, sourceProperty.escapedName)) {
                if (result) {
                    return undefined;
                }
                result = sourceProperty;
            }
        }
        return result;
    }
    function isOrContainsMatchingReference(source, target) {
        return isMatchingReference(source, target) || containsMatchingReference(source, target);
    }
    function hasMatchingArgument(callExpression, reference) {
        if (callExpression.arguments) {
            for (let _i = 0, _a = callExpression.arguments; _i < _a.length; _i++) {
                let argument = _a[_i];
                if (isOrContainsMatchingReference(reference, argument)) {
                    return true;
                }
            }
        }
        if (callExpression.expression.kind === 179 /* PropertyAccessExpression */ &&
            isOrContainsMatchingReference(reference, callExpression.expression.expression)) {
            return true;
        }
        return false;
    }
    function getFlowNodeId(flow) {
        if (!flow.id) {
            flow.id = nextFlowId;
            nextFlowId++;
        }
        return flow.id;
    }
    function typeMaybeAssignableTo(source, target) {
        if (!(source.flags & 65536 /* Union */)) {
            return isTypeAssignableTo(source, target);
        }
        for (let _i = 0, _a = source.types; _i < _a.length; _i++) {
            let t = _a[_i];
            if (isTypeAssignableTo(t, target)) {
                return true;
            }
        }
        return false;
    }
    // Remove those constituent types of declaredType to which no constituent type of assignedType is assignable.
    // For example, when a variable of type number | string | boolean is assigned a value of type number | boolean,
    // we remove type string.
    function getAssignmentReducedType(declaredType, assignedType) {
        if (declaredType !== assignedType) {
            if (assignedType.flags & 8192 /* Never */) {
                return assignedType;
            }
            let reducedType = filterType(declaredType, function (t) { return typeMaybeAssignableTo(assignedType, t); });
            if (!(reducedType.flags & 8192 /* Never */)) {
                return reducedType;
            }
        }
        return declaredType;
    }
    function getTypeFactsOfTypes(types) {
        let result = 0 /* None */;
        for (let _i = 0, types_13 = types; _i < types_13.length; _i++) {
            let t = types_13[_i];
            result |= getTypeFacts(t);
        }
        return result;
    }
    function isFunctionObjectType(type) {
        // We do a quick check for a "bind" property before performing the more expensive subtype
        // check. This gives us a quicker out in the common case where an object type is not a function.
        let resolved = resolveStructuredTypeMembers(type);
        return !!(resolved.callSignatures.length || resolved.constructSignatures.length ||
            resolved.members.get("bind") && isTypeSubtypeOf(type, globalFunctionType));
    }
    function getTypeFacts(type) {
        let flags = type.flags;
        if (flags & 2 /* String */) {
            return strictNullChecks ? 4079361 /* StringStrictFacts */ : 4194049 /* StringFacts */;
        }
        if (flags & 32 /* StringLiteral */) {
            let isEmpty = type.value === "";
            return strictNullChecks ?
                isEmpty ? 3030785 /* EmptyStringStrictFacts */ : 1982209 /* NonEmptyStringStrictFacts */ :
                isEmpty ? 3145473 /* EmptyStringFacts */ : 4194049 /* NonEmptyStringFacts */;
        }
        if (flags & (4 /* Number */ | 16 /* Enum */)) {
            return strictNullChecks ? 4079234 /* NumberStrictFacts */ : 4193922 /* NumberFacts */;
        }
        if (flags & 64 /* NumberLiteral */) {
            let isZero = type.value === 0;
            return strictNullChecks ?
                isZero ? 3030658 /* ZeroStrictFacts */ : 1982082 /* NonZeroStrictFacts */ :
                isZero ? 3145346 /* ZeroFacts */ : 4193922 /* NonZeroFacts */;
        }
        if (flags & 8 /* Boolean */) {
            return strictNullChecks ? 4078980 /* BooleanStrictFacts */ : 4193668 /* BooleanFacts */;
        }
        if (flags & 136 /* BooleanLike */) {
            return strictNullChecks ?
                type === falseType ? 3030404 /* FalseStrictFacts */ : 1981828 /* TrueStrictFacts */ :
                type === falseType ? 3145092 /* FalseFacts */ : 4193668 /* TrueFacts */;
        }
        if (flags & TypeFlags.Object) {
            return isFunctionObjectType(type) ?
                strictNullChecks ? 6164448 /* FunctionStrictFacts */ : 8376288 /* FunctionFacts */ :
                strictNullChecks ? 6166480 /* ObjectStrictFacts */ : 8378320 /* ObjectFacts */;
        }
        if (flags & (1024 /* Void */ | 2048 /* Undefined */)) {
            return 2457472 /* UndefinedFacts */;
        }
        if (flags & 4096 /* Null */) {
            return 2340752 /* NullFacts */;
        }
        if (flags & 512 /* ESSymbol */) {
            return strictNullChecks ? 1981320 /* SymbolStrictFacts */ : 4193160 /* SymbolFacts */;
        }
        if (flags & 16777216 /* NonPrimitive */) {
            return strictNullChecks ? 6166480 /* ObjectStrictFacts */ : 8378320 /* ObjectFacts */;
        }
        if (flags & 540672 /* TypeVariable */) {
            return getTypeFacts(getBaseConstraintOfType(type) || emptyObjectType);
        }
        if (flags & 196608 /* UnionOrIntersection */) {
            return getTypeFactsOfTypes(type.types);
        }
        return 8388607 /* All */;
    }
    function getTypeWithFacts(type, include) {
        if (type.flags & 524288 /* IndexedAccess */) {
            // TODO (weswig): This is a substitute for a lazy negated type to remove the types indicated by the TypeFacts from the (potential) union the IndexedAccess refers to
            //  - See discussion in https://github.com/Microsoft/TypeScript/pull/19275 for details, and test `strictNullNotNullIndexTypeShouldWork` for current behavior
            let baseConstraint = getBaseConstraintOfType(type) || emptyObjectType;
            let result = filterType(baseConstraint, function (t) { return (getTypeFacts(t) & include) !== 0; });
            if (result !== baseConstraint) {
                return result;
            }
            return type;
        }
        return filterType(type, function (t) { return (getTypeFacts(t) & include) !== 0; });
    }
    function getTypeWithDefault(type, defaultExpression) {
        if (defaultExpression) {
            let defaultType = getTypeOfExpression(defaultExpression);
            return getUnionType([getTypeWithFacts(type, 131072 /* NEUndefined */), defaultType]);
        }
        return type;
    }
    function getTypeOfDestructuredProperty(type, name) {
        let text = ts.getTextOfPropertyName(name);
        return getTypeOfPropertyOfType(type, text) ||
            isNumericLiteralName(text) && getIndexTypeOfType(type, 1 /* Number */) ||
            getIndexTypeOfType(type, 0 /* String */) ||
            unknownType;
    }
    function getTypeOfDestructuredArrayElement(type, index) {
        return isTupleLikeType(type) && getTypeOfPropertyOfType(type, "" + index) ||
            checkIteratedTypeOrElementType(type, /*errorNode*/ undefined, /*allowStringInput*/ false, /*allowAsyncIterables*/ false) ||
            unknownType;
    }
    function getTypeOfDestructuredSpreadExpression(type) {
        return createArrayType(checkIteratedTypeOrElementType(type, /*errorNode*/ undefined, /*allowStringInput*/ false, /*allowAsyncIterables*/ false) || unknownType);
    }
    function getAssignedTypeOfBinaryExpression(node) {
        let isDestructuringDefaultAssignment = node.parent.kind === 177 /* ArrayLiteralExpression */ && isDestructuringAssignmentTarget(node.parent) ||
            node.parent.kind === 264 /* PropertyAssignment */ && isDestructuringAssignmentTarget(node.parent.parent);
        return isDestructuringDefaultAssignment ?
            getTypeWithDefault(getAssignedType(node), node.right) :
            getTypeOfExpression(node.right);
    }
    function isDestructuringAssignmentTarget(parent) {
        return parent.parent.kind === 194 /* BinaryExpression */ && parent.parent.left === parent ||
            parent.parent.kind === SyntaxKind.ForOfStatement && parent.parent.initializer === parent;
    }
    function getAssignedTypeOfArrayLiteralElement(node, element) {
        return getTypeOfDestructuredArrayElement(getAssignedType(node), ts.indexOf(node.elements, element));
    }
    function getAssignedTypeOfSpreadExpression(node) {
        return getTypeOfDestructuredSpreadExpression(getAssignedType(node.parent));
    }
    function getAssignedTypeOfPropertyAssignment(node) {
        return getTypeOfDestructuredProperty(getAssignedType(node.parent), node.name);
    }
    function getAssignedTypeOfShorthandPropertyAssignment(node) {
        return getTypeWithDefault(getAssignedTypeOfPropertyAssignment(node), node.objectAssignmentInitializer);
    }
    function getAssignedType(node) {
        let parent = node.parent;
        switch (parent.kind) {
            case 215 /* ForInStatement */:
                return stringType;
            case SyntaxKind.ForOfStatement:
                return checkRightHandSideOfForOf(parent.expression, parent.awaitModifier) || unknownType;
            case 194 /* BinaryExpression */:
                return getAssignedTypeOfBinaryExpression(parent);
            case 188 /* DeleteExpression */:
                return undefinedType;
            case 177 /* ArrayLiteralExpression */:
                return getAssignedTypeOfArrayLiteralElement(parent, node);
            case 198 /* SpreadElement */:
                return getAssignedTypeOfSpreadExpression(parent);
            case 264 /* PropertyAssignment */:
                return getAssignedTypeOfPropertyAssignment(parent);
            case 265 /* ShorthandPropertyAssignment */:
                return getAssignedTypeOfShorthandPropertyAssignment(parent);
        }
        return unknownType;
    }
    function getInitialTypeOfBindingElement(node) {
        let pattern = node.parent;
        let parentType = getInitialType(pattern.parent);
        let type = pattern.kind === 174 /* ObjectBindingPattern */ ?
            getTypeOfDestructuredProperty(parentType, node.propertyName || node.name) :
            !node.dotDotDotToken ?
                getTypeOfDestructuredArrayElement(parentType, ts.indexOf(pattern.elements, node)) :
                getTypeOfDestructuredSpreadExpression(parentType);
        return getTypeWithDefault(type, node.initializer);
    }
    function getTypeOfInitializer(node) {
        // Return the cached type if one is available. If the type of the variable was inferred
        // from its initializer, we'll already have cached the type. Otherwise we compute it now
        // without caching such that transient types are reflected.
        let links = getNodeLinks(node);
        return links.resolvedType || getTypeOfExpression(node);
    }
    function getInitialTypeOfVariableDeclaration(node) {
        if (node.initializer) {
            return getTypeOfInitializer(node.initializer);
        }
        if (node.parent.parent.kind === 215 /* ForInStatement */) {
            return stringType;
        }
        if (node.parent.parent.kind === SyntaxKind.ForOfStatement) {
            return checkRightHandSideOfForOf(node.parent.parent.expression, node.parent.parent.awaitModifier) || unknownType;
        }
        return unknownType;
    }
    function getInitialType(node) {
        return node.kind === SyntaxKind.VariableDeclaration ?
            getInitialTypeOfVariableDeclaration(node) :
            getInitialTypeOfBindingElement(node);
    }
    function getInitialOrAssignedType(node) {
        return node.kind === SyntaxKind.VariableDeclaration || node.kind === 176 /* BindingElement */ ?
            getInitialType(node) :
            getAssignedType(node);
    }
    function isEmptyArrayAssignment(node) {
        return node.kind === SyntaxKind.VariableDeclaration && node.initializer &&
            isEmptyArrayLiteral(node.initializer) ||
            node.kind !== 176 /* BindingElement */ && node.parent.kind === 194 /* BinaryExpression */ &&
            isEmptyArrayLiteral(node.parent.right);
    }
    function getReferenceCandidate(node) {
        switch (node.kind) {
            case 185 /* ParenthesizedExpression */:
                return getReferenceCandidate(node.expression);
            case 194 /* BinaryExpression */:
                switch (node.operatorToken.kind) {
                    case 58 /* EqualsToken */:
                        return getReferenceCandidate(node.left);
                    case 26 /* CommaToken */:
                        return getReferenceCandidate(node.right);
                }
        }
        return node;
    }
    function getReferenceRoot(node) {
        let parent = node.parent;
        return parent.kind === 185 /* ParenthesizedExpression */ ||
            parent.kind === 194 /* BinaryExpression */ && parent.operatorToken.kind === 58 /* EqualsToken */ && parent.left === node ||
            parent.kind === 194 /* BinaryExpression */ && parent.operatorToken.kind === 26 /* CommaToken */ && parent.right === node ?
            getReferenceRoot(parent) : node;
    }
    function getTypeOfSwitchClause(clause) {
        if (clause.kind === 260 /* CaseClause */) {
            let caseType = getRegularTypeOfLiteralType(getTypeOfExpression(clause.expression));
            return isUnitType(caseType) ? caseType : undefined;
        }
        return neverType;
    }
    function getSwitchClauseTypes(switchStatement) {
        let links = getNodeLinks(switchStatement);
        if (!links.switchTypes) {
            // If all case clauses specify expressions that have unit types, we return an array
            // of those unit types. Otherwise we return an empty array.
            links.switchTypes = [];
            for (let _i = 0, _a = switchStatement.caseBlock.clauses; _i < _a.length; _i++) {
                let clause = _a[_i];
                let type = getTypeOfSwitchClause(clause);
                if (type === undefined) {
                    return links.switchTypes = ts.emptyArray;
                }
                links.switchTypes.push(type);
            }
        }
        return links.switchTypes;
    }
    function eachTypeContainedIn(source, types) {
        return source.flags & 65536 /* Union */ ? !ts.forEach(source.types, function (t) { return !ts.contains(types, t); }) : ts.contains(types, source);
    }
    function isTypeSubsetOf(source, target) {
        return source === target || target.flags & 65536 /* Union */ && isTypeSubsetOfUnion(source, target);
    }
    function isTypeSubsetOfUnion(source, target) {
        if (source.flags & 65536 /* Union */) {
            for (let _i = 0, _a = source.types; _i < _a.length; _i++) {
                let t = _a[_i];
                if (!containsType(target.types, t)) {
                    return false;
                }
            }
            return true;
        }
        if (source.flags & 256 /* EnumLiteral */ && getBaseTypeOfEnumLiteralType(source) === target) {
            return true;
        }
        return containsType(target.types, source);
    }
    function forEachType(type, f) {
        return type.flags & 65536 /* Union */ ? ts.forEach(type.types, f) : f(type);
    }
    function filterType(type, f) {
        if (type.flags & 65536 /* Union */) {
            let types = type.types;
            let filtered = ts.filter(types, f);
            return filtered === types ? type : getUnionTypeFromSortedList(filtered);
        }
        return f(type) ? type : neverType;
    }
    // Apply a mapping function to a type and return the resulting type. If the source type
    // is a union type, the mapping function is applied to each constituent type and a union
    // of the resulting types is returned.
    function mapType(type, mapper) {
        if (!(type.flags & 65536 /* Union */)) {
            return mapper(type);
        }
        let types = type.types;
        let mappedType;
        let mappedTypes;
        for (let _i = 0, types_14 = types; _i < types_14.length; _i++) {
            let current = types_14[_i];
            let t = mapper(current);
            if (t) {
                if (!mappedType) {
                    mappedType = t;
                }
                else if (!mappedTypes) {
                    mappedTypes = [mappedType, t];
                }
                else {
                    mappedTypes.push(t);
                }
            }
        }
        return mappedTypes ? getUnionType(mappedTypes) : mappedType;
    }
    function extractTypesOfKind(type, kind) {
        return filterType(type, function (t) { return (t.flags & kind) !== 0; });
    }
    // Return a new type in which occurrences of the string and number primitive types in
    // typeWithPrimitives have been replaced with occurrences of string literals and numeric
    // literals in typeWithLiterals, respectively.
    function replacePrimitivesWithLiterals(typeWithPrimitives, typeWithLiterals) {
        if (isTypeSubsetOf(stringType, typeWithPrimitives) && maybeTypeOfKind(typeWithLiterals, 32 /* StringLiteral */) ||
            isTypeSubsetOf(numberType, typeWithPrimitives) && maybeTypeOfKind(typeWithLiterals, 64 /* NumberLiteral */)) {
            return mapType(typeWithPrimitives, function (t) {
                return t.flags & 2 /* String */ ? extractTypesOfKind(typeWithLiterals, 2 /* String */ | 32 /* StringLiteral */) :
                    t.flags & 4 /* Number */ ? extractTypesOfKind(typeWithLiterals, 4 /* Number */ | 64 /* NumberLiteral */) :
                        t;
            });
        }
        return typeWithPrimitives;
    }
    function isIncomplete(flowType) {
        return flowType.flags === 0;
    }
    function getTypeFromFlowType(flowType) {
        return flowType.flags === 0 ? flowType.type : flowType;
    }
    function createFlowType(type, incomplete) {
        return incomplete ? { flags: 0, type: type } : type;
    }
    // An evolving array type tracks the element types that have so far been seen in an
    // 'x.push(value)' or 'x[n] = value' operation along the control flow graph. Evolving
    // array types are ultimately converted into manifest array types (using getFinalArrayType)
    // and never escape the getFlowTypeOfReference function.
    function createEvolvingArrayType(elementType) {
        let result = createObjectType(256 /* EvolvingArray */);
        result.elementType = elementType;
        return result;
    }
    function getEvolvingArrayType(elementType) {
        return evolvingArrayTypes[elementType.id] || (evolvingArrayTypes[elementType.id] = createEvolvingArrayType(elementType));
    }
    // When adding evolving array element types we do not perform subtype reduction. Instead,
    // we defer subtype reduction until the evolving array type is finalized into a manifest
    // array type.
    function addEvolvingArrayElementType(evolvingArrayType, node) {
        let elementType = getBaseTypeOfLiteralType(getContextFreeTypeOfExpression(node));
        return isTypeSubsetOf(elementType, evolvingArrayType.elementType) ? evolvingArrayType : getEvolvingArrayType(getUnionType([evolvingArrayType.elementType, elementType]));
    }
    function createFinalArrayType(elementType) {
        return elementType.flags & 8192 /* Never */ ?
            autoArrayType :
            createArrayType(elementType.flags & 65536 /* Union */ ?
                getUnionType(elementType.types, /*subtypeReduction*/ true) :
                elementType);
    }
    // We perform subtype reduction upon obtaining the final array type from an evolving array type.
    function getFinalArrayType(evolvingArrayType) {
        return evolvingArrayType.finalArrayType || (evolvingArrayType.finalArrayType = createFinalArrayType(evolvingArrayType.elementType));
    }
    function finalizeEvolvingArrayType(type) {
        return getObjectFlags(type) & 256 /* EvolvingArray */ ? getFinalArrayType(type) : type;
    }
    function getElementTypeOfEvolvingArrayType(type) {
        return getObjectFlags(type) & 256 /* EvolvingArray */ ? type.elementType : neverType;
    }
    function isEvolvingArrayTypeList(types) {
        let hasEvolvingArrayType = false;
        for (let _i = 0, types_15 = types; _i < types_15.length; _i++) {
            let t = types_15[_i];
            if (!(t.flags & 8192 /* Never */)) {
                if (!(getObjectFlags(t) & 256 /* EvolvingArray */)) {
                    return false;
                }
                hasEvolvingArrayType = true;
            }
        }
        return hasEvolvingArrayType;
    }
    // At flow control branch or loop junctions, if the type along every antecedent code path
    // is an evolving array type, we construct a combined evolving array type. Otherwise we
    // finalize all evolving array types.
    function getUnionOrEvolvingArrayType(types, subtypeReduction) {
        return isEvolvingArrayTypeList(types) ?
            getEvolvingArrayType(getUnionType(ts.map(types, getElementTypeOfEvolvingArrayType))) :
            getUnionType(ts.sameMap(types, finalizeEvolvingArrayType), subtypeReduction);
    }
    // Return true if the given node is 'x' in an 'x.length', x.push(value)', 'x.unshift(value)' or
    // 'x[n] = value' operation, where 'n' is an expression of type any, undefined, or a number-like type.
    function isEvolvingArrayOperationTarget(node) {
        let root = getReferenceRoot(node);
        let parent = root.parent;
        let isLengthPushOrUnshift = parent.kind === 179 /* PropertyAccessExpression */ && (parent.name.escapedText === "length" ||
            parent.parent.kind === 181 /* CallExpression */ && ts.isPushOrUnshiftIdentifier(parent.name));
        let isElementAssignment = parent.kind === 180 /* ElementAccessExpression */ &&
            parent.expression === root &&
            parent.parent.kind === 194 /* BinaryExpression */ &&
            parent.parent.operatorToken.kind === 58 /* EqualsToken */ &&
            parent.parent.left === parent &&
            !ts.isAssignmentTarget(parent.parent) &&
            isTypeAssignableToKind(getTypeOfExpression(parent.argumentExpression), 84 /* NumberLike */);
        return isLengthPushOrUnshift || isElementAssignment;
    }
    function maybeTypePredicateCall(node) {
        let links = getNodeLinks(node);
        if (links.maybeTypePredicate === undefined) {
            links.maybeTypePredicate = getMaybeTypePredicate(node);
        }
        return links.maybeTypePredicate;
    }
    function getMaybeTypePredicate(node) {
        if (node.expression.kind !== 97 /* SuperKeyword */) {
            let funcType = checkNonNullExpression(node.expression);
            if (funcType !== silentNeverType) {
                let apparentType = getApparentType(funcType);
                if (apparentType !== unknownType) {
                    let callSignatures = getSignaturesOfType(apparentType, 0 /* Call */);
                    return !!ts.forEach(callSignatures, function (sig) { return sig.typePredicate; });
                }
            }
        }
        return false;
    }
    function reportFlowControlError(node) {
        let block = ts.findAncestor(node, ts.isFunctionOrModuleBlock);
        let sourceFile = ts.getSourceFileOfNode(node);
        let span = ts.getSpanOfTokenAtPosition(sourceFile, block.statements.pos);
        diagnostics.add(ts.createFileDiagnostic(sourceFile, span.start, span.length, ts.Diagnostics.The_containing_function_or_module_body_is_too_large_for_control_flow_analysis));
    }
    function getFlowTypeOfReference(reference, declaredType, initialType, flowContainer, couldBeUninitialized) {
        if (initialType === void 0) { initialType = declaredType; }
        let key;
        let flowDepth = 0;
        if (flowAnalysisDisabled) {
            return unknownType;
        }
        if (!reference.flowNode || !couldBeUninitialized && !(declaredType.flags & 17810175 /* Narrowable */)) {
            return declaredType;
        }
        let sharedFlowStart = sharedFlowCount;
        let evolvedType = getTypeFromFlowType(getTypeAtFlowNode(reference.flowNode));
        sharedFlowCount = sharedFlowStart;
        // When the reference is 'x' in an 'x.length', 'x.push(value)', 'x.unshift(value)' or x[n] = value' operation,
        // we give type 'any[]' to 'x' instead of using the type determined by control flow analysis such that operations
        // on empty arrays are possible without implicit any errors and new element types can be inferred without
        // type mismatch errors.
        let resultType = getObjectFlags(evolvedType) & 256 /* EvolvingArray */ && isEvolvingArrayOperationTarget(reference) ? anyArrayType : finalizeEvolvingArrayType(evolvedType);
        if (reference.parent.kind === 203 /* NonNullExpression */ && getTypeWithFacts(resultType, 524288 /* NEUndefinedOrNull */).flags & 8192 /* Never */) {
            return declaredType;
        }
        return resultType;
        function getTypeAtFlowNode(flow) {
            if (flowDepth === 2500) {
                // We have made 2500 recursive invocations. To avoid overflowing the call stack we report an error
                // and disable further control flow analysis in the containing function or module body.
                flowAnalysisDisabled = true;
                reportFlowControlError(reference);
                return unknownType;
            }
            flowDepth++;
            while (true) {
                let flags = flow.flags;
                if (flags & 1024 /* Shared */) {
                    // We cache results of flow type resolution for shared nodes that were previously visited in
                    // the same getFlowTypeOfReference invocation. A node is considered shared when it is the
                    // antecedent of more than one node.
                    for (let i = sharedFlowStart; i < sharedFlowCount; i++) {
                        if (sharedFlowNodes[i] === flow) {
                            flowDepth--;
                            return sharedFlowTypes[i];
                        }
                    }
                }
                let type = void 0;
                if (flags & 4096 /* AfterFinally */) {
                    // block flow edge: finally -> pre-try (for larger explanation check comment in binder.ts - bindTryStatement
                    flow.locked = true;
                    type = getTypeAtFlowNode(flow.antecedent);
                    flow.locked = false;
                }
                else if (flags & 2048 /* PreFinally */) {
                    // locked pre-finally flows are filtered out in getTypeAtFlowBranchLabel
                    // so here just redirect to antecedent
                    flow = flow.antecedent;
                    continue;
                }
                else if (flags & 16 /* Assignment */) {
                    type = getTypeAtFlowAssignment(flow);
                    if (!type) {
                        flow = flow.antecedent;
                        continue;
                    }
                }
                else if (flags & 96 /* Condition */) {
                    type = getTypeAtFlowCondition(flow);
                }
                else if (flags & 128 /* SwitchClause */) {
                    type = getTypeAtSwitchClause(flow);
                }
                else if (flags & 12 /* Label */) {
                    if (flow.antecedents.length === 1) {
                        flow = flow.antecedents[0];
                        continue;
                    }
                    type = flags & 4 /* BranchLabel */ ?
                        getTypeAtFlowBranchLabel(flow) :
                        getTypeAtFlowLoopLabel(flow);
                }
                else if (flags & 256 /* ArrayMutation */) {
                    type = getTypeAtFlowArrayMutation(flow);
                    if (!type) {
                        flow = flow.antecedent;
                        continue;
                    }
                }
                else if (flags & 2 /* Start */) {
                    // Check if we should continue with the control flow of the containing function.
                    let container = flow.container;
                    if (container && container !== flowContainer && reference.kind !== 179 /* PropertyAccessExpression */ && reference.kind !== 99 /* ThisKeyword */) {
                        flow = container.flowNode;
                        continue;
                    }
                    // At the top of the flow we have the initial type.
                    type = initialType;
                }
                else {
                    // Unreachable code errors are reported in the binding phase. Here we
                    // simply return the non-auto declared type to reduce follow-on errors.
                    type = convertAutoToAny(declaredType);
                }
                if (flags & 1024 /* Shared */) {
                    // Record visited node and the associated type in the cache.
                    sharedFlowNodes[sharedFlowCount] = flow;
                    sharedFlowTypes[sharedFlowCount] = type;
                    sharedFlowCount++;
                }
                flowDepth--;
                return type;
            }
        }
        function getTypeAtFlowAssignment(flow) {
            let node = flow.node;
            // Assignments only narrow the computed type if the declared type is a union type. Thus, we
            // only need to evaluate the assigned type if the declared type is a union type.
            if (isMatchingReference(reference, node)) {
                if (ts.getAssignmentTargetKind(node) === 2 /* Compound */) {
                    let flowType = getTypeAtFlowNode(flow.antecedent);
                    return createFlowType(getBaseTypeOfLiteralType(getTypeFromFlowType(flowType)), isIncomplete(flowType));
                }
                if (declaredType === autoType || declaredType === autoArrayType) {
                    if (isEmptyArrayAssignment(node)) {
                        return getEvolvingArrayType(neverType);
                    }
                    let assignedType = getBaseTypeOfLiteralType(getInitialOrAssignedType(node));
                    return isTypeAssignableTo(assignedType, declaredType) ? assignedType : anyArrayType;
                }
                if (declaredType.flags & 65536 /* Union */) {
                    return getAssignmentReducedType(declaredType, getInitialOrAssignedType(node));
                }
                return declaredType;
            }
            // We didn't have a direct match. However, if the reference is a dotted name, this
            // may be an assignment to a left hand part of the reference. For example, for a
            // reference 'x.y.z', we may be at an assignment to 'x.y' or 'x'. In that case,
            // return the declared type.
            if (containsMatchingReference(reference, node)) {
                return declaredType;
            }
            // Assignment doesn't affect reference
            return undefined;
        }
        function getTypeAtFlowArrayMutation(flow) {
            if (declaredType === autoType || declaredType === autoArrayType) {
                let node = flow.node;
                let expr = node.kind === 181 /* CallExpression */ ?
                    node.expression.expression :
                    node.left.expression;
                if (isMatchingReference(reference, getReferenceCandidate(expr))) {
                    let flowType = getTypeAtFlowNode(flow.antecedent);
                    let type = getTypeFromFlowType(flowType);
                    if (getObjectFlags(type) & 256 /* EvolvingArray */) {
                        let evolvedType_1 = type;
                        if (node.kind === 181 /* CallExpression */) {
                            for (let _i = 0, _a = node.arguments; _i < _a.length; _i++) {
                                let arg = _a[_i];
                                evolvedType_1 = addEvolvingArrayElementType(evolvedType_1, arg);
                            }
                        }
                        else {
                            let indexType = getTypeOfExpression(node.left.argumentExpression);
                            if (isTypeAssignableToKind(indexType, 84 /* NumberLike */)) {
                                evolvedType_1 = addEvolvingArrayElementType(evolvedType_1, node.right);
                            }
                        }
                        return evolvedType_1 === type ? flowType : createFlowType(evolvedType_1, isIncomplete(flowType));
                    }
                    return flowType;
                }
            }
            return undefined;
        }
        function getTypeAtFlowCondition(flow) {
            let flowType = getTypeAtFlowNode(flow.antecedent);
            let type = getTypeFromFlowType(flowType);
            if (type.flags & 8192 /* Never */) {
                return flowType;
            }
            // If we have an antecedent type (meaning we're reachable in some way), we first
            // attempt to narrow the antecedent type. If that produces the never type, and if
            // the antecedent type is incomplete (i.e. a transient type in a loop), then we
            // take the type guard as an indication that control *could* reach here once we
            // have the complete type. We proceed by switching to the silent never type which
            // doesn't report errors when operators are applied to it. Note that this is the
            // *only* place a silent never type is ever generated.
            let assumeTrue = (flow.flags & 32 /* TrueCondition */) !== 0;
            let nonEvolvingType = finalizeEvolvingArrayType(type);
            let narrowedType = narrowType(nonEvolvingType, flow.expression, assumeTrue);
            if (narrowedType === nonEvolvingType) {
                return flowType;
            }
            let incomplete = isIncomplete(flowType);
            let resultType = incomplete && narrowedType.flags & 8192 /* Never */ ? silentNeverType : narrowedType;
            return createFlowType(resultType, incomplete);
        }
        function getTypeAtSwitchClause(flow) {
            let flowType = getTypeAtFlowNode(flow.antecedent);
            let type = getTypeFromFlowType(flowType);
            let expr = flow.switchStatement.expression;
            if (isMatchingReference(reference, expr)) {
                type = narrowTypeBySwitchOnDiscriminant(type, flow.switchStatement, flow.clauseStart, flow.clauseEnd);
            }
            else if (isMatchingReferenceDiscriminant(expr, type)) {
                type = narrowTypeByDiscriminant(type, expr, function (t) { return narrowTypeBySwitchOnDiscriminant(t, flow.switchStatement, flow.clauseStart, flow.clauseEnd); });
            }
            return createFlowType(type, isIncomplete(flowType));
        }
        function getTypeAtFlowBranchLabel(flow) {
            let antecedentTypes = [];
            let subtypeReduction = false;
            let seenIncomplete = false;
            for (let _i = 0, _a = flow.antecedents; _i < _a.length; _i++) {
                let antecedent = _a[_i];
                if (antecedent.flags & 2048 /* PreFinally */ && antecedent.lock.locked) {
                    // if flow correspond to branch from pre-try to finally and this branch is locked - this means that
                    // we initially have started following the flow outside the finally block.
                    // in this case we should ignore this branch.
                    continue;
                }
                let flowType = getTypeAtFlowNode(antecedent);
                let type = getTypeFromFlowType(flowType);
                // If the type at a particular antecedent path is the declared type and the
                // reference is known to always be assigned (i.e. when declared and initial types
                // are the same), there is no reason to process more antecedents since the only
                // possible outcome is subtypes that will be removed in the final union type anyway.
                if (type === declaredType && declaredType === initialType) {
                    return type;
                }
                ts.pushIfUnique(antecedentTypes, type);
                // If an antecedent type is not a subset of the declared type, we need to perform
                // subtype reduction. This happens when a "foreign" type is injected into the control
                // flow using the instanceof operator or a user defined type predicate.
                if (!isTypeSubsetOf(type, declaredType)) {
                    subtypeReduction = true;
                }
                if (isIncomplete(flowType)) {
                    seenIncomplete = true;
                }
            }
            return createFlowType(getUnionOrEvolvingArrayType(antecedentTypes, subtypeReduction), seenIncomplete);
        }
        function getTypeAtFlowLoopLabel(flow) {
            // If we have previously computed the control flow type for the reference at
            // this flow loop junction, return the cached type.
            let id = getFlowNodeId(flow);
            let cache = flowLoopCaches[id] || (flowLoopCaches[id] = ts.createMap());
            if (!key) {
                key = getFlowCacheKey(reference);
                // No cache key is generated when binding patterns are in unnarrowable situations
                if (!key) {
                    return declaredType;
                }
            }
            let cached = cache.get(key);
            if (cached) {
                return cached;
            }
            // If this flow loop junction and reference are already being processed, return
            // the union of the types computed for each branch so far, marked as incomplete.
            // It is possible to see an empty array in cases where loops are nested and the
            // back edge of the outer loop reaches an inner loop that is already being analyzed.
            // In such cases we restart the analysis of the inner loop, which will then see
            // a non-empty in-process array for the outer loop and eventually terminate because
            // the first antecedent of a loop junction is always the non-looping control flow
            // path that leads to the top.
            for (let i = flowLoopStart; i < flowLoopCount; i++) {
                if (flowLoopNodes[i] === flow && flowLoopKeys[i] === key && flowLoopTypes[i].length) {
                    return createFlowType(getUnionOrEvolvingArrayType(flowLoopTypes[i], /*subtypeReduction*/ false), /*incomplete*/ true);
                }
            }
            // Add the flow loop junction and reference to the in-process stack and analyze
            // each antecedent code path.
            let antecedentTypes = [];
            let subtypeReduction = false;
            let firstAntecedentType;
            flowLoopNodes[flowLoopCount] = flow;
            flowLoopKeys[flowLoopCount] = key;
            flowLoopTypes[flowLoopCount] = antecedentTypes;
            for (let _i = 0, _a = flow.antecedents; _i < _a.length; _i++) {
                let antecedent = _a[_i];
                flowLoopCount++;
                let flowType = getTypeAtFlowNode(antecedent);
                flowLoopCount--;
                if (!firstAntecedentType) {
                    firstAntecedentType = flowType;
                }
                let type = getTypeFromFlowType(flowType);
                // If we see a value appear in the cache it is a sign that control flow  analysis
                // was restarted and completed by checkExpressionCached. We can simply pick up
                // the resulting type and bail out.
                let cached_1 = cache.get(key);
                if (cached_1) {
                    return cached_1;
                }
                ts.pushIfUnique(antecedentTypes, type);
                // If an antecedent type is not a subset of the declared type, we need to perform
                // subtype reduction. This happens when a "foreign" type is injected into the control
                // flow using the instanceof operator or a user defined type predicate.
                if (!isTypeSubsetOf(type, declaredType)) {
                    subtypeReduction = true;
                }
                // If the type at a particular antecedent path is the declared type there is no
                // reason to process more antecedents since the only possible outcome is subtypes
                // that will be removed in the final union type anyway.
                if (type === declaredType) {
                    break;
                }
            }
            // The result is incomplete if the first antecedent (the non-looping control flow path)
            // is incomplete.
            let result = getUnionOrEvolvingArrayType(antecedentTypes, subtypeReduction);
            if (isIncomplete(firstAntecedentType)) {
                return createFlowType(result, /*incomplete*/ true);
            }
            cache.set(key, result);
            return result;
        }
        function isMatchingReferenceDiscriminant(expr, computedType) {
            return expr.kind === 179 /* PropertyAccessExpression */ &&
                computedType.flags & 65536 /* Union */ &&
                isMatchingReference(reference, expr.expression) &&
                isDiscriminantProperty(computedType, expr.name.escapedText);
        }
        function narrowTypeByDiscriminant(type, propAccess, narrowType) {
            let propName = propAccess.name.escapedText;
            let propType = getTypeOfPropertyOfType(type, propName);
            let narrowedPropType = propType && narrowType(propType);
            return propType === narrowedPropType ? type : filterType(type, function (t) { return isTypeComparableTo(getTypeOfPropertyOfType(t, propName), narrowedPropType); });
        }
        function narrowTypeByTruthiness(type, expr, assumeTrue) {
            if (isMatchingReference(reference, expr)) {
                return getTypeWithFacts(type, assumeTrue ? 1048576 /* Truthy */ : 2097152 /* Falsy */);
            }
            if (isMatchingReferenceDiscriminant(expr, declaredType)) {
                return narrowTypeByDiscriminant(type, expr, function (t) { return getTypeWithFacts(t, assumeTrue ? 1048576 /* Truthy */ : 2097152 /* Falsy */); });
            }
            if (containsMatchingReferenceDiscriminant(reference, expr)) {
                return declaredType;
            }
            return type;
        }
        function narrowTypeByBinaryExpression(type, expr, assumeTrue) {
            switch (expr.operatorToken.kind) {
                case 58 /* EqualsToken */:
                    return narrowTypeByTruthiness(type, expr.left, assumeTrue);
                case 32 /* EqualsEqualsToken */:
                case 33 /* ExclamationEqualsToken */:
                case 34 /* EqualsEqualsEqualsToken */:
                case 35 /* ExclamationEqualsEqualsToken */:
                    let operator_1 = expr.operatorToken.kind;
                    let left_1 = getReferenceCandidate(expr.left);
                    let right_1 = getReferenceCandidate(expr.right);
                    if (left_1.kind === 189 /* TypeOfExpression */ && right_1.kind === 9 /* StringLiteral */) {
                        return narrowTypeByTypeof(type, left_1, operator_1, right_1, assumeTrue);
                    }
                    if (right_1.kind === 189 /* TypeOfExpression */ && left_1.kind === 9 /* StringLiteral */) {
                        return narrowTypeByTypeof(type, right_1, operator_1, left_1, assumeTrue);
                    }
                    if (isMatchingReference(reference, left_1)) {
                        return narrowTypeByEquality(type, operator_1, right_1, assumeTrue);
                    }
                    if (isMatchingReference(reference, right_1)) {
                        return narrowTypeByEquality(type, operator_1, left_1, assumeTrue);
                    }
                    if (isMatchingReferenceDiscriminant(left_1, declaredType)) {
                        return narrowTypeByDiscriminant(type, left_1, function (t) { return narrowTypeByEquality(t, operator_1, right_1, assumeTrue); });
                    }
                    if (isMatchingReferenceDiscriminant(right_1, declaredType)) {
                        return narrowTypeByDiscriminant(type, right_1, function (t) { return narrowTypeByEquality(t, operator_1, left_1, assumeTrue); });
                    }
                    if (containsMatchingReferenceDiscriminant(reference, left_1) || containsMatchingReferenceDiscriminant(reference, right_1)) {
                        return declaredType;
                    }
                    break;
                case 93 /* InstanceOfKeyword */:
                    return narrowTypeByInstanceof(type, expr, assumeTrue);
                case 26 /* CommaToken */:
                    return narrowType(type, expr.right, assumeTrue);
            }
            return type;
        }
        function narrowTypeByEquality(type, operator, value, assumeTrue) {
            if (type.flags & 1 /* Any */) {
                return type;
            }
            if (operator === 33 /* ExclamationEqualsToken */ || operator === 35 /* ExclamationEqualsEqualsToken */) {
                assumeTrue = !assumeTrue;
            }
            let valueType = getTypeOfExpression(value);
            if (valueType.flags & 6144 /* Nullable */) {
                if (!strictNullChecks) {
                    return type;
                }
                let doubleEquals = operator === 32 /* EqualsEqualsToken */ || operator === 33 /* ExclamationEqualsToken */;
                let facts = doubleEquals ?
                    assumeTrue ? 65536 /* EQUndefinedOrNull */ : 524288 /* NEUndefinedOrNull */ :
                    value.kind === 95 /* NullKeyword */ ?
                        assumeTrue ? 32768 /* EQNull */ : 262144 /* NENull */ :
                        assumeTrue ? 16384 /* EQUndefined */ : 131072 /* NEUndefined */;
                return getTypeWithFacts(type, facts);
            }
            if (type.flags & 16810497 /* NotUnionOrUnit */) {
                return type;
            }
            if (assumeTrue) {
                let narrowedType = filterType(type, function (t) { return areTypesComparable(t, valueType); });
                return narrowedType.flags & 8192 /* Never */ ? type : replacePrimitivesWithLiterals(narrowedType, valueType);
            }
            if (isUnitType(valueType)) {
                let regularType_1 = getRegularTypeOfLiteralType(valueType);
                return filterType(type, function (t) { return getRegularTypeOfLiteralType(t) !== regularType_1; });
            }
            return type;
        }
        function narrowTypeByTypeof(type, typeOfExpr, operator, literal, assumeTrue) {
            // We have '==', '!=', '====', or !==' operator with 'typeof xxx' and string literal operands
            let target = getReferenceCandidate(typeOfExpr.expression);
            if (!isMatchingReference(reference, target)) {
                // For a reference of the form 'x.y', a 'typeof x === ...' type guard resets the
                // narrowed type of 'y' to its declared type.
                if (containsMatchingReference(reference, target)) {
                    return declaredType;
                }
                return type;
            }
            if (operator === 33 /* ExclamationEqualsToken */ || operator === 35 /* ExclamationEqualsEqualsToken */) {
                assumeTrue = !assumeTrue;
            }
            if (assumeTrue && !(type.flags & 65536 /* Union */)) {
                // We narrow a non-union type to an exact primitive type if the non-union type
                // is a supertype of that primitive type. For example, type 'any' can be narrowed
                // to one of the primitive types.
                let targetType = typeofTypesByName.get(literal.text);
                if (targetType) {
                    if (isTypeSubtypeOf(targetType, type)) {
                        return targetType;
                    }
                    if (type.flags & 540672 /* TypeVariable */) {
                        let constraint = getBaseConstraintOfType(type) || anyType;
                        if (isTypeSubtypeOf(targetType, constraint)) {
                            return getIntersectionType([type, targetType]);
                        }
                    }
                }
            }
            let facts = assumeTrue ?
                typeofEQFacts.get(literal.text) || 64 /* TypeofEQHostObject */ :
                typeofNEFacts.get(literal.text) || 8192 /* TypeofNEHostObject */;
            return getTypeWithFacts(type, facts);
        }
        function narrowTypeBySwitchOnDiscriminant(type, switchStatement, clauseStart, clauseEnd) {
            // We only narrow if all case expressions specify values with unit types
            let switchTypes = getSwitchClauseTypes(switchStatement);
            if (!switchTypes.length) {
                return type;
            }
            let clauseTypes = switchTypes.slice(clauseStart, clauseEnd);
            let hasDefaultClause = clauseStart === clauseEnd || ts.contains(clauseTypes, neverType);
            let discriminantType = getUnionType(clauseTypes);
            let caseType = discriminantType.flags & 8192 /* Never */ ? neverType :
                replacePrimitivesWithLiterals(filterType(type, function (t) { return isTypeComparableTo(discriminantType, t); }), discriminantType);
            if (!hasDefaultClause) {
                return caseType;
            }
            let defaultType = filterType(type, function (t) { return !(isUnitType(t) && ts.contains(switchTypes, getRegularTypeOfLiteralType(t))); });
            return caseType.flags & 8192 /* Never */ ? defaultType : getUnionType([caseType, defaultType]);
        }
        function narrowTypeByInstanceof(type, expr, assumeTrue) {
            let left = getReferenceCandidate(expr.left);
            if (!isMatchingReference(reference, left)) {
                // For a reference of the form 'x.y', an 'x instanceof T' type guard resets the
                // narrowed type of 'y' to its declared type.
                if (containsMatchingReference(reference, left)) {
                    return declaredType;
                }
                return type;
            }
            // Check that right operand is a function type with a prototype property
            let rightType = getTypeOfExpression(expr.right);
            if (!isTypeSubtypeOf(rightType, globalFunctionType)) {
                return type;
            }
            let targetType;
            let prototypeProperty = getPropertyOfType(rightType, "prototype");
            if (prototypeProperty) {
                // Target type is type of the prototype property
                let prototypePropertyType = getTypeOfSymbol(prototypeProperty);
                if (!isTypeAny(prototypePropertyType)) {
                    targetType = prototypePropertyType;
                }
            }
            // Don't narrow from 'any' if the target type is exactly 'Object' or 'Function'
            if (isTypeAny(type) && (targetType === globalObjectType || targetType === globalFunctionType)) {
                return type;
            }
            if (!targetType) {
                // Target type is type of construct signature
                let constructSignatures = void 0;
                if (getObjectFlags(rightType) & 2 /* Interface */) {
                    constructSignatures = resolveDeclaredMembers(rightType).declaredConstructSignatures;
                }
                else if (getObjectFlags(rightType) & 16 /* Anonymous */) {
                    constructSignatures = getSignaturesOfType(rightType, 1 /* Construct */);
                }
                if (constructSignatures && constructSignatures.length) {
                    targetType = getUnionType(ts.map(constructSignatures, function (signature) { return getReturnTypeOfSignature(getErasedSignature(signature)); }));
                }
            }
            if (targetType) {
                return getNarrowedType(type, targetType, assumeTrue, isTypeInstanceOf);
            }
            return type;
        }
        function getNarrowedType(type, candidate, assumeTrue, isRelated) {
            if (!assumeTrue) {
                return filterType(type, function (t) { return !isRelated(t, candidate); });
            }
            // If the current type is a union type, remove all constituents that couldn't be instances of
            // the candidate type. If one or more constituents remain, return a union of those.
            if (type.flags & 65536 /* Union */) {
                let assignableType = filterType(type, function (t) { return isRelated(t, candidate); });
                if (!(assignableType.flags & 8192 /* Never */)) {
                    return assignableType;
                }
            }
            // If the candidate type is a subtype of the target type, narrow to the candidate type.
            // Otherwise, if the target type is assignable to the candidate type, keep the target type.
            // Otherwise, if the candidate type is assignable to the target type, narrow to the candidate
            // type. Otherwise, the types are completely unrelated, so narrow to an intersection of the
            // two types.
            return isTypeSubtypeOf(candidate, type) ? candidate :
                isTypeAssignableTo(type, candidate) ? type :
                    isTypeAssignableTo(candidate, type) ? candidate :
                        getIntersectionType([type, candidate]);
        }
        function narrowTypeByTypePredicate(type, callExpression, assumeTrue) {
            if (!hasMatchingArgument(callExpression, reference) || !maybeTypePredicateCall(callExpression)) {
                return type;
            }
            let signature = getResolvedSignature(callExpression);
            let predicate = signature.typePredicate;
            if (!predicate) {
                return type;
            }
            // Don't narrow from 'any' if the predicate type is exactly 'Object' or 'Function'
            if (isTypeAny(type) && (predicate.type === globalObjectType || predicate.type === globalFunctionType)) {
                return type;
            }
            if (ts.isIdentifierTypePredicate(predicate)) {
                let predicateArgument = callExpression.arguments[predicate.parameterIndex - (signature.thisParameter ? 1 : 0)];
                if (predicateArgument) {
                    if (isMatchingReference(reference, predicateArgument)) {
                        return getNarrowedType(type, predicate.type, assumeTrue, isTypeSubtypeOf);
                    }
                    if (containsMatchingReference(reference, predicateArgument)) {
                        return declaredType;
                    }
                }
            }
            else {
                let invokedExpression = ts.skipParentheses(callExpression.expression);
                if (invokedExpression.kind === 180 /* ElementAccessExpression */ || invokedExpression.kind === 179 /* PropertyAccessExpression */) {
                    let accessExpression = invokedExpression;
                    let possibleReference = ts.skipParentheses(accessExpression.expression);
                    if (isMatchingReference(reference, possibleReference)) {
                        return getNarrowedType(type, predicate.type, assumeTrue, isTypeSubtypeOf);
                    }
                    if (containsMatchingReference(reference, possibleReference)) {
                        return declaredType;
                    }
                }
            }
            return type;
        }
        // Narrow the given type based on the given expression having the assumed boolean value. The returned type
        // will be a subtype or the same type as the argument.
        function narrowType(type, expr, assumeTrue) {
            switch (expr.kind) {
                case 71 /* Identifier */:
                case 99 /* ThisKeyword */:
                case 97 /* SuperKeyword */:
                case 179 /* PropertyAccessExpression */:
                    return narrowTypeByTruthiness(type, expr, assumeTrue);
                case 181 /* CallExpression */:
                    return narrowTypeByTypePredicate(type, expr, assumeTrue);
                case 185 /* ParenthesizedExpression */:
                    return narrowType(type, expr.expression, assumeTrue);
                case 194 /* BinaryExpression */:
                    return narrowTypeByBinaryExpression(type, expr, assumeTrue);
                case 192 /* PrefixUnaryExpression */:
                    if (expr.operator === 51 /* ExclamationToken */) {
                        return narrowType(type, expr.operand, !assumeTrue);
                    }
                    break;
            }
            return type;
        }
    }
    function getTypeOfSymbolAtLocation(symbol, location) {
        symbol = symbol.exportSymbol || symbol;
        // If we have an identifier or a property access at the given location, if the location is
        // an dotted name expression, and if the location is not an assignment target, obtain the type
        // of the expression (which will reflect control flow analysis). If the expression indeed
        // resolved to the given symbol, return the narrowed type.
        if (location.kind === 71 /* Identifier */) {
            if (ts.isRightSideOfQualifiedNameOrPropertyAccess(location)) {
                location = location.parent;
            }
            if (ts.isPartOfExpression(location) && !ts.isAssignmentTarget(location)) {
                let type = getTypeOfExpression(location);
                if (getExportSymbolOfValueSymbolIfExported(getNodeLinks(location).resolvedSymbol) === symbol) {
                    return type;
                }
            }
        }
        // The location isn't a reference to the given symbol, meaning we're being asked
        // a hypothetical question of what type the symbol would have if there was a reference
        // to it at the given location. Since we have no control flow information for the
        // hypothetical reference (control flow information is created and attached by the
        // binder), we simply return the declared type of the symbol.
        return getTypeOfSymbol(symbol);
    }
    function getControlFlowContainer(node) {
        return ts.findAncestor(node.parent, function (node) {
            return ts.isFunctionLike(node) && !ts.getImmediatelyInvokedFunctionExpression(node) ||
                node.kind === 234 /* ModuleBlock */ ||
                node.kind === SyntaxKind.SourceFile ||
                node.kind === SyntaxKind.PropertyDeclaration;
        });
    }
    // Check if a parameter is assigned anywhere within its declaring function.
    function isParameterAssigned(symbol) {
        let func = ts.getRootDeclaration(symbol.valueDeclaration).parent;
        let links = getNodeLinks(func);
        if (!(links.flags & 4194304 /* AssignmentsMarked */)) {
            links.flags |= 4194304 /* AssignmentsMarked */;
            if (!hasParentWithAssignmentsMarked(func)) {
                markParameterAssignments(func);
            }
        }
        return symbol.isAssigned || false;
    }
    function hasParentWithAssignmentsMarked(node) {
        return !!ts.findAncestor(node.parent, function (node) { return ts.isFunctionLike(node) && !!(getNodeLinks(node).flags & 4194304 /* AssignmentsMarked */); });
    }
    function markParameterAssignments(node) {
        if (node.kind === 71 /* Identifier */) {
            if (ts.isAssignmentTarget(node)) {
                let symbol = getResolvedSymbol(node);
                if (symbol.valueDeclaration && ts.getRootDeclaration(symbol.valueDeclaration).kind === SyntaxKind.Parameter) {
                    symbol.isAssigned = true;
                }
            }
        }
        else {
            ts.forEachChild(node, markParameterAssignments);
        }
    }
    function isConstVariable(symbol) {
        return symbol.flags & 3 /* Variable */ && (getDeclarationNodeFlagsFromSymbol(symbol) & 2 /* Const */) !== 0 && getTypeOfSymbol(symbol) !== autoArrayType;
    }
    /** remove undefined from the annotated type of a parameter when there is an initializer (that doesn't include undefined) */
    function removeOptionalityFromDeclaredType(declaredType, declaration) {
        let annotationIncludesUndefined = strictNullChecks &&
            declaration.kind === SyntaxKind.Parameter &&
            declaration.initializer &&
            getFalsyFlags(declaredType) & 2048 /* Undefined */ &&
            !(getFalsyFlags(checkExpression(declaration.initializer)) & 2048 /* Undefined */);
        return annotationIncludesUndefined ? getTypeWithFacts(declaredType, 131072 /* NEUndefined */) : declaredType;
    }
    function isApparentTypePosition(node) {
        let parent = node.parent;
        return parent.kind === 179 /* PropertyAccessExpression */ ||
            parent.kind === 181 /* CallExpression */ && parent.expression === node ||
            parent.kind === 180 /* ElementAccessExpression */ && parent.expression === node;
    }
    function typeHasNullableConstraint(type) {
        return type.flags & 540672 /* TypeVariable */ && maybeTypeOfKind(getBaseConstraintOfType(type) || emptyObjectType, 6144 /* Nullable */);
    }
    function getDeclaredOrApparentType(symbol, node) {
        // When a node is the left hand expression of a property access, element access, or call expression,
        // and the type of the node includes type variables with constraints that are nullable, we fetch the
        // apparent type of the node *before* performing control flow analysis such that narrowings apply to
        // the constraint type.
        let type = getTypeOfSymbol(symbol);
        if (isApparentTypePosition(node) && forEachType(type, typeHasNullableConstraint)) {
            return mapType(getWidenedType(type), getApparentType);
        }
        return type;
    }
    function checkIdentifier(node) {
        let symbol = getResolvedSymbol(node);
        if (symbol === unknownSymbol) {
            return unknownType;
        }
        // As noted in ECMAScript 6 language spec, arrow functions never have an arguments objects.
        // Although in down-level emit of arrow function, we emit it using function expression which means that
        // arguments objects will be bound to the inner object; emitting arrow function natively in ES6, arguments objects
        // will be bound to non-arrow function that contain this arrow function. This results in inconsistent behavior.
        // To avoid that we will give an error to users if they use arguments objects in arrow function so that they
        // can explicitly bound arguments objects
        if (symbol === argumentsSymbol) {
            let container = ts.getContainingFunction(node);
            if (languageVersion < 2 /* ES2015 */) {
                if (container.kind === 187 /* ArrowFunction */) {
                    error(node, ts.Diagnostics.The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_standard_function_expression);
                }
                else if (ts.hasModifier(container, 256 /* Async */)) {
                    error(node, ts.Diagnostics.The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_using_a_standard_function_or_method);
                }
            }
            getNodeLinks(container).flags |= 8192 /* CaptureArguments */;
            return getTypeOfSymbol(symbol);
        }
        // We should only mark aliases as referenced if there isn't a local value declaration
        // for the symbol.
        if (isNonLocalAlias(symbol, /*excludes*/ SymbolFlags.Value) && !isInTypeQuery(node) && !isConstEnumOrConstEnumOnlyModule(resolveAlias(symbol))) {
            markAliasSymbolAsReferenced(symbol);
        }
        let localOrExportSymbol = getExportSymbolOfValueSymbolIfExported(symbol);
        let declaration = localOrExportSymbol.valueDeclaration;
        if (localOrExportSymbol.flags & 32 /* Class */) {
            // Due to the emit for class decorators, any reference to the class from inside of the class body
            // must instead be rewritten to point to a temporary variable to avoid issues with the double-bind
            // behavior of class names in ES6.
            if (declaration.kind === SyntaxKind.ClassDeclaration
                && ts.nodeIsDecorated(declaration)) {
                let container = ts.getContainingClass(node);
                while (container !== undefined) {
                    if (container === declaration && container.name !== node) {
                        getNodeLinks(declaration).flags |= 8388608 /* ClassWithConstructorReference */;
                        getNodeLinks(node).flags |= 16777216 /* ConstructorReferenceInClass */;
                        break;
                    }
                    container = ts.getContainingClass(container);
                }
            }
            else if (declaration.kind === SyntaxKind.ClassExpression) {
                // When we emit a class expression with static members that contain a reference
                // to the constructor in the initializer, we will need to substitute that
                // binding with an alias as the class name is not in scope.
                let container = ts.getThisContainer(node, /*includeArrowFunctions*/ false);
                while (container !== undefined) {
                    if (container.parent === declaration) {
                        if (container.kind === SyntaxKind.PropertyDeclaration && ts.hasModifier(container, ModifierFlags.Static)) {
                            getNodeLinks(declaration).flags |= 8388608 /* ClassWithConstructorReference */;
                            getNodeLinks(node).flags |= 16777216 /* ConstructorReferenceInClass */;
                        }
                        break;
                    }
                    container = ts.getThisContainer(container, /*includeArrowFunctions*/ false);
                }
            }
        }
        checkCollisionWithCapturedSuperVariable(node, node);
        checkCollisionWithCapturedThisVariable(node, node);
        checkCollisionWithCapturedNewTargetVariable(node, node);
        checkNestedBlockScopedBinding(node, symbol);
        let type = getDeclaredOrApparentType(localOrExportSymbol, node);
        let assignmentKind = ts.getAssignmentTargetKind(node);
        if (assignmentKind) {
            if (!(localOrExportSymbol.flags & 3 /* Variable */)) {
                error(node, ts.Diagnostics.Cannot_assign_to_0_because_it_is_not_a_variable, symbolToString(symbol));
                return unknownType;
            }
            if (isReadonlySymbol(localOrExportSymbol)) {
                error(node, ts.Diagnostics.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, symbolToString(symbol));
                return unknownType;
            }
        }
        let isAlias = localOrExportSymbol.flags & SymbolFlags.Alias;
        // We only narrow variables and parameters occurring in a non-assignment position. For all other
        // entities we simply return the declared type.
        if (localOrExportSymbol.flags & 3 /* Variable */) {
            if (assignmentKind === 1 /* Definite */) {
                return type;
            }
        }
        else if (isAlias) {
            declaration = ts.find(symbol.declarations, isSomeImportDeclaration);
        }
        else {
            return type;
        }
        if (!declaration) {
            return type;
        }
        // The declaration container is the innermost function that encloses the declaration of the variable
        // or parameter. The flow container is the innermost function starting with which we analyze the control
        // flow graph to determine the control flow based type.
        let isParameter = ts.getRootDeclaration(declaration).kind === SyntaxKind.Parameter;
        let declarationContainer = getControlFlowContainer(declaration);
        let flowContainer = getControlFlowContainer(node);
        let isOuterVariable = flowContainer !== declarationContainer;
        // When the control flow originates in a function expression or arrow function and we are referencing
        // a const variable or parameter from an outer function, we extend the origin of the control flow
        // analysis to include the immediately enclosing function.
        while (flowContainer !== declarationContainer && (flowContainer.kind === 186 /* FunctionExpression */ ||
            flowContainer.kind === 187 /* ArrowFunction */ || ts.isObjectLiteralOrClassExpressionMethod(flowContainer)) &&
            (isConstVariable(localOrExportSymbol) || isParameter && !isParameterAssigned(localOrExportSymbol))) {
            flowContainer = getControlFlowContainer(flowContainer);
        }
        // We only look for uninitialized variables in strict null checking mode, and only when we can analyze
        // the entire control flow graph from the variable's declaration (i.e. when the flow container and
        // declaration container are the same).
        let assumeInitialized = isParameter || isAlias || isOuterVariable ||
            type !== autoType && type !== autoArrayType && (!strictNullChecks || (type.flags & 1 /* Any */) !== 0 || isInTypeQuery(node) || node.parent.kind === SyntaxKind.ExportSpecifier) ||
            node.parent.kind === 203 /* NonNullExpression */ ||
            ts.isInAmbientContext(declaration);
        let initialType = assumeInitialized ? (isParameter ? removeOptionalityFromDeclaredType(type, ts.getRootDeclaration(declaration)) : type) :
            type === autoType || type === autoArrayType ? undefinedType :
                getNullableType(type, 2048 /* Undefined */);
        let flowType = getFlowTypeOfReference(node, type, initialType, flowContainer, !assumeInitialized);
        // A variable is considered uninitialized when it is possible to analyze the entire control flow graph
        // from declaration to use, and when the variable's declared type doesn't include undefined but the
        // control flow based type does include undefined.
        if (type === autoType || type === autoArrayType) {
            if (flowType === autoType || flowType === autoArrayType) {
                if (noImplicitAny) {
                    error(ts.getNameOfDeclaration(declaration), ts.Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined, symbolToString(symbol), typeToString(flowType));
                    error(node, ts.Diagnostics.Variable_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType));
                }
                return convertAutoToAny(flowType);
            }
        }
        else if (!assumeInitialized && !(getFalsyFlags(type) & 2048 /* Undefined */) && getFalsyFlags(flowType) & 2048 /* Undefined */) {
            error(node, ts.Diagnostics.Variable_0_is_used_before_being_assigned, symbolToString(symbol));
            // Return the declared type to reduce follow-on errors
            return type;
        }
        return assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType;
    }
    function isInsideFunction(node, threshold) {
        return !!ts.findAncestor(node, function (n) { return n === threshold ? "quit" : ts.isFunctionLike(n); });
    }
    function checkNestedBlockScopedBinding(node, symbol) {
        if (languageVersion >= 2 /* ES2015 */ ||
            (symbol.flags & (SymbolFlags.BlockScopedVariable | 32 /* Class */)) === 0 ||
            symbol.valueDeclaration.parent.kind === 263 /* CatchClause */) {
            return;
        }
        // 1. walk from the use site up to the declaration and check
        // if there is anything function like between declaration and use-site (is binding/class is captured in function).
        // 2. walk from the declaration up to the boundary of lexical environment and check
        // if there is an iteration statement in between declaration and boundary (is binding/class declared inside iteration statement)
        let container = ts.getEnclosingBlockScopeContainer(symbol.valueDeclaration);
        let usedInFunction = isInsideFunction(node.parent, container);
        let current = container;
        let containedInIterationStatement = false;
        while (current && !ts.nodeStartsNewLexicalEnvironment(current)) {
            if (ts.isIterationStatement(current, /*lookInLabeledStatements*/ false)) {
                containedInIterationStatement = true;
                break;
            }
            current = current.parent;
        }
        if (containedInIterationStatement) {
            if (usedInFunction) {
                // mark iteration statement as containing block-scoped binding captured in some function
                getNodeLinks(current).flags |= 65536 /* LoopWithCapturedBlockScopedBinding */;
            }
            // mark variables that are declared in loop initializer and reassigned inside the body of ForStatement.
            // if body of ForStatement will be converted to function then we'll need a extra machinery to propagate reassigned values back.
            if (container.kind === SyntaxKind.ForStatement &&
                ts.getAncestor(symbol.valueDeclaration, 227 /* VariableDeclarationList */).parent === container &&
                isAssignedInBodyOfForStatement(node, container)) {
                getNodeLinks(symbol.valueDeclaration).flags |= 2097152 /* NeedsLoopOutParameter */;
            }
            // set 'declared inside loop' bit on the block-scoped binding
            getNodeLinks(symbol.valueDeclaration).flags |= 262144 /* BlockScopedBindingInLoop */;
        }
        if (usedInFunction) {
            getNodeLinks(symbol.valueDeclaration).flags |= 131072 /* CapturedBlockScopedBinding */;
        }
    }
    function isAssignedInBodyOfForStatement(node, container) {
        // skip parenthesized nodes
        let current = node;
        while (current.parent.kind === 185 /* ParenthesizedExpression */) {
            current = current.parent;
        }
        // check if node is used as LHS in some assignment expression
        let isAssigned = false;
        if (ts.isAssignmentTarget(current)) {
            isAssigned = true;
        }
        else if ((current.parent.kind === 192 /* PrefixUnaryExpression */ || current.parent.kind === 193 /* PostfixUnaryExpression */)) {
            let expr = current.parent;
            isAssigned = expr.operator === 43 /* PlusPlusToken */ || expr.operator === 44 /* MinusMinusToken */;
        }
        if (!isAssigned) {
            return false;
        }
        // at this point we know that node is the target of assignment
        // now check that modification happens inside the statement part of the ForStatement
        return !!ts.findAncestor(current, function (n) { return n === container ? "quit" : n === container.statement; });
    }
    function captureLexicalThis(node, container) {
        getNodeLinks(node).flags |= 2 /* LexicalThis */;
        if (container.kind === SyntaxKind.PropertyDeclaration || container.kind === 152 /* Constructor */) {
            let classNode = container.parent;
            getNodeLinks(classNode).flags |= 4 /* CaptureThis */;
        }
        else {
            getNodeLinks(container).flags |= 4 /* CaptureThis */;
        }
    }
    function findFirstSuperCall(n) {
        if (ts.isSuperCall(n)) {
            return n;
        }
        else if (ts.isFunctionLike(n)) {
            return undefined;
        }
        return ts.forEachChild(n, findFirstSuperCall);
    }
    /**
     * Return a cached result if super-statement is already found.
     * Otherwise, find a super statement in a given constructor function and cache the result in the node-links of the constructor
     *
     * @param constructor constructor-function to look for super statement
     */
    function getSuperCallInConstructor(constructor) {
        let links = getNodeLinks(constructor);
        // Only trying to find super-call if we haven't yet tried to find one.  Once we try, we will record the result
        if (links.hasSuperCall === undefined) {
            links.superCall = findFirstSuperCall(constructor.body);
            links.hasSuperCall = links.superCall ? true : false;
        }
        return links.superCall;
    }
    /**
     * Check if the given class-declaration extends null then return true.
     * Otherwise, return false
     * @param classDecl a class declaration to check if it extends null
     */
    function classDeclarationExtendsNull(classDecl) {
        let classSymbol = getSymbolOfNode(classDecl);
        let classInstanceType = getDeclaredTypeOfSymbol(classSymbol);
        let baseConstructorType = getBaseConstructorTypeOfClass(classInstanceType);
        return baseConstructorType === nullWideningType;
    }
    function checkThisBeforeSuper(node, container, diagnosticMessage) {
        let containingClassDecl = container.parent;
        let baseTypeNode = ts.getClassExtendsHeritageClauseElement(containingClassDecl);
        // If a containing class does not have extends clause or the class extends null
        // skip checking whether super statement is called before "this" accessing.
        if (baseTypeNode && !classDeclarationExtendsNull(containingClassDecl)) {
            let superCall = getSuperCallInConstructor(container);
            // We should give an error in the following cases:
            //      - No super-call
            //      - "this" is accessing before super-call.
            //          i.e super(this)
            //              this.x; super();
            // We want to make sure that super-call is done before accessing "this" so that
            // "this" is not accessed as a parameter of the super-call.
            if (!superCall || superCall.end > node.pos) {
                // In ES6, super inside constructor of class-declaration has to precede "this" accessing
                error(node, diagnosticMessage);
            }
        }
    }
    function checkThisExpression(node) {
        // Stop at the first arrow function so that we can
        // tell whether 'this' needs to be captured.
        let container = ts.getThisContainer(node, /* includeArrowFunctions */ true);
        let needToCaptureLexicalThis = false;
        if (container.kind === 152 /* Constructor */) {
            checkThisBeforeSuper(node, container, ts.Diagnostics.super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class);
        }
        // Now skip arrow functions to get the "real" owner of 'this'.
        if (container.kind === 187 /* ArrowFunction */) {
            container = ts.getThisContainer(container, /* includeArrowFunctions */ false);
            // When targeting es6, arrow function lexically bind "this" so we do not need to do the work of binding "this" in emitted code
            needToCaptureLexicalThis = (languageVersion < 2 /* ES2015 */);
        }
        switch (container.kind) {
            case SyntaxKind.ModuleDeclaration:
                error(node, ts.Diagnostics.this_cannot_be_referenced_in_a_module_or_namespace_body);
                // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
                break;
            case SyntaxKind.EnumDeclaration:
                error(node, ts.Diagnostics.this_cannot_be_referenced_in_current_location);
                // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
                break;
            case 152 /* Constructor */:
                if (isInConstructorArgumentInitializer(node, container)) {
                    error(node, ts.Diagnostics.this_cannot_be_referenced_in_constructor_arguments);
                    // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
                }
                break;
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.PropertySignature:
                if (ts.hasModifier(container, ModifierFlags.Static)) {
                    error(node, ts.Diagnostics.this_cannot_be_referenced_in_a_static_property_initializer);
                    // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks
                }
                break;
            case 144 /* ComputedPropertyName */:
                error(node, ts.Diagnostics.this_cannot_be_referenced_in_a_computed_property_name);
                break;
        }
        if (needToCaptureLexicalThis) {
            captureLexicalThis(node, container);
        }
        if (ts.isFunctionLike(container) &&
            (!isInParameterInitializerBeforeContainingFunction(node) || ts.getThisParameter(container))) {
            // Note: a parameter initializer should refer to class-this unless function-this is explicitly annotated.
            // If this is a function in a JS file, it might be a class method. Check if it's the RHS
            // of a x.prototype.y = function [name]() { .... }
            if (container.kind === 186 /* FunctionExpression */ &&
                container.parent.kind === 194 /* BinaryExpression */ &&
                ts.getSpecialPropertyAssignmentKind(container.parent) === 3 /* PrototypeProperty */) {
                // Get the 'x' of 'x.prototype.y = f' (here, 'f' is 'container')
                let className = container.parent // x.prototype.y = f
                    .left // x.prototype.y
                    .expression // x.prototype
                    .expression; // x
                let classSymbol = checkExpression(className).symbol;
                if (classSymbol && classSymbol.members && (classSymbol.flags & 16 /* Function */)) {
                    return getInferredClassType(classSymbol);
                }
            }
            let thisType = getThisTypeOfDeclaration(container) || getContextualThisParameterType(container);
            if (thisType) {
                return thisType;
            }
        }
        if (ts.isClassLike(container.parent)) {
            let symbol = getSymbolOfNode(container.parent);
            let type = ts.hasModifier(container, ModifierFlags.Static) ? getTypeOfSymbol(symbol) : getDeclaredTypeOfSymbol(symbol).thisType;
            return getFlowTypeOfReference(node, type);
        }
        if (ts.isInJavaScriptFile(node)) {
            let type = getTypeForThisExpressionFromJSDoc(container);
            if (type && type !== unknownType) {
                return type;
            }
        }
        if (noImplicitThis) {
            // With noImplicitThis, functions may not reference 'this' if it has type 'any'
            error(node, ts.Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation);
        }
        return anyType;
    }
    function getTypeForThisExpressionFromJSDoc(node) {
        let jsdocType = ts.getJSDocType(node);
        if (jsdocType && jsdocType.kind === 276 /* JSDocFunctionType */) {
            let jsDocFunctionType = jsdocType;
            if (jsDocFunctionType.parameters.length > 0 &&
                jsDocFunctionType.parameters[0].name &&
                jsDocFunctionType.parameters[0].name.escapedText === "this") {
                return getTypeFromTypeNode(jsDocFunctionType.parameters[0].type);
            }
        }
    }
    function isInConstructorArgumentInitializer(node, constructorDecl) {
        return !!ts.findAncestor(node, function (n) { return n === constructorDecl ? "quit" : n.kind === SyntaxKind.Parameter; });
    }
    function checkSuperExpression(node) {
        let isCallExpression = node.parent.kind === 181 /* CallExpression */ && node.parent.expression === node;
        let container = ts.getSuperContainer(node, /*stopOnFunctions*/ true);
        let needToCaptureLexicalThis = false;
        // adjust the container reference in case if super is used inside arrow functions with arbitrarily deep nesting
        if (!isCallExpression) {
            while (container && container.kind === 187 /* ArrowFunction */) {
                container = ts.getSuperContainer(container, /*stopOnFunctions*/ true);
                needToCaptureLexicalThis = languageVersion < 2 /* ES2015 */;
            }
        }
        let canUseSuperExpression = isLegalUsageOfSuperExpression(container);
        let nodeCheckFlag = 0;
        if (!canUseSuperExpression) {
            // issue more specific error if super is used in computed property name
            // class A { foo() { return "1" }}
            // class B {
            //     [super.foo()]() {}
            // }
            let current = ts.findAncestor(node, function (n) { return n === container ? "quit" : n.kind === 144 /* ComputedPropertyName */; });
            if (current && current.kind === 144 /* ComputedPropertyName */) {
                error(node, ts.Diagnostics.super_cannot_be_referenced_in_a_computed_property_name);
            }
            else if (isCallExpression) {
                error(node, ts.Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors);
            }
            else if (!container || !container.parent || !(ts.isClassLike(container.parent) || container.parent.kind === 178 /* ObjectLiteralExpression */)) {
                error(node, ts.Diagnostics.super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions);
            }
            else {
                error(node, ts.Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class);
            }
            return unknownType;
        }
        if (!isCallExpression && container.kind === 152 /* Constructor */) {
            checkThisBeforeSuper(node, container, ts.Diagnostics.super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class);
        }
        if (ts.hasModifier(container, ModifierFlags.Static) || isCallExpression) {
            nodeCheckFlag = 512 /* SuperStatic */;
        }
        else {
            nodeCheckFlag = 256 /* SuperInstance */;
        }
        getNodeLinks(node).flags |= nodeCheckFlag;
        // Due to how we emit async functions, we need to specialize the emit for an async method that contains a `super` reference.
        // This is due to the fact that we emit the body of an async function inside of a generator function. As generator
        // functions cannot reference `super`, we emit a helper inside of the method body, but outside of the generator. This helper
        // uses an arrow function, which is permitted to reference `super`.
        //
        // There are two primary ways we can access `super` from within an async method. The first is getting the value of a property
        // or indexed access on super, either as part of a right-hand-side expression or call expression. The second is when setting the value
        // of a property or indexed access, either as part of an assignment expression or destructuring assignment.
        //
        // The simplest case is reading a value, in which case we will emit something like the following:
        //
        //  // ts
        //  ...
        //  async asyncMethod() {
        //    let x = await super.asyncMethod();
        //    return x;
        //  }
        //  ...
        //
        //  // js
        //  ...
        //  asyncMethod() {
        //      const _super = name => super[name];
        //      return __awaiter(this, arguments, Promise, function *() {
        //          let x = yield _super("asyncMethod").call(this);
        //          return x;
        //      });
        //  }
        //  ...
        //
        // The more complex case is when we wish to assign a value, especially as part of a destructuring assignment. As both cases
        // are legal in ES6, but also likely less frequent, we emit the same more complex helper for both scenarios:
        //
        //  // ts
        //  ...
        //  async asyncMethod(ar: Promise<any[]>) {
        //      [super.a, super.b] = await ar;
        //  }
        //  ...
        //
        //  // js
        //  ...
        //  asyncMethod(ar) {
        //      const _super = (function (geti, seti) {
        //          const cache = Object.create(null);
        //          return name => cache[name] || (cache[name] = { get value() { return geti(name); }, set value(v) { seti(name, v); } });
        //      })(name => super[name], (name, value) => super[name] = value);
        //      return __awaiter(this, arguments, Promise, function *() {
        //          [_super("a").value, _super("b").value] = yield ar;
        //      });
        //  }
        //  ...
        //
        // This helper creates an object with a "value" property that wraps the `super` property or indexed access for both get and set.
        // This is required for destructuring assignments, as a call expression cannot be used as the target of a destructuring assignment
        // while a property access can.
        if (container.kind === SyntaxKind.MethodDeclaration && ts.hasModifier(container, 256 /* Async */)) {
            if (ts.isSuperProperty(node.parent) && ts.isAssignmentTarget(node.parent)) {
                getNodeLinks(container).flags |= 4096 /* AsyncMethodWithSuperBinding */;
            }
            else {
                getNodeLinks(container).flags |= 2048 /* AsyncMethodWithSuper */;
            }
        }
        if (needToCaptureLexicalThis) {
            // call expressions are allowed only in constructors so they should always capture correct 'this'
            // super property access expressions can also appear in arrow functions -
            // in this case they should also use correct lexical this
            captureLexicalThis(node.parent, container);
        }
        if (container.parent.kind === 178 /* ObjectLiteralExpression */) {
            if (languageVersion < 2 /* ES2015 */) {
                error(node, ts.Diagnostics.super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher);
                return unknownType;
            }
            else {
                // for object literal assume that type of 'super' is 'any'
                return anyType;
            }
        }
        // at this point the only legal case for parent is ClassLikeDeclaration
        let classLikeDeclaration = container.parent;
        let classType = getDeclaredTypeOfSymbol(getSymbolOfNode(classLikeDeclaration));
        let baseClassType = classType && getBaseTypes(classType)[0];
        if (!baseClassType) {
            if (!ts.getClassExtendsHeritageClauseElement(classLikeDeclaration)) {
                error(node, ts.Diagnostics.super_can_only_be_referenced_in_a_derived_class);
            }
            return unknownType;
        }
        if (container.kind === 152 /* Constructor */ && isInConstructorArgumentInitializer(node, container)) {
            // issue custom error message for super property access in constructor arguments (to be aligned with old compiler)
            error(node, ts.Diagnostics.super_cannot_be_referenced_in_constructor_arguments);
            return unknownType;
        }
        return nodeCheckFlag === 512 /* SuperStatic */
            ? getBaseConstructorTypeOfClass(classType)
            : getTypeWithThisArgument(baseClassType, classType.thisType);
        function isLegalUsageOfSuperExpression(container) {
            if (!container) {
                return false;
            }
            if (isCallExpression) {
                // TS 1.0 SPEC (April 2014): 4.8.1
                // Super calls are only permitted in constructors of derived classes
                return container.kind === 152 /* Constructor */;
            }
            else {
                // TS 1.0 SPEC (April 2014)
                // 'super' property access is allowed
                // - In a constructor, instance member function, instance member accessor, or instance member variable initializer where this references a derived class instance
                // - In a static member function or static member accessor
                // topmost container must be something that is directly nested in the class declaration\object literal expression
                if (ts.isClassLike(container.parent) || container.parent.kind === 178 /* ObjectLiteralExpression */) {
                    if (ts.hasModifier(container, ModifierFlags.Static)) {
                        return container.kind === SyntaxKind.MethodDeclaration ||
                            container.kind === 150 /* MethodSignature */ ||
                            container.kind === 153 /* GetAccessor */ ||
                            container.kind === 154 /* SetAccessor */;
                    }
                    else {
                        return container.kind === SyntaxKind.MethodDeclaration ||
                            container.kind === 150 /* MethodSignature */ ||
                            container.kind === 153 /* GetAccessor */ ||
                            container.kind === 154 /* SetAccessor */ ||
                            container.kind === SyntaxKind.PropertyDeclaration ||
                            container.kind === SyntaxKind.PropertySignature ||
                            container.kind === 152 /* Constructor */;
                    }
                }
            }
            return false;
        }
    }
    function getContainingObjectLiteral(func) {
        return (func.kind === SyntaxKind.MethodDeclaration ||
            func.kind === 153 /* GetAccessor */ ||
            func.kind === 154 /* SetAccessor */) && func.parent.kind === 178 /* ObjectLiteralExpression */ ? func.parent :
            func.kind === 186 /* FunctionExpression */ && func.parent.kind === 264 /* PropertyAssignment */ ? func.parent.parent :
                undefined;
    }
    function getThisTypeArgument(type) {
        return getObjectFlags(type) & 4 /* Reference */ && type.target === globalThisType ? type.typeArguments[0] : undefined;
    }
    function getThisTypeFromContextualType(type) {
        return mapType(type, function (t) {
            return t.flags & 131072 /* Intersection */ ? ts.forEach(t.types, getThisTypeArgument) : getThisTypeArgument(t);
        });
    }
    function getContextualThisParameterType(func) {
        if (func.kind === 187 /* ArrowFunction */) {
            return undefined;
        }
        if (isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
            let contextualSignature = getContextualSignature(func);
            if (contextualSignature) {
                let thisParameter = contextualSignature.thisParameter;
                if (thisParameter) {
                    return getTypeOfSymbol(thisParameter);
                }
            }
        }
        let inJs = ts.isInJavaScriptFile(func);
        if (noImplicitThis || inJs) {
            let containingLiteral = getContainingObjectLiteral(func);
            if (containingLiteral) {
                // We have an object literal method. Check if the containing object literal has a contextual type
                // that includes a ThisType<T>. If so, T is the contextual type for 'this'. We continue looking in
                // any directly enclosing object literals.
                let contextualType = getApparentTypeOfContextualType(containingLiteral);
                let literal = containingLiteral;
                let type = contextualType;
                while (type) {
                    let thisType = getThisTypeFromContextualType(type);
                    if (thisType) {
                        return instantiateType(thisType, getContextualMapper(containingLiteral));
                    }
                    if (literal.parent.kind !== 264 /* PropertyAssignment */) {
                        break;
                    }
                    literal = literal.parent.parent;
                    type = getApparentTypeOfContextualType(literal);
                }
                // There was no contextual ThisType<T> for the containing object literal, so the contextual type
                // for 'this' is the non-null form of the contextual type for the containing object literal or
                // the type of the object literal itself.
                return contextualType ? getNonNullableType(contextualType) : checkExpressionCached(containingLiteral);
            }
            // In an assignment of the form 'obj.xxx = function(...)' or 'obj[xxx] = function(...)', the
            // contextual type for 'this' is 'obj'.
            let parent = func.parent;
            if (parent.kind === 194 /* BinaryExpression */ && parent.operatorToken.kind === 58 /* EqualsToken */) {
                let target = parent.left;
                if (target.kind === 179 /* PropertyAccessExpression */ || target.kind === 180 /* ElementAccessExpression */) {
                    let expression = target.expression;
                    // Don't contextually type `this` as `exports` in `exports.Point = function(x, y) { this.x = x; this.y = y; }`
                    if (inJs && ts.isIdentifier(expression)) {
                        let sourceFile = ts.getSourceFileOfNode(parent);
                        if (sourceFile.commonJsModuleIndicator && getResolvedSymbol(expression) === sourceFile.symbol) {
                            return undefined;
                        }
                    }
                    return checkExpressionCached(expression);
                }
            }
        }
        return undefined;
    }
    // Return contextual type of parameter or undefined if no contextual type is available
    function getContextuallyTypedParameterType(parameter) {
        let func = parameter.parent;
        if (isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
            let iife = ts.getImmediatelyInvokedFunctionExpression(func);
            if (iife && iife.arguments) {
                let indexOfParameter = ts.indexOf(func.parameters, parameter);
                if (parameter.dotDotDotToken) {
                    let restTypes = [];
                    for (let i = indexOfParameter; i < iife.arguments.length; i++) {
                        restTypes.push(getWidenedLiteralType(checkExpression(iife.arguments[i])));
                    }
                    return restTypes.length ? createArrayType(getUnionType(restTypes)) : undefined;
                }
                let links = getNodeLinks(iife);
                let cached = links.resolvedSignature;
                links.resolvedSignature = anySignature;
                let type = indexOfParameter < iife.arguments.length ?
                    getWidenedLiteralType(checkExpression(iife.arguments[indexOfParameter])) :
                    parameter.initializer ? undefined : undefinedWideningType;
                links.resolvedSignature = cached;
                return type;
            }
            let contextualSignature = getContextualSignature(func);
            if (contextualSignature) {
                let funcHasRestParameters = ts.hasRestParameter(func);
                let len = func.parameters.length - (funcHasRestParameters ? 1 : 0);
                let indexOfParameter = ts.indexOf(func.parameters, parameter);
                if (ts.getThisParameter(func) !== undefined && !contextualSignature.thisParameter) {
                    ts.Debug.assert(indexOfParameter !== 0); // Otherwise we should not have called `getContextuallyTypedParameterType`.
                    indexOfParameter -= 1;
                }
                if (indexOfParameter < len) {
                    return getTypeAtPosition(contextualSignature, indexOfParameter);
                }
                // If last parameter is contextually rest parameter get its type
                if (funcHasRestParameters &&
                    indexOfParameter === (func.parameters.length - 1) &&
                    isRestParameterIndex(contextualSignature, func.parameters.length - 1)) {
                    return getTypeOfSymbol(ts.lastOrUndefined(contextualSignature.parameters));
                }
            }
        }
        return undefined;
    }
    // In a variable, parameter or property declaration with a type annotation,
    //   the contextual type of an initializer expression is the type of the variable, parameter or property.
    // Otherwise, in a parameter declaration of a contextually typed function expression,
    //   the contextual type of an initializer expression is the contextual type of the parameter.
    // Otherwise, in a variable or parameter declaration with a binding pattern name,
    //   the contextual type of an initializer expression is the type implied by the binding pattern.
    // Otherwise, in a binding pattern inside a variable or parameter declaration,
    //   the contextual type of an initializer expression is the type annotation of the containing declaration, if present.
    function getContextualTypeForInitializerExpression(node) {
        let declaration = node.parent;
        if (node === declaration.initializer) {
            let typeNode = ts.getEffectiveTypeAnnotationNode(declaration);
            if (typeNode) {
                return getTypeFromTypeNode(typeNode);
            }
            if (declaration.kind === SyntaxKind.Parameter) {
                let type = getContextuallyTypedParameterType(declaration);
                if (type) {
                    return type;
                }
            }
            if (ts.isBindingPattern(declaration.name)) {
                return getTypeFromBindingPattern(declaration.name, /*includePatternInType*/ true, /*reportErrors*/ false);
            }
            if (ts.isBindingPattern(declaration.parent)) {
                let parentDeclaration = declaration.parent.parent;
                let name = declaration.propertyName || declaration.name;
                if (parentDeclaration.kind !== 176 /* BindingElement */) {
                    let parentTypeNode = ts.getEffectiveTypeAnnotationNode(parentDeclaration);
                    if (parentTypeNode && !ts.isBindingPattern(name)) {
                        let text = ts.getTextOfPropertyName(name);
                        if (text) {
                            return getTypeOfPropertyOfType(getTypeFromTypeNode(parentTypeNode), text);
                        }
                    }
                }
            }
        }
        return undefined;
    }
    function getContextualTypeForReturnExpression(node) {
        let func = ts.getContainingFunction(node);
        if (func) {
            let functionFlags = ts.getFunctionFlags(func);
            if (functionFlags & 1 /* Generator */) {
                return undefined;
            }
            let contextualReturnType = getContextualReturnType(func);
            return functionFlags & 2 /* Async */
                ? contextualReturnType && getAwaitedTypeOfPromise(contextualReturnType) // Async function
                : contextualReturnType; // Regular function
        }
        return undefined;
    }
    function getContextualTypeForYieldOperand(node) {
        let func = ts.getContainingFunction(node);
        if (func) {
            let functionFlags = ts.getFunctionFlags(func);
            let contextualReturnType = getContextualReturnType(func);
            if (contextualReturnType) {
                return node.asteriskToken
                    ? contextualReturnType
                    : getIteratedTypeOfGenerator(contextualReturnType, (functionFlags & 2 /* Async */) !== 0);
            }
        }
        return undefined;
    }
    function isInParameterInitializerBeforeContainingFunction(node) {
        while (node.parent && !ts.isFunctionLike(node.parent)) {
            if (node.parent.kind === SyntaxKind.Parameter && node.parent.initializer === node) {
                return true;
            }
            node = node.parent;
        }
        return false;
    }
    function getContextualReturnType(functionDecl) {
        // If the containing function has a return type annotation, is a constructor, or is a get accessor whose
        // corresponding set accessor has a type annotation, return statements in the function are contextually typed
        if (functionDecl.kind === 152 /* Constructor */ ||
            ts.getEffectiveReturnTypeNode(functionDecl) ||
            isGetAccessorWithAnnotatedSetAccessor(functionDecl)) {
            return getReturnTypeOfSignature(getSignatureFromDeclaration(functionDecl));
        }
        // Otherwise, if the containing function is contextually typed by a function type with exactly one call signature
        // and that call signature is non-generic, return statements are contextually typed by the return type of the signature
        let signature = getContextualSignatureForFunctionLikeDeclaration(functionDecl);
        if (signature && !isResolvingReturnTypeOfSignature(signature)) {
            return getReturnTypeOfSignature(signature);
        }
        return undefined;
    }
    // In a typed function call, an argument or substitution expression is contextually typed by the type of the corresponding parameter.
    function getContextualTypeForArgument(callTarget, arg) {
        let args = getEffectiveCallArguments(callTarget);
        let argIndex = ts.indexOf(args, arg);
        if (argIndex >= 0) {
            // If we're already in the process of resolving the given signature, don't resolve again as
            // that could cause infinite recursion. Instead, return anySignature.
            let signature = getNodeLinks(callTarget).resolvedSignature === resolvingSignature ? resolvingSignature : getResolvedSignature(callTarget);
            return getTypeAtPosition(signature, argIndex);
        }
        return undefined;
    }
    function getContextualTypeForSubstitutionExpression(template, substitutionExpression) {
        if (template.parent.kind === 183 /* TaggedTemplateExpression */) {
            return getContextualTypeForArgument(template.parent, substitutionExpression);
        }
        return undefined;
    }
    function getContextualTypeForBinaryOperand(node) {
        let binaryExpression = node.parent;
        let operator = binaryExpression.operatorToken.kind;
        if (ts.isAssignmentOperator(operator)) {
            if (node === binaryExpression.right) {
                // Don't do this for special property assignments to avoid circularity
                switch (ts.getSpecialPropertyAssignmentKind(binaryExpression)) {
                    case 0 /* None */:
                        break;
                    case 5 /* Property */:
                        // If `binaryExpression.left` was assigned a symbol, then this is a new declaration; otherwise it is an assignment to an existing declaration.
                        // See `bindStaticPropertyAssignment` in `binder.ts`.
                        if (!binaryExpression.left.symbol) {
                            break;
                        }
                    // falls through
                    case 1 /* ExportsProperty */:
                    case 2 /* ModuleExports */:
                    case 3 /* PrototypeProperty */:
                    case 4 /* ThisProperty */:
                        return undefined;
                }
                // In an assignment expression, the right operand is contextually typed by the type of the left operand.
                return getTypeOfExpression(binaryExpression.left);
            }
        }
        else if (operator === 54 /* BarBarToken */) {
            // When an || expression has a contextual type, the operands are contextually typed by that type. When an ||
            // expression has no contextual type, the right operand is contextually typed by the type of the left operand.
            let type = getContextualType(binaryExpression);
            if (!type && node === binaryExpression.right) {
                type = getTypeOfExpression(binaryExpression.left, /*cache*/ true);
            }
            return type;
        }
        else if (operator === 53 /* AmpersandAmpersandToken */ || operator === 26 /* CommaToken */) {
            if (node === binaryExpression.right) {
                return getContextualType(binaryExpression);
            }
        }
        return undefined;
    }
    function getTypeOfPropertyOfContextualType(type, name) {
        return mapType(type, function (t) {
            let prop = t.flags & 229376 /* StructuredType */ ? getPropertyOfType(t, name) : undefined;
            return prop ? getTypeOfSymbol(prop) : undefined;
        });
    }
    function getIndexTypeOfContextualType(type, kind) {
        return mapType(type, function (t) { return getIndexTypeOfStructuredType(t, kind); });
    }
    // Return true if the given contextual type is a tuple-like type
    function contextualTypeIsTupleLikeType(type) {
        return !!(type.flags & 65536 /* Union */ ? ts.forEach(type.types, isTupleLikeType) : isTupleLikeType(type));
    }
    // In an object literal contextually typed by a type T, the contextual type of a property assignment is the type of
    // the matching property in T, if one exists. Otherwise, it is the type of the numeric index signature in T, if one
    // exists. Otherwise, it is the type of the string index signature in T, if one exists.
    function getContextualTypeForObjectLiteralMethod(node) {
        ts.Debug.assert(ts.isObjectLiteralMethod(node));
        if (isInsideWithStatementBody(node)) {
            // We cannot answer semantic questions within a with block, do not proceed any further
            return undefined;
        }
        return getContextualTypeForObjectLiteralElement(node);
    }
    function getContextualTypeForObjectLiteralElement(element) {
        let objectLiteral = element.parent;
        let type = getApparentTypeOfContextualType(objectLiteral);
        if (type) {
            if (!ts.hasDynamicName(element)) {
                // For a (non-symbol) computed property, there is no reason to look up the name
                // in the type. It will just be "__computed", which does not appear in any
                // SymbolTable.
                let symbolName_1 = getSymbolOfNode(element).escapedName;
                let propertyType = getTypeOfPropertyOfContextualType(type, symbolName_1);
                if (propertyType) {
                    return propertyType;
                }
            }
            return isNumericName(element.name) && getIndexTypeOfContextualType(type, 1 /* Number */) ||
                getIndexTypeOfContextualType(type, 0 /* String */);
        }
        return undefined;
    }
    // In an array literal contextually typed by a type T, the contextual type of an element expression at index N is
    // the type of the property with the numeric name N in T, if one exists. Otherwise, if T has a numeric index signature,
    // it is the type of the numeric index signature in T. Otherwise, in ES6 and higher, the contextual type is the iterated
    // type of T.
    function getContextualTypeForElementExpression(arrayContextualType, index) {
        return arrayContextualType && (getTypeOfPropertyOfContextualType(arrayContextualType, "" + index)
            || getIndexTypeOfContextualType(arrayContextualType, 1 /* Number */)
            || getIteratedTypeOrElementType(arrayContextualType, /*errorNode*/ undefined, /*allowStringInput*/ false, /*allowAsyncIterables*/ false, /*checkAssignability*/ false));
    }
    // In a contextually typed conditional expression, the true/false expressions are contextually typed by the same type.
    function getContextualTypeForConditionalOperand(node) {
        let conditional = node.parent;
        return node === conditional.whenTrue || node === conditional.whenFalse ? getContextualType(conditional) : undefined;
    }
    function getContextualTypeForJsxExpression(node) {
        // JSX expression can appear in two position : JSX Element's children or JSX attribute
        let jsxAttributes = ts.isJsxAttributeLike(node.parent) ?
            node.parent.parent :
            ts.isJsxElement(node.parent) ?
                node.parent.openingElement.attributes :
                undefined; // node.parent is JsxFragment with no attributes
        if (!jsxAttributes) {
            return undefined; // don't check children of a fragment
        }
        // When we trying to resolve JsxOpeningLikeElement as a stateless function element, we will already give its attributes a contextual type
        // which is a type of the parameter of the signature we are trying out.
        // If there is no contextual type (e.g. we are trying to resolve stateful component), get attributes type from resolving element's tagName
        let attributesType = getContextualType(jsxAttributes);
        if (!attributesType || isTypeAny(attributesType)) {
            return undefined;
        }
        if (ts.isJsxAttribute(node.parent)) {
            // JSX expression is in JSX attribute
            return getTypeOfPropertyOfContextualType(attributesType, node.parent.name.escapedText);
        }
        else if (node.parent.kind === 249 /* JsxElement */) {
            // JSX expression is in children of JSX Element, we will look for an "children" atttribute (we get the name from JSX.ElementAttributesProperty)
            let jsxChildrenPropertyName = getJsxElementChildrenPropertyname();
            return jsxChildrenPropertyName && jsxChildrenPropertyName !== "" ? getTypeOfPropertyOfContextualType(attributesType, jsxChildrenPropertyName) : anyType;
        }
        else {
            // JSX expression is in JSX spread attribute
            return attributesType;
        }
    }
    function getContextualTypeForJsxAttribute(attribute) {
        // When we trying to resolve JsxOpeningLikeElement as a stateless function element, we will already give its attributes a contextual type
        // which is a type of the parameter of the signature we are trying out.
        // If there is no contextual type (e.g. we are trying to resolve stateful component), get attributes type from resolving element's tagName
        let attributesType = getContextualType(attribute.parent);
        if (ts.isJsxAttribute(attribute)) {
            if (!attributesType || isTypeAny(attributesType)) {
                return undefined;
            }
            return getTypeOfPropertyOfContextualType(attributesType, attribute.name.escapedText);
        }
        else {
            return attributesType;
        }
    }
    // Return the contextual type for a given expression node. During overload resolution, a contextual type may temporarily
    // be "pushed" onto a node using the contextualType property.
    function getApparentTypeOfContextualType(node) {
        let type = getContextualType(node);
        return type && getApparentType(type);
    }
    /**
     * Woah! Do you really want to use this function?
     *
     * Unless you're trying to get the *non-apparent* type for a
     * value-literal type or you're authoring relevant portions of this algorithm,
     * you probably meant to use 'getApparentTypeOfContextualType'.
     * Otherwise this may not be very useful.
     *
     * In cases where you *are* working on this function, you should understand
     * when it is appropriate to use 'getContextualType' and 'getApparentTypeOfContextualType'.
     *
     *   - Use 'getContextualType' when you are simply going to propagate the result to the expression.
     *   - Use 'getApparentTypeOfContextualType' when you're going to need the members of the type.
     *
     * @param node the expression whose contextual type will be returned.
     * @returns the contextual type of an expression.
     */
    function getContextualType(node) {
        if (isInsideWithStatementBody(node)) {
            // We cannot answer semantic questions within a with block, do not proceed any further
            return undefined;
        }
        if (node.contextualType) {
            return node.contextualType;
        }
        let parent = node.parent;
        switch (parent.kind) {
            case SyntaxKind.VariableDeclaration:
            case SyntaxKind.Parameter:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.PropertySignature:
            case 176 /* BindingElement */:
                return getContextualTypeForInitializerExpression(node);
            case 187 /* ArrowFunction */:
            case 219 /* ReturnStatement */:
                return getContextualTypeForReturnExpression(node);
            case 197 /* YieldExpression */:
                return getContextualTypeForYieldOperand(parent);
            case 181 /* CallExpression */:
            case 182 /* NewExpression */:
                return getContextualTypeForArgument(parent, node);
            case 184 /* TypeAssertionExpression */:
            case 202 /* AsExpression */:
                return getTypeFromTypeNode(parent.type);
            case 194 /* BinaryExpression */:
                return getContextualTypeForBinaryOperand(node);
            case 264 /* PropertyAssignment */:
            case 265 /* ShorthandPropertyAssignment */:
                return getContextualTypeForObjectLiteralElement(parent);
            case 266 /* SpreadAssignment */:
                return getApparentTypeOfContextualType(parent.parent);
            case 177 /* ArrayLiteralExpression */: {
                let arrayLiteral = parent;
                let type = getApparentTypeOfContextualType(arrayLiteral);
                return getContextualTypeForElementExpression(type, ts.indexOfNode(arrayLiteral.elements, node));
            }
            case 195 /* ConditionalExpression */:
                return getContextualTypeForConditionalOperand(node);
            case 205 /* TemplateSpan */:
                ts.Debug.assert(parent.parent.kind === 196 /* TemplateExpression */);
                return getContextualTypeForSubstitutionExpression(parent.parent, node);
            case 185 /* ParenthesizedExpression */: {
                // Like in `checkParenthesizedExpression`, an `/** @type {xyz} */` comment before a parenthesized expression acts as a type cast.
                let tag = ts.isInJavaScriptFile(parent) ? ts.getJSDocTypeTag(parent) : undefined;
                return tag ? getTypeFromTypeNode(tag.typeExpression.type) : getContextualType(parent);
            }
            case 259 /* JsxExpression */:
                return getContextualTypeForJsxExpression(parent);
            case 256 /* JsxAttribute */:
            case 258 /* JsxSpreadAttribute */:
                return getContextualTypeForJsxAttribute(parent);
            case 251 /* JsxOpeningElement */:
            case 250 /* JsxSelfClosingElement */:
                return getAttributesTypeFromJsxOpeningLikeElement(parent);
        }
        return undefined;
    }
    function getContextualMapper(node) {
        node = ts.findAncestor(node, function (n) { return !!n.contextualMapper; });
        return node ? node.contextualMapper : identityMapper;
    }
    // If the given type is an object or union type with a single signature, and if that signature has at
    // least as many parameters as the given function, return the signature. Otherwise return undefined.
    function getContextualCallSignature(type, node) {
        let signatures = getSignaturesOfStructuredType(type, 0 /* Call */);
        if (signatures.length === 1) {
            let signature = signatures[0];
            if (!isAritySmaller(signature, node)) {
                return signature;
            }
        }
    }
    /** If the contextual signature has fewer parameters than the function expression, do not use it */
    function isAritySmaller(signature, target) {
        let targetParameterCount = 0;
        for (; targetParameterCount < target.parameters.length; targetParameterCount++) {
            let param = target.parameters[targetParameterCount];
            if (param.initializer || param.questionToken || param.dotDotDotToken || isJSDocOptionalParameter(param)) {
                break;
            }
        }
        if (target.parameters.length && ts.parameterIsThisKeyword(target.parameters[0])) {
            targetParameterCount--;
        }
        let sourceLength = signature.hasRestParameter ? Number.MAX_VALUE : signature.parameters.length;
        return sourceLength < targetParameterCount;
    }
    function isFunctionExpressionOrArrowFunction(node) {
        return node.kind === 186 /* FunctionExpression */ || node.kind === 187 /* ArrowFunction */;
    }
    function getContextualSignatureForFunctionLikeDeclaration(node) {
        // Only function expressions, arrow functions, and object literal methods are contextually typed.
        return isFunctionExpressionOrArrowFunction(node) || ts.isObjectLiteralMethod(node)
            ? getContextualSignature(node)
            : undefined;
    }
    function getContextualTypeForFunctionLikeDeclaration(node) {
        return ts.isObjectLiteralMethod(node) ?
            getContextualTypeForObjectLiteralMethod(node) :
            getApparentTypeOfContextualType(node);
    }
    // Return the contextual signature for a given expression node. A contextual type provides a
    // contextual signature if it has a single call signature and if that call signature is non-generic.
    // If the contextual type is a union type, get the signature from each type possible and if they are
    // all identical ignoring their return type, the result is same signature but with return type as
    // union type of return types from these signatures
    function getContextualSignature(node) {
        ts.Debug.assert(node.kind !== SyntaxKind.MethodDeclaration || ts.isObjectLiteralMethod(node));
        let type = getContextualTypeForFunctionLikeDeclaration(node);
        if (!type) {
            return undefined;
        }
        if (!(type.flags & 65536 /* Union */)) {
            return getContextualCallSignature(type, node);
        }
        let signatureList;
        let types = type.types;
        for (let _i = 0, types_16 = types; _i < types_16.length; _i++) {
            let current = types_16[_i];
            let signature = getContextualCallSignature(current, node);
            if (signature) {
                if (!signatureList) {
                    // This signature will contribute to contextual union signature
                    signatureList = [signature];
                }
                else if (!compareSignaturesIdentical(signatureList[0], signature, /*partialMatch*/ false, /*ignoreThisTypes*/ true, /*ignoreReturnTypes*/ true, compareTypesIdentical)) {
                    // Signatures aren't identical, do not use
                    return undefined;
                }
                else {
                    // Use this signature for contextual union signature
                    signatureList.push(signature);
                }
            }
        }
        // Result is union of signatures collected (return type is union of return types of this signature set)
        let result;
        if (signatureList) {
            result = cloneSignature(signatureList[0]);
            // Clear resolved return type we possibly got from cloneSignature
            result.resolvedReturnType = undefined;
            result.unionSignatures = signatureList;
        }
        return result;
    }
    function checkSpreadExpression(node, checkMode) {
        if (languageVersion < 2 /* ES2015 */ && compilerOptions.downlevelIteration) {
            checkExternalEmitHelpers(node, 1536 /* SpreadIncludes */);
        }
        let arrayOrIterableType = checkExpression(node.expression, checkMode);
        return checkIteratedTypeOrElementType(arrayOrIterableType, node.expression, /*allowStringInput*/ false, /*allowAsyncIterables*/ false);
    }
    function hasDefaultValue(node) {
        return (node.kind === 176 /* BindingElement */ && !!node.initializer) ||
            (node.kind === 194 /* BinaryExpression */ && node.operatorToken.kind === 58 /* EqualsToken */);
    }
    function checkArrayLiteral(node, checkMode) {
        let elements = node.elements;
        let hasSpreadElement = false;
        let elementTypes = [];
        let inDestructuringPattern = ts.isAssignmentTarget(node);
        let contextualType = getApparentTypeOfContextualType(node);
        for (let index = 0; index < elements.length; index++) {
            let e = elements[index];
            if (inDestructuringPattern && e.kind === 198 /* SpreadElement */) {
                // Given the following situation:
                //    let c: {};
                //    [...c] = ["", 0];
                //
                // c is represented in the tree as a spread element in an array literal.
                // But c really functions as a rest element, and its purpose is to provide
                // a contextual type for the right hand side of the assignment. Therefore,
                // instead of calling checkExpression on "...c", which will give an error
                // if c is not iterable/array-like, we need to act as if we are trying to
                // get the contextual element type from it. So we do something similar to
                // getContextualTypeForElementExpression, which will crucially not error
                // if there is no index type / iterated type.
                let restArrayType = checkExpression(e.expression, checkMode);
                let restElementType = getIndexTypeOfType(restArrayType, 1 /* Number */) ||
                    getIteratedTypeOrElementType(restArrayType, /*errorNode*/ undefined, /*allowStringInput*/ false, /*allowAsyncIterables*/ false, /*checkAssignability*/ false);
                if (restElementType) {
                    elementTypes.push(restElementType);
                }
            }
            else {
                let elementContextualType = getContextualTypeForElementExpression(contextualType, index);
                let type = checkExpressionForMutableLocation(e, checkMode, elementContextualType);
                elementTypes.push(type);
            }
            hasSpreadElement = hasSpreadElement || e.kind === 198 /* SpreadElement */;
        }
        if (!hasSpreadElement) {
            // If array literal is actually a destructuring pattern, mark it as an implied type. We do this such
            // that we get the same behavior for "let [x, y] = []" and "[x, y] = []".
            if (inDestructuringPattern && elementTypes.length) {
                let type = cloneTypeReference(createTupleType(elementTypes));
                type.pattern = node;
                return type;
            }
            let contextualType_1 = getApparentTypeOfContextualType(node);
            if (contextualType_1 && contextualTypeIsTupleLikeType(contextualType_1)) {
                let pattern = contextualType_1.pattern;
                // If array literal is contextually typed by a binding pattern or an assignment pattern, pad the resulting
                // tuple type with the corresponding binding or assignment element types to make the lengths equal.
                if (pattern && (pattern.kind === 175 /* ArrayBindingPattern */ || pattern.kind === 177 /* ArrayLiteralExpression */)) {
                    let patternElements = pattern.elements;
                    for (let i = elementTypes.length; i < patternElements.length; i++) {
                        let patternElement = patternElements[i];
                        if (hasDefaultValue(patternElement)) {
                            elementTypes.push(contextualType_1.typeArguments[i]);
                        }
                        else {
                            if (patternElement.kind !== 200 /* OmittedExpression */) {
                                error(patternElement, ts.Diagnostics.Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value);
                            }
                            elementTypes.push(unknownType);
                        }
                    }
                }
                if (elementTypes.length) {
                    return createTupleType(elementTypes);
                }
            }
        }
        return createArrayType(elementTypes.length ?
            getUnionType(elementTypes, /*subtypeReduction*/ true) :
            strictNullChecks ? neverType : undefinedWideningType);
    }
    function isNumericName(name) {
        switch (name.kind) {
            case 144 /* ComputedPropertyName */:
                return isNumericComputedName(name);
            case 71 /* Identifier */:
                return isNumericLiteralName(name.escapedText);
            case 8 /* NumericLiteral */:
            case 9 /* StringLiteral */:
                return isNumericLiteralName(name.text);
            default:
                return false;
        }
    }
    function isNumericComputedName(name) {
        // It seems odd to consider an expression of type Any to result in a numeric name,
        // but this behavior is consistent with checkIndexedAccess
        return isTypeAssignableToKind(checkComputedPropertyName(name), 84 /* NumberLike */);
    }
    function isInfinityOrNaNString(name) {
        return name === "Infinity" || name === "-Infinity" || name === "NaN";
    }
    function isNumericLiteralName(name) {
        // The intent of numeric names is that
        //     - they are names with text in a numeric form, and that
        //     - setting properties/indexing with them is always equivalent to doing so with the numeric literal 'numLit',
        //         acquired by applying the abstract 'ToNumber' operation on the name's text.
        //
        // The subtlety is in the latter portion, as we cannot reliably say that anything that looks like a numeric literal is a numeric name.
        // In fact, it is the case that the text of the name must be equal to 'ToString(numLit)' for this to hold.
        //
        // Consider the property name '"0xF00D"'. When one indexes with '0xF00D', they are actually indexing with the value of 'ToString(0xF00D)'
        // according to the ECMAScript specification, so it is actually as if the user indexed with the string '"61453"'.
        // Thus, the text of all numeric literals equivalent to '61543' such as '0xF00D', '0xf00D', '0170015', etc. are not valid numeric names
        // because their 'ToString' representation is not equal to their original text.
        // This is motivated by ECMA-262 sections 9.3.1, 9.8.1, 11.1.5, and 11.2.1.
        //
        // Here, we test whether 'ToString(ToNumber(name))' is exactly equal to 'name'.
        // The '+' prefix operator is equivalent here to applying the abstract ToNumber operation.
        // Applying the 'toString()' method on a number gives us the abstract ToString operation on a number.
        //
        // Note that this accepts the values 'Infinity', '-Infinity', and 'NaN', and that this is intentional.
        // This is desired behavior, because when indexing with them as numeric entities, you are indexing
        // with the strings '"Infinity"', '"-Infinity"', and '"NaN"' respectively.
        return (+name).toString() === name;
    }
    function checkComputedPropertyName(node) {
        let links = getNodeLinks(node.expression);
        if (!links.resolvedType) {
            links.resolvedType = checkExpression(node.expression);
            // This will allow types number, string, symbol or any. It will also allow enums, the unknown
            // type, and any union of these types (like string | number).
            if (links.resolvedType.flags & 6144 /* Nullable */ ||
                !isTypeAssignableToKind(links.resolvedType, 262178 /* StringLike */ | 84 /* NumberLike */ | 512 /* ESSymbol */) &&
                !isTypeAssignableTo(links.resolvedType, getUnionType([stringType, numberType, esSymbolType]))) {
                error(node, ts.Diagnostics.A_computed_property_name_must_be_of_type_string_number_symbol_or_any);
            }
            else {
                checkThatExpressionIsProperSymbolReference(node.expression, links.resolvedType, /*reportError*/ true);
            }
        }
        return links.resolvedType;
    }
    function getObjectLiteralIndexInfo(propertyNodes, offset, properties, kind) {
        let propTypes = [];
        for (let i = 0; i < properties.length; i++) {
            if (kind === 0 /* String */ || isNumericName(propertyNodes[i + offset].name)) {
                propTypes.push(getTypeOfSymbol(properties[i]));
            }
        }
        let unionType = propTypes.length ? getUnionType(propTypes, /*subtypeReduction*/ true) : undefinedType;
        return createIndexInfo(unionType, /*isReadonly*/ false);
    }
    function checkObjectLiteral(node, checkMode) {
        let inDestructuringPattern = ts.isAssignmentTarget(node);
        // Grammar checking
        checkGrammarObjectLiteralExpression(node, inDestructuringPattern);
        let propertiesTable = ts.createSymbolTable();
        let propertiesArray = [];
        let spread = emptyObjectType;
        let propagatedFlags = 0;
        let contextualType = getApparentTypeOfContextualType(node);
        let contextualTypeHasPattern = contextualType && contextualType.pattern &&
            (contextualType.pattern.kind === 174 /* ObjectBindingPattern */ || contextualType.pattern.kind === 178 /* ObjectLiteralExpression */);
        let isJSObjectLiteral = !contextualType && ts.isInJavaScriptFile(node);
        let typeFlags = 0;
        let patternWithComputedProperties = false;
        let hasComputedStringProperty = false;
        let hasComputedNumberProperty = false;
        let isInJSFile = ts.isInJavaScriptFile(node);
        let offset = 0;
        for (let i = 0; i < node.properties.length; i++) {
            let memberDecl = node.properties[i];
            let member = memberDecl.symbol;
            let literalName = void 0;
            if (memberDecl.kind === 264 /* PropertyAssignment */ ||
                memberDecl.kind === 265 /* ShorthandPropertyAssignment */ ||
                ts.isObjectLiteralMethod(memberDecl)) {
                let jsdocType = void 0;
                if (isInJSFile) {
                    jsdocType = getTypeForDeclarationFromJSDocComment(memberDecl);
                }
                let type = void 0;
                if (memberDecl.kind === 264 /* PropertyAssignment */) {
                    if (memberDecl.name.kind === 144 /* ComputedPropertyName */) {
                        let t = checkComputedPropertyName(memberDecl.name);
                        if (t.flags & 224 /* Literal */) {
                            literalName = ts.escapeLeadingUnderscores("" + t.value);
                        }
                    }
                    type = checkPropertyAssignment(memberDecl, checkMode);
                }
                else if (memberDecl.kind === SyntaxKind.MethodDeclaration) {
                    type = checkObjectLiteralMethod(memberDecl, checkMode);
                }
                else {
                    ts.Debug.assert(memberDecl.kind === 265 /* ShorthandPropertyAssignment */);
                    type = checkExpressionForMutableLocation(memberDecl.name, checkMode);
                }
                if (jsdocType) {
                    checkTypeAssignableTo(type, jsdocType, memberDecl);
                    type = jsdocType;
                }
                typeFlags |= type.flags;
                let prop = createSymbol(SymbolFlags.Property | member.flags, literalName || member.escapedName);
                if (inDestructuringPattern) {
                    // If object literal is an assignment pattern and if the assignment pattern specifies a default value
                    // for the property, make the property optional.
                    let isOptional = (memberDecl.kind === 264 /* PropertyAssignment */ && hasDefaultValue(memberDecl.initializer)) ||
                        (memberDecl.kind === 265 /* ShorthandPropertyAssignment */ && memberDecl.objectAssignmentInitializer);
                    if (isOptional) {
                        prop.flags |= 16777216 /* Optional */;
                    }
                    if (!literalName && ts.hasDynamicName(memberDecl)) {
                        patternWithComputedProperties = true;
                    }
                }
                else if (contextualTypeHasPattern && !(getObjectFlags(contextualType) & 512 /* ObjectLiteralPatternWithComputedProperties */)) {
                    // If object literal is contextually typed by the implied type of a binding pattern, and if the
                    // binding pattern specifies a default value for the property, make the property optional.
                    let impliedProp = getPropertyOfType(contextualType, member.escapedName);
                    if (impliedProp) {
                        prop.flags |= impliedProp.flags & 16777216 /* Optional */;
                    }
                    else if (!compilerOptions.suppressExcessPropertyErrors && !getIndexInfoOfType(contextualType, 0 /* String */)) {
                        error(memberDecl.name, ts.Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(member), typeToString(contextualType));
                    }
                }
                prop.declarations = member.declarations;
                prop.parent = member.parent;
                if (member.valueDeclaration) {
                    prop.valueDeclaration = member.valueDeclaration;
                }
                prop.type = type;
                prop.target = member;
                member = prop;
            }
            else if (memberDecl.kind === 266 /* SpreadAssignment */) {
                if (languageVersion < 2 /* ES2015 */) {
                    checkExternalEmitHelpers(memberDecl, 2 /* Assign */);
                }
                if (propertiesArray.length > 0) {
                    spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, propagatedFlags);
                    propertiesArray = [];
                    propertiesTable = ts.createSymbolTable();
                    hasComputedStringProperty = false;
                    hasComputedNumberProperty = false;
                    typeFlags = 0;
                }
                let type = checkExpression(memberDecl.expression);
                if (!isValidSpreadType(type)) {
                    error(memberDecl, ts.Diagnostics.Spread_types_may_only_be_created_from_object_types);
                    return unknownType;
                }
                spread = getSpreadType(spread, type, node.symbol, propagatedFlags);
                offset = i + 1;
                continue;
            }
            else {
                // TypeScript 1.0 spec (April 2014)
                // A get accessor declaration is processed in the same manner as
                // an ordinary function declaration(section 6.1) with no parameters.
                // A set accessor declaration is processed in the same manner
                // as an ordinary function declaration with a single parameter and a Void return type.
                ts.Debug.assert(memberDecl.kind === 153 /* GetAccessor */ || memberDecl.kind === 154 /* SetAccessor */);
                checkNodeDeferred(memberDecl);
            }
            if (!literalName && ts.hasDynamicName(memberDecl)) {
                if (isNumericName(memberDecl.name)) {
                    hasComputedNumberProperty = true;
                }
                else {
                    hasComputedStringProperty = true;
                }
            }
            else {
                propertiesTable.set(member.escapedName, member);
            }
            propertiesArray.push(member);
        }
        // If object literal is contextually typed by the implied type of a binding pattern, augment the result
        // type with those properties for which the binding pattern specifies a default value.
        if (contextualTypeHasPattern) {
            for (let _i = 0, _a = getPropertiesOfType(contextualType); _i < _a.length; _i++) {
                let prop = _a[_i];
                if (!propertiesTable.get(prop.escapedName)) {
                    if (!(prop.flags & 16777216 /* Optional */)) {
                        error(prop.valueDeclaration || prop.bindingElement, ts.Diagnostics.Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value);
                    }
                    propertiesTable.set(prop.escapedName, prop);
                    propertiesArray.push(prop);
                }
            }
        }
        if (spread !== emptyObjectType) {
            if (propertiesArray.length > 0) {
                spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, propagatedFlags);
            }
            return spread;
        }
        return createObjectLiteralType();
        function createObjectLiteralType() {
            let stringIndexInfo = isJSObjectLiteral ? jsObjectLiteralIndexInfo : hasComputedStringProperty ? getObjectLiteralIndexInfo(node.properties, offset, propertiesArray, 0 /* String */) : undefined;
            let numberIndexInfo = hasComputedNumberProperty && !isJSObjectLiteral ? getObjectLiteralIndexInfo(node.properties, offset, propertiesArray, 1 /* Number */) : undefined;
            let result = createAnonymousType(node.symbol, propertiesTable, ts.emptyArray, ts.emptyArray, stringIndexInfo, numberIndexInfo);
            let freshObjectLiteralFlag = compilerOptions.suppressExcessPropertyErrors ? 0 : 1048576 /* FreshLiteral */;
            result.flags |= 4194304 /* ContainsObjectLiteral */ | freshObjectLiteralFlag | (typeFlags & 14680064 /* PropagatingFlags */);
            result.objectFlags |= 128 /* ObjectLiteral */;
            if (patternWithComputedProperties) {
                result.objectFlags |= 512 /* ObjectLiteralPatternWithComputedProperties */;
            }
            if (inDestructuringPattern) {
                result.pattern = node;
            }
            if (!(result.flags & 6144 /* Nullable */)) {
                propagatedFlags |= (result.flags & 14680064 /* PropagatingFlags */);
            }
            return result;
        }
    }
    function isValidSpreadType(type) {
        return !!(type.flags & (1 /* Any */ | 16777216 /* NonPrimitive */) ||
            getFalsyFlags(type) & 7392 /* DefinitelyFalsy */ && isValidSpreadType(removeDefinitelyFalsyTypes(type)) ||
            type.flags & TypeFlags.Object && !isGenericMappedType(type) ||
            type.flags & 196608 /* UnionOrIntersection */ && !ts.forEach(type.types, function (t) { return !isValidSpreadType(t); }));
    }
    function checkJsxSelfClosingElement(node) {
        checkJsxOpeningLikeElementOrOpeningFragment(node);
        return getJsxGlobalElementType() || anyType;
    }
    function checkJsxElement(node) {
        // Check attributes
        checkJsxOpeningLikeElementOrOpeningFragment(node.openingElement);
        // Perform resolution on the closing tag so that rename/go to definition/etc work
        if (isJsxIntrinsicIdentifier(node.closingElement.tagName)) {
            getIntrinsicTagSymbol(node.closingElement);
        }
        else {
            checkExpression(node.closingElement.tagName);
        }
        return getJsxGlobalElementType() || anyType;
    }
    function checkJsxFragment(node) {
        checkJsxOpeningLikeElementOrOpeningFragment(node.openingFragment);
        if (compilerOptions.jsx === 2 /* React */ && compilerOptions.jsxFactory) {
            error(node, ts.Diagnostics.JSX_fragment_is_not_supported_when_using_jsxFactory);
        }
        return getJsxGlobalElementType() || anyType;
    }
    /**
     * Returns true iff the JSX element name would be a valid JS identifier, ignoring restrictions about keywords not being identifiers
     */
    function isUnhyphenatedJsxName(name) {
        // - is the only character supported in JSX attribute names that isn't valid in JavaScript identifiers
        return !ts.stringContains(name, "-");
    }
    /**
     * Returns true iff React would emit this tag name as a string rather than an identifier or qualified name
     */
    function isJsxIntrinsicIdentifier(tagName) {
        // TODO (yuisu): comment
        switch (tagName.kind) {
            case 179 /* PropertyAccessExpression */:
            case 99 /* ThisKeyword */:
                return false;
            case 71 /* Identifier */:
                return ts.isIntrinsicJsxName(tagName.escapedText);
            default:
                ts.Debug.fail();
        }
    }
    /**
     * Get attributes type of the JSX opening-like element. The result is from resolving "attributes" property of the opening-like element.
     *
     * @param openingLikeElement a JSX opening-like element
     * @param filter a function to remove attributes that will not participate in checking whether attributes are assignable
     * @return an anonymous type (similar to the one returned by checkObjectLiteral) in which its properties are attributes property.
     * @remarks Because this function calls getSpreadType, it needs to use the same checks as checkObjectLiteral,
     * which also calls getSpreadType.
     */
    function createJsxAttributesTypeFromAttributesProperty(openingLikeElement, filter, checkMode) {
        let attributes = openingLikeElement.attributes;
        let attributesTable = ts.createSymbolTable();
        let spread = emptyObjectType;
        let attributesArray = [];
        let hasSpreadAnyType = false;
        let typeToIntersect;
        let explicitlySpecifyChildrenAttribute = false;
        let jsxChildrenPropertyName = getJsxElementChildrenPropertyname();
        for (let _i = 0, _a = attributes.properties; _i < _a.length; _i++) {
            let attributeDecl = _a[_i];
            let member = attributeDecl.symbol;
            if (ts.isJsxAttribute(attributeDecl)) {
                let exprType = attributeDecl.initializer ?
                    checkExpression(attributeDecl.initializer, checkMode) :
                    trueType; // <Elem attr /> is sugar for <Elem attr={true} />
                let attributeSymbol = createSymbol(SymbolFlags.Property | SymbolFlags.Transient | member.flags, member.escapedName);
                attributeSymbol.declarations = member.declarations;
                attributeSymbol.parent = member.parent;
                if (member.valueDeclaration) {
                    attributeSymbol.valueDeclaration = member.valueDeclaration;
                }
                attributeSymbol.type = exprType;
                attributeSymbol.target = member;
                attributesTable.set(attributeSymbol.escapedName, attributeSymbol);
                attributesArray.push(attributeSymbol);
                if (attributeDecl.name.escapedText === jsxChildrenPropertyName) {
                    explicitlySpecifyChildrenAttribute = true;
                }
            }
            else {
                ts.Debug.assert(attributeDecl.kind === 258 /* JsxSpreadAttribute */);
                if (attributesArray.length > 0) {
                    spread = getSpreadType(spread, createJsxAttributesType(attributes.symbol, attributesTable), openingLikeElement.symbol, /*propagatedFlags*/ 0);
                    attributesArray = [];
                    attributesTable = ts.createSymbolTable();
                }
                let exprType = checkExpression(attributeDecl.expression);
                if (isTypeAny(exprType)) {
                    hasSpreadAnyType = true;
                }
                if (isValidSpreadType(exprType)) {
                    spread = getSpreadType(spread, exprType, openingLikeElement.symbol, /*propagatedFlags*/ 0);
                }
                else {
                    typeToIntersect = typeToIntersect ? getIntersectionType([typeToIntersect, exprType]) : exprType;
                }
            }
        }
        if (!hasSpreadAnyType) {
            if (spread !== emptyObjectType) {
                if (attributesArray.length > 0) {
                    spread = getSpreadType(spread, createJsxAttributesType(attributes.symbol, attributesTable), openingLikeElement.symbol, /*propagatedFlags*/ 0);
                }
                attributesArray = getPropertiesOfType(spread);
            }
            attributesTable = ts.createSymbolTable();
            for (let _b = 0, attributesArray_1 = attributesArray; _b < attributesArray_1.length; _b++) {
                let attr = attributesArray_1[_b];
                if (!filter || filter(attr)) {
                    attributesTable.set(attr.escapedName, attr);
                }
            }
        }
        // Handle children attribute
        let parent = openingLikeElement.parent.kind === 249 /* JsxElement */ ? openingLikeElement.parent : undefined;
        // We have to check that openingElement of the parent is the one we are visiting as this may not be true for selfClosingElement
        if (parent && parent.openingElement === openingLikeElement && parent.children.length > 0) {
            let childrenTypes = checkJsxChildren(parent, checkMode);
            if (!hasSpreadAnyType && jsxChildrenPropertyName && jsxChildrenPropertyName !== "") {
                // Error if there is a attribute named "children" explicitly specified and children element.
                // This is because children element will overwrite the value from attributes.
                // Note: we will not warn "children" attribute overwritten if "children" attribute is specified in object spread.
                if (explicitlySpecifyChildrenAttribute) {
                    error(attributes, ts.Diagnostics._0_are_specified_twice_The_attribute_named_0_will_be_overwritten, ts.unescapeLeadingUnderscores(jsxChildrenPropertyName));
                }
                // If there are children in the body of JSX element, create dummy attribute "children" with anyType so that it will pass the attribute checking process
                let childrenPropSymbol = createSymbol(SymbolFlags.Property | SymbolFlags.Transient, jsxChildrenPropertyName);
                childrenPropSymbol.type = childrenTypes.length === 1 ?
                    childrenTypes[0] :
                    createArrayType(getUnionType(childrenTypes, /*subtypeReduction*/ false));
                attributesTable.set(jsxChildrenPropertyName, childrenPropSymbol);
            }
        }
        if (hasSpreadAnyType) {
            return anyType;
        }
        let attributeType = createJsxAttributesType(attributes.symbol, attributesTable);
        return typeToIntersect && attributesTable.size ? getIntersectionType([typeToIntersect, attributeType]) :
            typeToIntersect ? typeToIntersect : attributeType;
        /**
         * Create anonymous type from given attributes symbol table.
         * @param symbol a symbol of JsxAttributes containing attributes corresponding to attributesTable
         * @param attributesTable a symbol table of attributes property
         */
        function createJsxAttributesType(symbol, attributesTable) {
            let result = createAnonymousType(symbol, attributesTable, ts.emptyArray, ts.emptyArray, /*stringIndexInfo*/ undefined, /*numberIndexInfo*/ undefined);
            result.flags |= 33554432 /* JsxAttributes */ | 4194304 /* ContainsObjectLiteral */;
            result.objectFlags |= 128 /* ObjectLiteral */;
            return result;
        }
    }
    function checkJsxChildren(node, checkMode) {
        let childrenTypes = [];
        for (let _i = 0, _a = node.children; _i < _a.length; _i++) {
            let child = _a[_i];
            // In React, JSX text that contains only whitespaces will be ignored so we don't want to type-check that
            // because then type of children property will have constituent of string type.
            if (child.kind === 10 /* JsxText */) {
                if (!child.containsOnlyWhiteSpaces) {
                    childrenTypes.push(stringType);
                }
            }
            else {
                childrenTypes.push(checkExpression(child, checkMode));
            }
        }
        return childrenTypes;
    }
    /**
     * Check attributes property of opening-like element. This function is called during chooseOverload to get call signature of a JSX opening-like element.
     * (See "checkApplicableSignatureForJsxOpeningLikeElement" for how the function is used)
     * @param node a JSXAttributes to be resolved of its type
     */
    function checkJsxAttributes(node, checkMode) {
        return createJsxAttributesTypeFromAttributesProperty(node.parent, /*filter*/ undefined, checkMode);
    }
    function getJsxType(name) {
        let jsxType = jsxTypes.get(name);
        if (jsxType === undefined) {
            jsxTypes.set(name, jsxType = getExportedTypeFromNamespace(JsxNames.JSX, name) || unknownType);
        }
        return jsxType;
    }
    /**
     * Looks up an intrinsic tag name and returns a symbol that either points to an intrinsic
     * property (in which case nodeLinks.jsxFlags will be IntrinsicNamedElement) or an intrinsic
     * string index signature (in which case nodeLinks.jsxFlags will be IntrinsicIndexedElement).
     * May also return unknownSymbol if both of these lookups fail.
     */
    function getIntrinsicTagSymbol(node) {
        let links = getNodeLinks(node);
        if (!links.resolvedSymbol) {
            let intrinsicElementsType = getJsxType(JsxNames.IntrinsicElements);
            if (intrinsicElementsType !== unknownType) {
                // Property case
                if (!ts.isIdentifier(node.tagName))
                    throw ts.Debug.fail();
                let intrinsicProp = getPropertyOfType(intrinsicElementsType, node.tagName.escapedText);
                if (intrinsicProp) {
                    links.jsxFlags |= 1 /* IntrinsicNamedElement */;
                    return links.resolvedSymbol = intrinsicProp;
                }
                // Intrinsic string indexer case
                let indexSignatureType = getIndexTypeOfType(intrinsicElementsType, 0 /* String */);
                if (indexSignatureType) {
                    links.jsxFlags |= 2 /* IntrinsicIndexedElement */;
                    return links.resolvedSymbol = intrinsicElementsType.symbol;
                }
                // Wasn't found
                error(node, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.idText(node.tagName), "JSX." + JsxNames.IntrinsicElements);
                return links.resolvedSymbol = unknownSymbol;
            }
            else {
                if (noImplicitAny) {
                    error(node, ts.Diagnostics.JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists, ts.unescapeLeadingUnderscores(JsxNames.IntrinsicElements));
                }
                return links.resolvedSymbol = unknownSymbol;
            }
        }
        return links.resolvedSymbol;
    }
    /**
     * Given a JSX element that is a class element, finds the Element Instance Type. If the
     * element is not a class element, or the class element type cannot be determined, returns 'undefined'.
     * For example, in the element <MyClass>, the element instance type is `MyClass` (not `typeof MyClass`).
     */
    function getJsxElementInstanceType(node, valueType) {
        ts.Debug.assert(!(valueType.flags & 65536 /* Union */));
        if (isTypeAny(valueType)) {
            // Short-circuit if the class tag is using an element type 'any'
            return anyType;
        }
        // Resolve the signatures, preferring constructor
        let signatures = getSignaturesOfType(valueType, 1 /* Construct */);
        if (signatures.length === 0) {
            // No construct signatures, try call signatures
            signatures = getSignaturesOfType(valueType, 0 /* Call */);
            if (signatures.length === 0) {
                // We found no signatures at all, which is an error
                error(node.tagName, ts.Diagnostics.JSX_element_type_0_does_not_have_any_construct_or_call_signatures, ts.getTextOfNode(node.tagName));
                return unknownType;
            }
        }
        let instantiatedSignatures = [];
        for (let _i = 0, signatures_3 = signatures; _i < signatures_3.length; _i++) {
            let signature = signatures_3[_i];
            if (signature.typeParameters) {
                let isJavascript = ts.isInJavaScriptFile(node);
                let typeArguments = fillMissingTypeArguments(/*typeArguments*/ undefined, signature.typeParameters, /*minTypeArgumentCount*/ 0, isJavascript);
                instantiatedSignatures.push(getSignatureInstantiation(signature, typeArguments, isJavascript));
            }
            else {
                instantiatedSignatures.push(signature);
            }
        }
        return getUnionType(ts.map(instantiatedSignatures, getReturnTypeOfSignature), /*subtypeReduction*/ true);
    }
    /**
     * Look into JSX namespace and then look for container with matching name as nameOfAttribPropContainer.
     * Get a single property from that container if existed. Report an error if there are more than one property.
     *
     * @param nameOfAttribPropContainer a string of value JsxNames.ElementAttributesPropertyNameContainer or JsxNames.ElementChildrenAttributeNameContainer
     *          if other string is given or the container doesn't exist, return undefined.
     */
    function getNameFromJsxElementAttributesContainer(nameOfAttribPropContainer) {
        // JSX
        let jsxNamespace = getGlobalSymbol(JsxNames.JSX, SymbolFlags.Namespace, /*diagnosticMessage*/ undefined);
        // JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute [symbol]
        let jsxElementAttribPropInterfaceSym = jsxNamespace && getSymbol(jsxNamespace.exports, nameOfAttribPropContainer, SymbolFlags.Type);
        // JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute [type]
        let jsxElementAttribPropInterfaceType = jsxElementAttribPropInterfaceSym && getDeclaredTypeOfSymbol(jsxElementAttribPropInterfaceSym);
        // The properties of JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute
        let propertiesOfJsxElementAttribPropInterface = jsxElementAttribPropInterfaceType && getPropertiesOfType(jsxElementAttribPropInterfaceType);
        if (propertiesOfJsxElementAttribPropInterface) {
            // Element Attributes has zero properties, so the element attributes type will be the class instance type
            if (propertiesOfJsxElementAttribPropInterface.length === 0) {
                return "";
            }
            else if (propertiesOfJsxElementAttribPropInterface.length === 1) {
                return propertiesOfJsxElementAttribPropInterface[0].escapedName;
            }
            else if (propertiesOfJsxElementAttribPropInterface.length > 1) {
                // More than one property on ElementAttributesProperty is an error
                error(jsxElementAttribPropInterfaceSym.declarations[0], ts.Diagnostics.The_global_type_JSX_0_may_not_have_more_than_one_property, ts.unescapeLeadingUnderscores(nameOfAttribPropContainer));
            }
        }
        return undefined;
    }
    /// e.g. "props" for React.d.ts,
    /// or 'undefined' if ElementAttributesProperty doesn't exist (which means all
    ///     non-intrinsic elements' attributes type is 'any'),
    /// or '' if it has 0 properties (which means every
    ///     non-intrinsic elements' attributes type is the element instance type)
    function getJsxElementPropertiesName() {
        if (!_hasComputedJsxElementPropertiesName) {
            _hasComputedJsxElementPropertiesName = true;
            _jsxElementPropertiesName = getNameFromJsxElementAttributesContainer(JsxNames.ElementAttributesPropertyNameContainer);
        }
        return _jsxElementPropertiesName;
    }
    function getJsxElementChildrenPropertyname() {
        if (!_hasComputedJsxElementChildrenPropertyName) {
            _hasComputedJsxElementChildrenPropertyName = true;
            _jsxElementChildrenPropertyName = getNameFromJsxElementAttributesContainer(JsxNames.ElementChildrenAttributeNameContainer);
        }
        return _jsxElementChildrenPropertyName;
    }
    function getApparentTypeOfJsxPropsType(propsType) {
        if (!propsType) {
            return undefined;
        }
        if (propsType.flags & 131072 /* Intersection */) {
            let propsApparentType = [];
            for (let _i = 0, _a = propsType.types; _i < _a.length; _i++) {
                let t = _a[_i];
                propsApparentType.push(getApparentType(t));
            }
            return getIntersectionType(propsApparentType);
        }
        return getApparentType(propsType);
    }
    /**
     * Get JSX attributes type by trying to resolve openingLikeElement as a stateless function component.
     * Return only attributes type of successfully resolved call signature.
     * This function assumes that the caller handled other possible element type of the JSX element (e.g. stateful component)
     * Unlike tryGetAllJsxStatelessFunctionAttributesType, this function is a default behavior of type-checkers.
     * @param openingLikeElement a JSX opening-like element to find attributes type
     * @param elementType a type of the opening-like element. This elementType can't be an union type
     * @param elemInstanceType an element instance type (the result of newing or invoking this tag)
     * @param elementClassType a JSX-ElementClass type. This is a result of looking up ElementClass interface in the JSX global
     */
    function defaultTryGetJsxStatelessFunctionAttributesType(openingLikeElement, elementType, elemInstanceType, elementClassType) {
        ts.Debug.assert(!(elementType.flags & 65536 /* Union */));
        if (!elementClassType || !isTypeAssignableTo(elemInstanceType, elementClassType)) {
            let jsxStatelessElementType = getJsxGlobalStatelessElementType();
            if (jsxStatelessElementType) {
                // We don't call getResolvedSignature here because we have already resolve the type of JSX Element.
                let callSignature = getResolvedJsxStatelessFunctionSignature(openingLikeElement, elementType, /*candidatesOutArray*/ undefined);
                if (callSignature !== unknownSignature) {
                    let callReturnType = callSignature && getReturnTypeOfSignature(callSignature);
                    let paramType = callReturnType && (callSignature.parameters.length === 0 ? emptyObjectType : getTypeOfSymbol(callSignature.parameters[0]));
                    paramType = getApparentTypeOfJsxPropsType(paramType);
                    if (callReturnType && isTypeAssignableTo(callReturnType, jsxStatelessElementType)) {
                        // Intersect in JSX.IntrinsicAttributes if it exists
                        let intrinsicAttributes = getJsxType(JsxNames.IntrinsicAttributes);
                        if (intrinsicAttributes !== unknownType) {
                            paramType = intersectTypes(intrinsicAttributes, paramType);
                        }
                        return paramType;
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Get JSX attributes type by trying to resolve openingLikeElement as a stateless function component.
     * Return all attributes type of resolved call signature including candidate signatures.
     * This function assumes that the caller handled other possible element type of the JSX element.
     * This function is a behavior used by language service when looking up completion in JSX element.
     * @param openingLikeElement a JSX opening-like element to find attributes type
     * @param elementType a type of the opening-like element. This elementType can't be an union type
     * @param elemInstanceType an element instance type (the result of newing or invoking this tag)
     * @param elementClassType a JSX-ElementClass type. This is a result of looking up ElementClass interface in the JSX global
     */
    function tryGetAllJsxStatelessFunctionAttributesType(openingLikeElement, elementType, elemInstanceType, elementClassType) {
        ts.Debug.assert(!(elementType.flags & 65536 /* Union */));
        if (!elementClassType || !isTypeAssignableTo(elemInstanceType, elementClassType)) {
            // Is this is a stateless function component? See if its single signature's return type is assignable to the JSX Element Type
            let jsxStatelessElementType = getJsxGlobalStatelessElementType();
            if (jsxStatelessElementType) {
                // We don't call getResolvedSignature because here we have already resolve the type of JSX Element.
                let candidatesOutArray = [];
                getResolvedJsxStatelessFunctionSignature(openingLikeElement, elementType, candidatesOutArray);
                let result = void 0;
                let allMatchingAttributesType = void 0;
                for (let _i = 0, candidatesOutArray_1 = candidatesOutArray; _i < candidatesOutArray_1.length; _i++) {
                    let candidate = candidatesOutArray_1[_i];
                    let callReturnType = getReturnTypeOfSignature(candidate);
                    let paramType = callReturnType && (candidate.parameters.length === 0 ? emptyObjectType : getTypeOfSymbol(candidate.parameters[0]));
                    paramType = getApparentTypeOfJsxPropsType(paramType);
                    if (callReturnType && isTypeAssignableTo(callReturnType, jsxStatelessElementType)) {
                        let shouldBeCandidate = true;
                        for (let _a = 0, _b = openingLikeElement.attributes.properties; _a < _b.length; _a++) {
                            let attribute = _b[_a];
                            if (ts.isJsxAttribute(attribute) &&
                                isUnhyphenatedJsxName(attribute.name.escapedText) &&
                                !getPropertyOfType(paramType, attribute.name.escapedText)) {
                                shouldBeCandidate = false;
                                break;
                            }
                        }
                        if (shouldBeCandidate) {
                            result = intersectTypes(result, paramType);
                        }
                        allMatchingAttributesType = intersectTypes(allMatchingAttributesType, paramType);
                    }
                }
                // If we can't find any matching, just return everything.
                if (!result) {
                    result = allMatchingAttributesType;
                }
                // Intersect in JSX.IntrinsicAttributes if it exists
                let intrinsicAttributes = getJsxType(JsxNames.IntrinsicAttributes);
                if (intrinsicAttributes !== unknownType) {
                    result = intersectTypes(intrinsicAttributes, result);
                }
                return result;
            }
        }
        return undefined;
    }
    /**
     * Resolve attributes type of the given opening-like element. The attributes type is a type of attributes associated with the given elementType.
     * For instance:
     *      declare function Foo(attr: { p1: string}): JSX.Element;
     *      <Foo p1={10} />;  // This function will try resolve "Foo" and return an attributes type of "Foo" which is "{ p1: string }"
     *
     * The function is intended to initially be called from getAttributesTypeFromJsxOpeningLikeElement which already handle JSX-intrinsic-element..
     * This function will try to resolve custom JSX attributes type in following order: string literal, stateless function, and stateful component
     *
     * @param openingLikeElement a non-intrinsic JSXOPeningLikeElement
     * @param shouldIncludeAllStatelessAttributesType a boolean indicating whether to include all attributes types from all stateless function signature
     * @param elementType an instance type of the given opening-like element. If undefined, the function will check type openinglikeElement's tagname.
     * @param elementClassType a JSX-ElementClass type. This is a result of looking up ElementClass interface in the JSX global (imported from react.d.ts)
     * @return attributes type if able to resolve the type of node
     *         anyType if there is no type ElementAttributesProperty or there is an error
     *         emptyObjectType if there is no "prop" in the element instance type
     */
    function resolveCustomJsxElementAttributesType(openingLikeElement, shouldIncludeAllStatelessAttributesType, elementType, elementClassType) {
        if (elementType === void 0) { elementType = checkExpression(openingLikeElement.tagName); }
        if (elementType.flags & 65536 /* Union */) {
            let types = elementType.types;
            return getUnionType(types.map(function (type) {
                return resolveCustomJsxElementAttributesType(openingLikeElement, shouldIncludeAllStatelessAttributesType, type, elementClassType);
            }), /*subtypeReduction*/ true);
        }
        // If the elemType is a string type, we have to return anyType to prevent an error downstream as we will try to find construct or call signature of the type
        if (elementType.flags & 2 /* String */) {
            return anyType;
        }
        else if (elementType.flags & 32 /* StringLiteral */) {
            // If the elemType is a stringLiteral type, we can then provide a check to make sure that the string literal type is one of the Jsx intrinsic element type
            // For example:
            //      let CustomTag: "h1" = "h1";
            //      <CustomTag> Hello World </CustomTag>
            let intrinsicElementsType = getJsxType(JsxNames.IntrinsicElements);
            if (intrinsicElementsType !== unknownType) {
                let stringLiteralTypeName = elementType.value;
                let intrinsicProp = getPropertyOfType(intrinsicElementsType, ts.escapeLeadingUnderscores(stringLiteralTypeName));
                if (intrinsicProp) {
                    return getTypeOfSymbol(intrinsicProp);
                }
                let indexSignatureType = getIndexTypeOfType(intrinsicElementsType, 0 /* String */);
                if (indexSignatureType) {
                    return indexSignatureType;
                }
                error(openingLikeElement, ts.Diagnostics.Property_0_does_not_exist_on_type_1, stringLiteralTypeName, "JSX." + JsxNames.IntrinsicElements);
            }
            // If we need to report an error, we already done so here. So just return any to prevent any more error downstream
            return anyType;
        }
        // Get the element instance type (the result of newing or invoking this tag)
        let elemInstanceType = getJsxElementInstanceType(openingLikeElement, elementType);
        // If we should include all stateless attributes type, then get all attributes type from all stateless function signature.
        // Otherwise get only attributes type from the signature picked by choose-overload logic.
        let statelessAttributesType = shouldIncludeAllStatelessAttributesType ?
            tryGetAllJsxStatelessFunctionAttributesType(openingLikeElement, elementType, elemInstanceType, elementClassType) :
            defaultTryGetJsxStatelessFunctionAttributesType(openingLikeElement, elementType, elemInstanceType, elementClassType);
        if (statelessAttributesType) {
            return statelessAttributesType;
        }
        // Issue an error if this return type isn't assignable to JSX.ElementClass
        if (elementClassType) {
            checkTypeRelatedTo(elemInstanceType, elementClassType, assignableRelation, openingLikeElement, ts.Diagnostics.JSX_element_type_0_is_not_a_constructor_function_for_JSX_elements);
        }
        if (isTypeAny(elemInstanceType)) {
            return elemInstanceType;
        }
        let propsName = getJsxElementPropertiesName();
        if (propsName === undefined) {
            // There is no type ElementAttributesProperty, return 'any'
            return anyType;
        }
        else if (propsName === "") {
            // If there is no e.g. 'props' member in ElementAttributesProperty, use the element class type instead
            return elemInstanceType;
        }
        else {
            let attributesType = getTypeOfPropertyOfType(elemInstanceType, propsName);
            if (!attributesType) {
                // There is no property named 'props' on this instance type
                return emptyObjectType;
            }
            else if (isTypeAny(attributesType) || (attributesType === unknownType)) {
                // Props is of type 'any' or unknown
                return attributesType;
            }
            else {
                // Normal case -- add in IntrinsicClassElements<T> and IntrinsicElements
                let apparentAttributesType = attributesType;
                let intrinsicClassAttribs = getJsxType(JsxNames.IntrinsicClassAttributes);
                if (intrinsicClassAttribs !== unknownType) {
                    let typeParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(intrinsicClassAttribs.symbol);
                    if (typeParams) {
                        if (typeParams.length === 1) {
                            apparentAttributesType = intersectTypes(createTypeReference(intrinsicClassAttribs, [elemInstanceType]), apparentAttributesType);
                        }
                    }
                    else {
                        apparentAttributesType = intersectTypes(attributesType, intrinsicClassAttribs);
                    }
                }
                let intrinsicAttribs = getJsxType(JsxNames.IntrinsicAttributes);
                if (intrinsicAttribs !== unknownType) {
                    apparentAttributesType = intersectTypes(intrinsicAttribs, apparentAttributesType);
                }
                return apparentAttributesType;
            }
        }
    }
    /**
     * Get attributes type of the given intrinsic opening-like Jsx element by resolving the tag name.
     * The function is intended to be called from a function which has checked that the opening element is an intrinsic element.
     * @param node an intrinsic JSX opening-like element
     */
    function getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node) {
        ts.Debug.assert(isJsxIntrinsicIdentifier(node.tagName));
        let links = getNodeLinks(node);
        if (!links.resolvedJsxElementAttributesType) {
            let symbol = getIntrinsicTagSymbol(node);
            if (links.jsxFlags & 1 /* IntrinsicNamedElement */) {
                return links.resolvedJsxElementAttributesType = getTypeOfSymbol(symbol);
            }
            else if (links.jsxFlags & 2 /* IntrinsicIndexedElement */) {
                return links.resolvedJsxElementAttributesType = getIndexInfoOfSymbol(symbol, 0 /* String */).type;
            }
            else {
                return links.resolvedJsxElementAttributesType = unknownType;
            }
        }
        return links.resolvedJsxElementAttributesType;
    }
    /**
     * Get attributes type of the given custom opening-like JSX element.
     * This function is intended to be called from a caller that handles intrinsic JSX element already.
     * @param node a custom JSX opening-like element
     * @param shouldIncludeAllStatelessAttributesType a boolean value used by language service to get all possible attributes type from an overload stateless function component
     */
    function getCustomJsxElementAttributesType(node, shouldIncludeAllStatelessAttributesType) {
        let links = getNodeLinks(node);
        let linkLocation = shouldIncludeAllStatelessAttributesType ? "resolvedJsxElementAllAttributesType" : "resolvedJsxElementAttributesType";
        if (!links[linkLocation]) {
            let elemClassType = getJsxGlobalElementClassType();
            return links[linkLocation] = resolveCustomJsxElementAttributesType(node, shouldIncludeAllStatelessAttributesType, /*elementType*/ undefined, elemClassType);
        }
        return links[linkLocation];
    }
    /**
     * Get all possible attributes type, especially from an overload stateless function component, of the given JSX opening-like element.
     * This function is called by language service (see: completions-tryGetGlobalSymbols).
     * @param node a JSX opening-like element to get attributes type for
     */
    function getAllAttributesTypeFromJsxOpeningLikeElement(node) {
        if (isJsxIntrinsicIdentifier(node.tagName)) {
            return getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node);
        }
        else {
            // Because in language service, the given JSX opening-like element may be incomplete and therefore,
            // we can't resolve to exact signature if the element is a stateless function component so the best thing to do is return all attributes type from all overloads.
            return getCustomJsxElementAttributesType(node, /*shouldIncludeAllStatelessAttributesType*/ true);
        }
    }
    /**
     * Get the attributes type, which indicates the attributes that are valid on the given JSXOpeningLikeElement.
     * @param node a JSXOpeningLikeElement node
     * @return an attributes type of the given node
     */
    function getAttributesTypeFromJsxOpeningLikeElement(node) {
        if (isJsxIntrinsicIdentifier(node.tagName)) {
            return getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node);
        }
        else {
            return getCustomJsxElementAttributesType(node, /*shouldIncludeAllStatelessAttributesType*/ false);
        }
    }
    /**
     * Given a JSX attribute, returns the symbol for the corresponds property
     * of the element attributes type. Will return unknownSymbol for attributes
     * that have no matching element attributes type property.
     */
    function getJsxAttributePropertySymbol(attrib) {
        let attributesType = getAttributesTypeFromJsxOpeningLikeElement(attrib.parent.parent);
        let prop = getPropertyOfType(attributesType, attrib.name.escapedText);
        return prop || unknownSymbol;
    }
    function getJsxGlobalElementClassType() {
        if (!deferredJsxElementClassType) {
            deferredJsxElementClassType = getExportedTypeFromNamespace(JsxNames.JSX, JsxNames.ElementClass);
        }
        return deferredJsxElementClassType;
    }
    function getJsxGlobalElementType() {
        if (!deferredJsxElementType) {
            deferredJsxElementType = getExportedTypeFromNamespace(JsxNames.JSX, JsxNames.Element);
        }
        return deferredJsxElementType;
    }
    function getJsxGlobalStatelessElementType() {
        if (!deferredJsxStatelessElementType) {
            let jsxElementType = getJsxGlobalElementType();
            if (jsxElementType) {
                deferredJsxStatelessElementType = getUnionType([jsxElementType, nullType]);
            }
        }
        return deferredJsxStatelessElementType;
    }
    /**
     * Returns all the properties of the Jsx.IntrinsicElements interface
     */
    function getJsxIntrinsicTagNames() {
        let intrinsics = getJsxType(JsxNames.IntrinsicElements);
        return intrinsics ? getPropertiesOfType(intrinsics) : ts.emptyArray;
    }
    function checkJsxPreconditions(errorNode) {
        // Preconditions for using JSX
        if ((compilerOptions.jsx || 0 /* None */) === 0 /* None */) {
            error(errorNode, ts.Diagnostics.Cannot_use_JSX_unless_the_jsx_flag_is_provided);
        }
        if (getJsxGlobalElementType() === undefined) {
            if (noImplicitAny) {
                error(errorNode, ts.Diagnostics.JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist);
            }
        }
    }
    function checkJsxOpeningLikeElementOrOpeningFragment(node) {
        let isNodeOpeningLikeElement = ts.isJsxOpeningLikeElement(node);
        if (isNodeOpeningLikeElement) {
            checkGrammarJsxElement(node);
        }
        checkJsxPreconditions(node);
        // The reactNamespace/jsxFactory's root symbol should be marked as 'used' so we don't incorrectly elide its import.
        // And if there is no reactNamespace/jsxFactory's symbol in scope when targeting React emit, we should issue an error.
        let reactRefErr = diagnostics && compilerOptions.jsx === 2 /* React */ ? ts.Diagnostics.Cannot_find_name_0 : undefined;
        let reactNamespace = getJsxNamespace();
        let reactLocation = isNodeOpeningLikeElement ? node.tagName : node;
        let reactSym = resolveName(reactLocation, reactNamespace, SymbolFlags.Value, reactRefErr, reactNamespace, /*isUse*/ true);
        if (reactSym) {
            // Mark local symbol as referenced here because it might not have been marked
            // if jsx emit was not react as there wont be error being emitted
            reactSym.isReferenced = true;
            // If react symbol is alias, mark it as refereced
            if (reactSym.flags & SymbolFlags.Alias && !isConstEnumOrConstEnumOnlyModule(resolveAlias(reactSym))) {
                markAliasSymbolAsReferenced(reactSym);
            }
        }
        if (isNodeOpeningLikeElement) {
            checkJsxAttributesAssignableToTagNameAttributes(node);
        }
        else {
            checkJsxChildren(node.parent);
        }
    }
    /**
     * Check if a property with the given name is known anywhere in the given type. In an object type, a property
     * is considered known if
     * 1. the object type is empty and the check is for assignability, or
     * 2. if the object type has index signatures, or
     * 3. if the property is actually declared in the object type
     *    (this means that 'toString', for example, is not usually a known property).
     * 4. In a union or intersection type,
     *    a property is considered known if it is known in any constituent type.
     * @param targetType a type to search a given name in
     * @param name a property name to search
     * @param isComparingJsxAttributes a boolean flag indicating whether we are searching in JsxAttributesType
     */
    function isKnownProperty(targetType, name, isComparingJsxAttributes) {
        if (targetType.flags & TypeFlags.Object) {
            let resolved = resolveStructuredTypeMembers(targetType);
            if (resolved.stringIndexInfo ||
                resolved.numberIndexInfo && isNumericLiteralName(name) ||
                getPropertyOfObjectType(targetType, name) ||
                isComparingJsxAttributes && !isUnhyphenatedJsxName(name)) {
                // For JSXAttributes, if the attribute has a hyphenated name, consider that the attribute to be known.
                return true;
            }
        }
        else if (targetType.flags & 196608 /* UnionOrIntersection */) {
            for (let _i = 0, _a = targetType.types; _i < _a.length; _i++) {
                let t = _a[_i];
                if (isKnownProperty(t, name, isComparingJsxAttributes)) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Check whether the given attributes of JSX opening-like element is assignable to the tagName attributes.
     *      Get the attributes type of the opening-like element through resolving the tagName, "target attributes"
     *      Check assignablity between given attributes property, "source attributes", and the "target attributes"
     * @param openingLikeElement an opening-like JSX element to check its JSXAttributes
     */
    function checkJsxAttributesAssignableToTagNameAttributes(openingLikeElement) {
        // The function involves following steps:
        //      1. Figure out expected attributes type by resolving tagName of the JSX opening-like element, targetAttributesType.
        //         During these steps, we will try to resolve the tagName as intrinsic name, stateless function, stateful component (in the order)
        //      2. Solved JSX attributes type given by users, sourceAttributesType, which is by resolving "attributes" property of the JSX opening-like element.
        //      3. Check if the two are assignable to each other
        // targetAttributesType is a type of an attributes from resolving tagName of an opening-like JSX element.
        let targetAttributesType = isJsxIntrinsicIdentifier(openingLikeElement.tagName) ?
            getIntrinsicAttributesTypeFromJsxOpeningLikeElement(openingLikeElement) :
            getCustomJsxElementAttributesType(openingLikeElement, /*shouldIncludeAllStatelessAttributesType*/ false);
        // sourceAttributesType is a type of an attributes properties.
        // i.e <div attr1={10} attr2="string" />
        //     attr1 and attr2 are treated as JSXAttributes attached in the JsxOpeningLikeElement as "attributes".
        let sourceAttributesType = createJsxAttributesTypeFromAttributesProperty(openingLikeElement, function (attribute) {
            return isUnhyphenatedJsxName(attribute.escapedName) || !!(getPropertyOfType(targetAttributesType, attribute.escapedName));
        });
        // If the targetAttributesType is an emptyObjectType, indicating that there is no property named 'props' on this instance type.
        // but there exists a sourceAttributesType, we need to explicitly give an error as normal assignability check allow excess properties and will pass.
        if (targetAttributesType === emptyObjectType && (isTypeAny(sourceAttributesType) || sourceAttributesType.properties.length > 0)) {
            error(openingLikeElement, ts.Diagnostics.JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property, ts.unescapeLeadingUnderscores(getJsxElementPropertiesName()));
        }
        else {
            // Check if sourceAttributesType assignable to targetAttributesType though this check will allow excess properties
            let isSourceAttributeTypeAssignableToTarget = checkTypeAssignableTo(sourceAttributesType, targetAttributesType, openingLikeElement.attributes.properties.length > 0 ? openingLikeElement.attributes : openingLikeElement);
            // After we check for assignability, we will do another pass to check that all explicitly specified attributes have correct name corresponding in targetAttributeType.
            // This will allow excess properties in spread type as it is very common pattern to spread outter attributes into React component in its render method.
            if (isSourceAttributeTypeAssignableToTarget && !isTypeAny(sourceAttributesType) && !isTypeAny(targetAttributesType)) {
                for (let _i = 0, _a = openingLikeElement.attributes.properties; _i < _a.length; _i++) {
                    let attribute = _a[_i];
                    if (ts.isJsxAttribute(attribute) && !isKnownProperty(targetAttributesType, attribute.name.escapedText, /*isComparingJsxAttributes*/ true)) {
                        error(attribute, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.idText(attribute.name), typeToString(targetAttributesType));
                        // We break here so that errors won't be cascading
                        break;
                    }
                }
            }
        }
    }
    function checkJsxExpression(node, checkMode) {
        if (node.expression) {
            let type = checkExpression(node.expression, checkMode);
            if (node.dotDotDotToken && type !== anyType && !isArrayType(type)) {
                error(node, ts.Diagnostics.JSX_spread_child_must_be_an_array_type);
            }
            return type;
        }
        else {
            return unknownType;
        }
    }
    // If a symbol is a synthesized symbol with no value declaration, we assume it is a property. Example of this are the synthesized
    // '.prototype' property as well as synthesized tuple index properties.
    function getDeclarationKindFromSymbol(s) {
        return s.valueDeclaration ? s.valueDeclaration.kind : SyntaxKind.PropertyDeclaration;
    }
    function getDeclarationNodeFlagsFromSymbol(s) {
        return s.valueDeclaration ? ts.getCombinedNodeFlags(s.valueDeclaration) : 0;
    }
    function isMethodLike(symbol) {
        return !!(symbol.flags & 8192 /* Method */ || ts.getCheckFlags(symbol) & 4 /* SyntheticMethod */);
    }
    /**
     * Check whether the requested property access is valid.
     * Returns true if node is a valid property access, and false otherwise.
     * @param node The node to be checked.
     * @param left The left hand side of the property access (e.g.: the super in `super.foo`).
     * @param type The type of left.
     * @param prop The symbol for the right hand side of the property access.
     */
    function checkPropertyAccessibility(node, left, type, prop) {
        let flags = ts.getDeclarationModifierFlagsFromSymbol(prop);
        let errorNode = node.kind === 179 /* PropertyAccessExpression */ || node.kind === SyntaxKind.VariableDeclaration ?
            node.name :
            node.right;
        if (ts.getCheckFlags(prop) & 256 /* ContainsPrivate */) {
            // Synthetic property with private constituent property
            error(errorNode, ts.Diagnostics.Property_0_has_conflicting_declarations_and_is_inaccessible_in_type_1, symbolToString(prop), typeToString(type));
            return false;
        }
        if (left.kind === 97 /* SuperKeyword */) {
            // TS 1.0 spec (April 2014): 4.8.2
            // - In a constructor, instance member function, instance member accessor, or
            //   instance member variable initializer where this references a derived class instance,
            //   a super property access is permitted and must specify a public instance member function of the base class.
            // - In a static member function or static member accessor
            //   where this references the constructor function object of a derived class,
            //   a super property access is permitted and must specify a public static member function of the base class.
            if (languageVersion < 2 /* ES2015 */) {
                let hasNonMethodDeclaration = forEachProperty(prop, function (p) {
                    let propKind = getDeclarationKindFromSymbol(p);
                    return propKind !== SyntaxKind.MethodDeclaration && propKind !== 150 /* MethodSignature */;
                });
                if (hasNonMethodDeclaration) {
                    error(errorNode, ts.Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword);
                    return false;
                }
            }
            if (flags & 128 /* Abstract */) {
                // A method cannot be accessed in a super property access if the method is abstract.
                // This error could mask a private property access error. But, a member
                // cannot simultaneously be private and abstract, so this will trigger an
                // additional error elsewhere.
                error(errorNode, ts.Diagnostics.Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression, symbolToString(prop), typeToString(getDeclaringClass(prop)));
                return false;
            }
        }
        // Public properties are otherwise accessible.
        if (!(flags & 24 /* NonPublicAccessibilityModifier */)) {
            return true;
        }
        // Property is known to be private or protected at this point
        // Private property is accessible if the property is within the declaring class
        if (flags & 8 /* Private */) {
            let declaringClassDeclaration = getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop));
            if (!isNodeWithinClass(node, declaringClassDeclaration)) {
                error(errorNode, ts.Diagnostics.Property_0_is_private_and_only_accessible_within_class_1, symbolToString(prop), typeToString(getDeclaringClass(prop)));
                return false;
            }
            return true;
        }
        // Property is known to be protected at this point
        // All protected properties of a supertype are accessible in a super access
        if (left.kind === 97 /* SuperKeyword */) {
            return true;
        }
        // Find the first enclosing class that has the declaring classes of the protected constituents
        // of the property as base classes
        let enclosingClass = forEachEnclosingClass(node, function (enclosingDeclaration) {
            let enclosingClass = getDeclaredTypeOfSymbol(getSymbolOfNode(enclosingDeclaration));
            return isClassDerivedFromDeclaringClasses(enclosingClass, prop) ? enclosingClass : undefined;
        });
        // A protected property is accessible if the property is within the declaring class or classes derived from it
        if (!enclosingClass) {
            error(errorNode, ts.Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, symbolToString(prop), typeToString(getDeclaringClass(prop) || type));
            return false;
        }
        // No further restrictions for static properties
        if (flags & ModifierFlags.Static) {
            return true;
        }
        // An instance property must be accessed through an instance of the enclosing class
        if (type.flags & 16384 /* TypeParameter */ && type.isThisType) {
            // get the original type -- represented as the type constraint of the 'this' type
            type = getConstraintOfTypeParameter(type);
        }
        if (!(getObjectFlags(getTargetType(type)) & 3 /* ClassOrInterface */ && hasBaseType(type, enclosingClass))) {
            error(errorNode, ts.Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1, symbolToString(prop), typeToString(enclosingClass));
            return false;
        }
        return true;
    }
    function checkNonNullExpression(node) {
        return checkNonNullType(checkExpression(node), node);
    }
    function checkNonNullType(type, errorNode) {
        let kind = (strictNullChecks ? getFalsyFlags(type) : type.flags) & 6144 /* Nullable */;
        if (kind) {
            error(errorNode, kind & 2048 /* Undefined */ ? kind & 4096 /* Null */ ?
                ts.Diagnostics.Object_is_possibly_null_or_undefined :
                ts.Diagnostics.Object_is_possibly_undefined :
                ts.Diagnostics.Object_is_possibly_null);
            let t = getNonNullableType(type);
            return t.flags & (6144 /* Nullable */ | 8192 /* Never */) ? unknownType : t;
        }
        return type;
    }
    function checkPropertyAccessExpression(node) {
        return checkPropertyAccessExpressionOrQualifiedName(node, node.expression, node.name);
    }
    function checkQualifiedName(node) {
        return checkPropertyAccessExpressionOrQualifiedName(node, node.left, node.right);
    }
    function checkPropertyAccessExpressionOrQualifiedName(node, left, right) {
        let type = checkNonNullExpression(left);
        if (isTypeAny(type) || type === silentNeverType) {
            return type;
        }
        let apparentType = getApparentType(getWidenedType(type));
        if (apparentType === unknownType || (type.flags & 16384 /* TypeParameter */ && isTypeAny(apparentType))) {
            // handle cases when type is Type parameter with invalid or any constraint
            return apparentType;
        }
        let prop = getPropertyOfType(apparentType, right.escapedText);
        if (!prop) {
            let indexInfo = getIndexInfoOfType(apparentType, 0 /* String */);
            if (indexInfo && indexInfo.type) {
                if (indexInfo.isReadonly && (ts.isAssignmentTarget(node) || ts.isDeleteTarget(node))) {
                    error(node, ts.Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(apparentType));
                }
                return indexInfo.type;
            }
            if (right.escapedText && !checkAndReportErrorForExtendingInterface(node)) {
                reportNonexistentProperty(right, type.flags & 16384 /* TypeParameter */ && type.isThisType ? apparentType : type);
            }
            return unknownType;
        }
        checkPropertyNotUsedBeforeDeclaration(prop, node, right);
        markPropertyAsReferenced(prop, node, left.kind === 99 /* ThisKeyword */);
        getNodeLinks(node).resolvedSymbol = prop;
        checkPropertyAccessibility(node, left, apparentType, prop);
        let propType = getDeclaredOrApparentType(prop, node);
        let assignmentKind = ts.getAssignmentTargetKind(node);
        if (assignmentKind) {
            if (isReferenceToReadonlyEntity(node, prop) || isReferenceThroughNamespaceImport(node)) {
                error(right, ts.Diagnostics.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, ts.idText(right));
                return unknownType;
            }
        }
        // Only compute control flow type if this is a property access expression that isn't an
        // assignment target, and the referenced property was declared as a variable, property,
        // accessor, or optional method.
        if (node.kind !== 179 /* PropertyAccessExpression */ || assignmentKind === 1 /* Definite */ ||
            !(prop.flags & (3 /* Variable */ | SymbolFlags.Property | 98304 /* Accessor */)) &&
            !(prop.flags & 8192 /* Method */ && propType.flags & 65536 /* Union */)) {
            return propType;
        }
        let flowType = getFlowTypeOfReference(node, propType);
        return assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType;
    }
    function checkPropertyNotUsedBeforeDeclaration(prop, node, right) {
        let valueDeclaration = prop.valueDeclaration;
        if (!valueDeclaration) {
            return;
        }
        if (isInPropertyInitializer(node) &&
            !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right)
            && !isPropertyDeclaredInAncestorClass(prop)) {
            error(right, ts.Diagnostics.Block_scoped_variable_0_used_before_its_declaration, ts.idText(right));
        }
        else if (valueDeclaration.kind === SyntaxKind.ClassDeclaration &&
            node.parent.kind !== 159 /* TypeReference */ &&
            !ts.isInAmbientContext(valueDeclaration) &&
            !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right)) {
            error(right, ts.Diagnostics.Class_0_used_before_its_declaration, ts.idText(right));
        }
    }
    function isInPropertyInitializer(node) {
        return !!ts.findAncestor(node, function (node) {
            switch (node.kind) {
                case SyntaxKind.PropertyDeclaration:
                    return true;
                case 264 /* PropertyAssignment */:
                    // We might be in `a = { b: this.b }`, so keep looking. See `tests/cases/compiler/useBeforeDeclaration_propertyAssignment.ts`.
                    return false;
                default:
                    return ts.isPartOfExpression(node) ? false : "quit";
            }
        });
    }
    /**
     * It's possible that "prop.valueDeclaration" is a local declaration, but the property was also declared in a superclass.
     * In that case we won't consider it used before its declaration, because it gets its value from the superclass' declaration.
     */
    function isPropertyDeclaredInAncestorClass(prop) {
        let classType = getTypeOfSymbol(prop.parent);
        while (true) {
            classType = getSuperClass(classType);
            if (!classType) {
                return false;
            }
            let superProperty = getPropertyOfObjectType(classType, prop.escapedName);
            if (superProperty && superProperty.valueDeclaration) {
                return true;
            }
        }
    }
    function getSuperClass(classType) {
        let x = getBaseTypes(classType);
        if (x.length === 0) {
            return undefined;
        }
        ts.Debug.assert(x.length === 1);
        return x[0];
    }
    function reportNonexistentProperty(propNode, containingType) {
        let errorInfo;
        if (containingType.flags & 65536 /* Union */ && !(containingType.flags & 8190 /* Primitive */)) {
            for (let _i = 0, _a = containingType.types; _i < _a.length; _i++) {
                let subtype = _a[_i];
                if (!getPropertyOfType(subtype, propNode.escapedText)) {
                    errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.declarationNameToString(propNode), typeToString(subtype));
                    break;
                }
            }
        }
        let suggestion = getSuggestionForNonexistentProperty(propNode, containingType);
        if (suggestion !== undefined) {
            errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, ts.declarationNameToString(propNode), typeToString(containingType), suggestion);
        }
        else {
            errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.declarationNameToString(propNode), typeToString(containingType));
        }
        diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(propNode, errorInfo));
    }
    function getSuggestionForNonexistentProperty(node, containingType) {
        let suggestion = getSpellingSuggestionForName(ts.idText(node), getPropertiesOfType(containingType), SymbolFlags.Value);
        return suggestion && ts.symbolName(suggestion);
    }
    function getSuggestionForNonexistentSymbol(location, name, meaning) {
        let result = resolveNameHelper(location, name, meaning, /*nameNotFoundMessage*/ undefined, name, /*isUse*/ false, function (symbols, name, meaning) {
            // `name` from the callback === the outer `name`
            let symbol = getSymbol(symbols, name, meaning);
            // Sometimes the symbol is found when location is a return type of a function: `typeof x` and `x` is declared in the body of the function
            // So the table *contains* `x` but `x` isn't actually in scope.
            // However, resolveNameHelper will continue and call this callback again, so we'll eventually get a correct suggestion.
            return symbol || getSpellingSuggestionForName(ts.unescapeLeadingUnderscores(name), ts.arrayFrom(symbols.values()), meaning);
        });
        return result && ts.symbolName(result);
    }
    /**
     * Given a name and a list of symbols whose names are *not* equal to the name, return a spelling suggestion if there is one that is close enough.
     * Names less than length 3 only check for case-insensitive equality, not levenshtein distance.
     *
     * If there is a candidate that's the same except for case, return that.
     * If there is a candidate that's within one edit of the name, return that.
     * Otherwise, return the candidate with the smallest Levenshtein distance,
     *    except for candidates:
     *      * With no name
     *      * Whose meaning doesn't match the `meaning` parameter.
     *      * Whose length differs from the target name by more than 0.3 of the length of the name.
     *      * Whose levenshtein distance is more than 0.4 of the length of the name
     *        (0.4 allows 1 substitution/transposition for every 5 characters,
     *         and 1 insertion/deletion at 3 characters)
     * Names longer than 30 characters don't get suggestions because Levenshtein distance is an n**2 algorithm.
     */
    function getSpellingSuggestionForName(name, symbols, meaning) {
        let worstDistance = name.length * 0.4;
        let maximumLengthDifference = Math.min(3, name.length * 0.34);
        let bestDistance = Number.MAX_VALUE;
        let bestCandidate = undefined;
        let justCheckExactMatches = false;
        if (name.length > 30) {
            return undefined;
        }
        name = name.toLowerCase();
        for (let _i = 0, symbols_3 = symbols; _i < symbols_3.length; _i++) {
            let candidate = symbols_3[_i];
            let candidateName = ts.symbolName(candidate);
            if (candidate.flags & meaning &&
                candidateName &&
                Math.abs(candidateName.length - name.length) < maximumLengthDifference) {
                candidateName = candidateName.toLowerCase();
                if (candidateName === name) {
                    return candidate;
                }
                if (justCheckExactMatches) {
                    continue;
                }
                if (candidateName.length < 3 ||
                    name.length < 3 ||
                    candidateName === "eval" ||
                    candidateName === "intl" ||
                    candidateName === "undefined" ||
                    candidateName === "map" ||
                    candidateName === "nan" ||
                    candidateName === "set") {
                    continue;
                }
                let distance = ts.levenshtein(name, candidateName);
                if (distance > worstDistance) {
                    continue;
                }
                if (distance < 3) {
                    justCheckExactMatches = true;
                    bestCandidate = candidate;
                }
                else if (distance < bestDistance) {
                    bestDistance = distance;
                    bestCandidate = candidate;
                }
            }
        }
        return bestCandidate;
    }
    function markPropertyAsReferenced(prop, nodeForCheckWriteOnly, isThisAccess) {
        if (prop &&
            noUnusedIdentifiers &&
            (prop.flags & 106500 /* ClassMember */) &&
            prop.valueDeclaration && ts.hasModifier(prop.valueDeclaration, 8 /* Private */)
            && !(nodeForCheckWriteOnly && ts.isWriteOnlyAccess(nodeForCheckWriteOnly))) {
            if (isThisAccess) {
                // Find any FunctionLikeDeclaration because those create a new 'this' binding. But this should only matter for methods (or getters/setters).
                let containingMethod = ts.findAncestor(nodeForCheckWriteOnly, ts.isFunctionLikeDeclaration);
                if (containingMethod && containingMethod.symbol === prop) {
                    return;
                }
            }
            if (ts.getCheckFlags(prop) & CheckFlags.Instantiated) {
                getSymbolLinks(prop).target.isReferenced = true;
            }
            else {
                prop.isReferenced = true;
            }
        }
    }
    function isValidPropertyAccess(node, propertyName) {
        let left = node.kind === 179 /* PropertyAccessExpression */
            ? node.expression
            : node.left;
        return isValidPropertyAccessWithType(node, left, propertyName, getWidenedType(checkExpression(left)));
    }
    function isValidPropertyAccessWithType(node, left, propertyName, type) {
        if (type !== unknownType && !isTypeAny(type)) {
            let prop = getPropertyOfType(type, propertyName);
            if (prop) {
                return checkPropertyAccessibility(node, left, type, prop);
            }
            // In js files properties of unions are allowed in completion
            if (ts.isInJavaScriptFile(left) && (type.flags & 65536 /* Union */)) {
                for (let _i = 0, _a = type.types; _i < _a.length; _i++) {
                    let elementType = _a[_i];
                    if (isValidPropertyAccessWithType(node, left, propertyName, elementType)) {
                        return true;
                    }
                }
            }
            return false;
        }
        return true;
    }
    /**
     * Return the symbol of the for-in variable declared or referenced by the given for-in statement.
     */
    function getForInVariableSymbol(node) {
        let initializer = node.initializer;
        if (initializer.kind === 227 /* VariableDeclarationList */) {
            let variable = initializer.declarations[0];
            if (variable && !ts.isBindingPattern(variable.name)) {
                return getSymbolOfNode(variable);
            }
        }
        else if (initializer.kind === 71 /* Identifier */) {
            return getResolvedSymbol(initializer);
        }
        return undefined;
    }
    /**
     * Return true if the given type is considered to have numeric property names.
     */
    function hasNumericPropertyNames(type) {
        return getIndexTypeOfType(type, 1 /* Number */) && !getIndexTypeOfType(type, 0 /* String */);
    }
    /**
     * Return true if given node is an expression consisting of an identifier (possibly parenthesized)
     * that references a for-in variable for an object with numeric property names.
     */
    function isForInVariableForNumericPropertyNames(expr) {
        let e = ts.skipParentheses(expr);
        if (e.kind === 71 /* Identifier */) {
            let symbol = getResolvedSymbol(e);
            if (symbol.flags & 3 /* Variable */) {
                let child = expr;
                let node = expr.parent;
                while (node) {
                    if (node.kind === 215 /* ForInStatement */ &&
                        child === node.statement &&
                        getForInVariableSymbol(node) === symbol &&
                        hasNumericPropertyNames(getTypeOfExpression(node.expression))) {
                        return true;
                    }
                    child = node;
                    node = node.parent;
                }
            }
        }
        return false;
    }
    function checkIndexedAccess(node) {
        let objectType = checkNonNullExpression(node.expression);
        let indexExpression = node.argumentExpression;
        if (!indexExpression) {
            let sourceFile = ts.getSourceFileOfNode(node);
            if (node.parent.kind === 182 /* NewExpression */ && node.parent.expression === node) {
                let start = ts.skipTrivia(sourceFile.text, node.expression.end);
                let end = node.end;
                grammarErrorAtPos(sourceFile, start, end - start, ts.Diagnostics.new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead);
            }
            else {
                let start = node.end - "]".length;
                let end = node.end;
                grammarErrorAtPos(sourceFile, start, end - start, ts.Diagnostics.Expression_expected);
            }
            return unknownType;
        }
        let indexType = isForInVariableForNumericPropertyNames(indexExpression) ? numberType : checkExpression(indexExpression);
        if (objectType === unknownType || objectType === silentNeverType) {
            return objectType;
        }
        if (isConstEnumObjectType(objectType) && indexExpression.kind !== 9 /* StringLiteral */) {
            error(indexExpression, ts.Diagnostics.A_const_enum_member_can_only_be_accessed_using_a_string_literal);
            return unknownType;
        }
        return checkIndexedAccessIndexType(getIndexedAccessType(objectType, indexType, node), node);
    }
    function checkThatExpressionIsProperSymbolReference(expression, expressionType, reportError) {
        if (expressionType === unknownType) {
            // There is already an error, so no need to report one.
            return false;
        }
        if (!ts.isWellKnownSymbolSyntactically(expression)) {
            return false;
        }
        // Make sure the property type is the primitive symbol type
        if ((expressionType.flags & 512 /* ESSymbol */) === 0) {
            if (reportError) {
                error(expression, ts.Diagnostics.A_computed_property_name_of_the_form_0_must_be_of_type_symbol, ts.getTextOfNode(expression));
            }
            return false;
        }
        // The name is Symbol.<someName>, so make sure Symbol actually resolves to the
        // global Symbol object
        let leftHandSide = expression.expression;
        let leftHandSideSymbol = getResolvedSymbol(leftHandSide);
        if (!leftHandSideSymbol) {
            return false;
        }
        let globalESSymbol = getGlobalESSymbolConstructorSymbol(/*reportErrors*/ true);
        if (!globalESSymbol) {
            // Already errored when we tried to look up the symbol
            return false;
        }
        if (leftHandSideSymbol !== globalESSymbol) {
            if (reportError) {
                error(leftHandSide, ts.Diagnostics.Symbol_reference_does_not_refer_to_the_global_Symbol_constructor_object);
            }
            return false;
        }
        return true;
    }
    function callLikeExpressionMayHaveTypeArguments(node) {
        // TODO: Also include tagged templates (https://github.com/Microsoft/TypeScript/issues/11947)
        return ts.isCallOrNewExpression(node);
    }
    function resolveUntypedCall(node) {
        if (callLikeExpressionMayHaveTypeArguments(node)) {
            // Check type arguments even though we will give an error that untyped calls may not accept type arguments.
            // This gets us diagnostics for the type arguments and marks them as referenced.
            ts.forEach(node.typeArguments, checkSourceElement);
        }
        if (node.kind === 183 /* TaggedTemplateExpression */) {
            checkExpression(node.template);
        }
        else if (node.kind !== 147 /* Decorator */) {
            ts.forEach(node.arguments, function (argument) {
                checkExpression(argument);
            });
        }
        return anySignature;
    }
    function resolveErrorCall(node) {
        resolveUntypedCall(node);
        return unknownSignature;
    }
    // Re-order candidate signatures into the result array. Assumes the result array to be empty.
    // The candidate list orders groups in reverse, but within a group signatures are kept in declaration order
    // A nit here is that we reorder only signatures that belong to the same symbol,
    // so order how inherited signatures are processed is still preserved.
    // interface A { (x: string): void }
    // interface B extends A { (x: 'foo'): string }
    // const b: B;
    // b('foo') // <- here overloads should be processed as [(x:'foo'): string, (x: string): void]
    function reorderCandidates(signatures, result) {
        let lastParent;
        let lastSymbol;
        let cutoffIndex = 0;
        let index;
        let specializedIndex = -1;
        let spliceIndex;
        ts.Debug.assert(!result.length);
        for (let _i = 0, signatures_4 = signatures; _i < signatures_4.length; _i++) {
            let signature = signatures_4[_i];
            let symbol = signature.declaration && getSymbolOfNode(signature.declaration);
            let parent = signature.declaration && signature.declaration.parent;
            if (!lastSymbol || symbol === lastSymbol) {
                if (lastParent && parent === lastParent) {
                    index++;
                }
                else {
                    lastParent = parent;
                    index = cutoffIndex;
                }
            }
            else {
                // current declaration belongs to a different symbol
                // set cutoffIndex so re-orderings in the future won't change result set from 0 to cutoffIndex
                index = cutoffIndex = result.length;
                lastParent = parent;
            }
            lastSymbol = symbol;
            // specialized signatures always need to be placed before non-specialized signatures regardless
            // of the cutoff position; see GH#1133
            if (signature.hasLiteralTypes) {
                specializedIndex++;
                spliceIndex = specializedIndex;
                // The cutoff index always needs to be greater than or equal to the specialized signature index
                // in order to prevent non-specialized signatures from being added before a specialized
                // signature.
                cutoffIndex++;
            }
            else {
                spliceIndex = index;
            }
            result.splice(spliceIndex, 0, signature);
        }
    }
    function getSpreadArgumentIndex(args) {
        for (let i = 0; i < args.length; i++) {
            let arg = args[i];
            if (arg && arg.kind === 198 /* SpreadElement */) {
                return i;
            }
        }
        return -1;
    }
    function hasCorrectArity(node, args, signature, signatureHelpTrailingComma) {
        if (signatureHelpTrailingComma === void 0) { signatureHelpTrailingComma = false; }
        let argCount; // Apparent number of arguments we will have in this call
        let typeArguments; // Type arguments (undefined if none)
        let callIsIncomplete; // In incomplete call we want to be lenient when we have too few arguments
        let spreadArgIndex = -1;
        if (ts.isJsxOpeningLikeElement(node)) {
            // The arity check will be done in "checkApplicableSignatureForJsxOpeningLikeElement".
            return true;
        }
        if (node.kind === 183 /* TaggedTemplateExpression */) {
            let tagExpression = node;
            // Even if the call is incomplete, we'll have a missing expression as our last argument,
            // so we can say the count is just the arg list length
            argCount = args.length;
            typeArguments = undefined;
            if (tagExpression.template.kind === 196 /* TemplateExpression */) {
                // If a tagged template expression lacks a tail literal, the call is incomplete.
                // Specifically, a template only can end in a TemplateTail or a Missing literal.
                let templateExpression = tagExpression.template;
                let lastSpan = ts.lastOrUndefined(templateExpression.templateSpans);
                ts.Debug.assert(lastSpan !== undefined); // we should always have at least one span.
                callIsIncomplete = ts.nodeIsMissing(lastSpan.literal) || !!lastSpan.literal.isUnterminated;
            }
            else {
                // If the template didn't end in a backtick, or its beginning occurred right prior to EOF,
                // then this might actually turn out to be a TemplateHead in the future;
                // so we consider the call to be incomplete.
                let templateLiteral = tagExpression.template;
                ts.Debug.assert(templateLiteral.kind === 13 /* NoSubstitutionTemplateLiteral */);
                callIsIncomplete = !!templateLiteral.isUnterminated;
            }
        }
        else if (node.kind === 147 /* Decorator */) {
            typeArguments = undefined;
            argCount = getEffectiveArgumentCount(node, /*args*/ undefined, signature);
        }
        else {
            let callExpression = node;
            if (!callExpression.arguments) {
                // This only happens when we have something of the form: 'new C'
                ts.Debug.assert(callExpression.kind === 182 /* NewExpression */);
                return signature.minArgumentCount === 0;
            }
            argCount = signatureHelpTrailingComma ? args.length + 1 : args.length;
            // If we are missing the close parenthesis, the call is incomplete.
            callIsIncomplete = callExpression.arguments.end === callExpression.end;
            typeArguments = callExpression.typeArguments;
            spreadArgIndex = getSpreadArgumentIndex(args);
        }
        // If the user supplied type arguments, but the number of type arguments does not match
        // the declared number of type parameters, the call has an incorrect arity.
        let numTypeParameters = ts.length(signature.typeParameters);
        let minTypeArgumentCount = getMinTypeArgumentCount(signature.typeParameters);
        let hasRightNumberOfTypeArgs = !typeArguments ||
            (typeArguments.length >= minTypeArgumentCount && typeArguments.length <= numTypeParameters);
        if (!hasRightNumberOfTypeArgs) {
            return false;
        }
        // If spread arguments are present, check that they correspond to a rest parameter. If so, no
        // further checking is necessary.
        if (spreadArgIndex >= 0) {
            return isRestParameterIndex(signature, spreadArgIndex) || spreadArgIndex >= signature.minArgumentCount;
        }
        // Too many arguments implies incorrect arity.
        if (!signature.hasRestParameter && argCount > signature.parameters.length) {
            return false;
        }
        // If the call is incomplete, we should skip the lower bound check.
        let hasEnoughArguments = argCount >= signature.minArgumentCount;
        return callIsIncomplete || hasEnoughArguments;
    }
    // If type has a single call signature and no other members, return that signature. Otherwise, return undefined.
    function getSingleCallSignature(type) {
        if (type.flags & TypeFlags.Object) {
            let resolved = resolveStructuredTypeMembers(type);
            if (resolved.callSignatures.length === 1 && resolved.constructSignatures.length === 0 &&
                resolved.properties.length === 0 && !resolved.stringIndexInfo && !resolved.numberIndexInfo) {
                return resolved.callSignatures[0];
            }
        }
        return undefined;
    }
    // Instantiate a generic signature in the context of a non-generic signature (section 3.8.5 in TypeScript spec)
    function instantiateSignatureInContextOf(signature, contextualSignature, contextualMapper, compareTypes) {
        let context = createInferenceContext(signature, 1 /* InferUnionTypes */, compareTypes);
        forEachMatchingParameterType(contextualSignature, signature, function (source, target) {
            // Type parameters from outer context referenced by source type are fixed by instantiation of the source type
            inferTypes(context.inferences, instantiateType(source, contextualMapper || identityMapper), target);
        });
        if (!contextualMapper) {
            inferTypes(context.inferences, getReturnTypeOfSignature(contextualSignature), getReturnTypeOfSignature(signature), 8 /* ReturnType */);
        }
        return getSignatureInstantiation(signature, getInferredTypes(context), ts.isInJavaScriptFile(contextualSignature.declaration));
    }
    function inferTypeArguments(node, signature, args, excludeArgument, context) {
        // Clear out all the inference results from the last time inferTypeArguments was called on this context
        for (let _i = 0, _a = context.inferences; _i < _a.length; _i++) {
            let inference = _a[_i];
            // As an optimization, we don't have to clear (and later recompute) inferred types
            // for type parameters that have already been fixed on the previous call to inferTypeArguments.
            // It would be just as correct to reset all of them. But then we'd be repeating the same work
            // for the type parameters that were fixed, namely the work done by getInferredType.
            if (!inference.isFixed) {
                inference.inferredType = undefined;
            }
        }
        // If a contextual type is available, infer from that type to the return type of the call expression. For
        // example, given a 'function wrap<T, U>(cb: (x: T) => U): (x: T) => U' and a call expression
        // 'let f: (x: string) => number = wrap(s => s.length)', we infer from the declared type of 'f' to the
        // return type of 'wrap'.
        if (node.kind !== 147 /* Decorator */) {
            let contextualType = getContextualType(node);
            if (contextualType) {
                // We clone the contextual mapper to avoid disturbing a resolution in progress for an
                // outer call expression. Effectively we just want a snapshot of whatever has been
                // inferred for any outer call expression so far.
                let instantiatedType = instantiateType(contextualType, cloneTypeMapper(getContextualMapper(node)));
                // If the contextual type is a generic function type with a single call signature, we
                // instantiate the type with its own type parameters and type arguments. This ensures that
                // the type parameters are not erased to type any during type inference such that they can
                // be inferred as actual types from the contextual type. For example:
                //   declare function arrayMap<T, U>(f: (x: T) => U): (a: T[]) => U[];
                //   const boxElements: <A>(a: A[]) => { value: A }[] = arrayMap(value => ({ value }));
                // Above, the type of the 'value' parameter is inferred to be 'A'.
                let contextualSignature = getSingleCallSignature(instantiatedType);
                let inferenceSourceType = contextualSignature && contextualSignature.typeParameters ?
                    getOrCreateTypeFromSignature(getSignatureInstantiation(contextualSignature, contextualSignature.typeParameters, ts.isInJavaScriptFile(node))) :
                    instantiatedType;
                let inferenceTargetType = getReturnTypeOfSignature(signature);
                // Inferences made from return types have lower priority than all other inferences.
                inferTypes(context.inferences, inferenceSourceType, inferenceTargetType, 8 /* ReturnType */);
            }
        }
        let thisType = getThisTypeOfSignature(signature);
        if (thisType) {
            let thisArgumentNode = getThisArgumentOfCall(node);
            let thisArgumentType = thisArgumentNode ? checkExpression(thisArgumentNode) : voidType;
            inferTypes(context.inferences, thisArgumentType, thisType);
        }
        // We perform two passes over the arguments. In the first pass we infer from all arguments, but use
        // wildcards for all context sensitive function expressions.
        let argCount = getEffectiveArgumentCount(node, args, signature);
        for (let i = 0; i < argCount; i++) {
            let arg = getEffectiveArgument(node, args, i);
            // If the effective argument is 'undefined', then it is an argument that is present but is synthetic.
            if (arg === undefined || arg.kind !== 200 /* OmittedExpression */) {
                let paramType = getTypeAtPosition(signature, i);
                let argType = getEffectiveArgumentType(node, i);
                // If the effective argument type is 'undefined', there is no synthetic type
                // for the argument. In that case, we should check the argument.
                if (argType === undefined) {
                    // For context sensitive arguments we pass the identityMapper, which is a signal to treat all
                    // context sensitive function expressions as wildcards
                    let mapper = excludeArgument && excludeArgument[i] !== undefined ? identityMapper : context;
                    argType = checkExpressionWithContextualType(arg, paramType, mapper);
                }
                inferTypes(context.inferences, argType, paramType);
            }
        }
        // In the second pass we visit only context sensitive arguments, and only those that aren't excluded, this
        // time treating function expressions normally (which may cause previously inferred type arguments to be fixed
        // as we construct types for contextually typed parameters)
        // Decorators will not have `excludeArgument`, as their arguments cannot be contextually typed.
        // Tagged template expressions will always have `undefined` for `excludeArgument[0]`.
        if (excludeArgument) {
            for (let i = 0; i < argCount; i++) {
                // No need to check for omitted args and template expressions, their exclusion value is always undefined
                if (excludeArgument[i] === false) {
                    let arg = args[i];
                    let paramType = getTypeAtPosition(signature, i);
                    inferTypes(context.inferences, checkExpressionWithContextualType(arg, paramType, context), paramType);
                }
            }
        }
        return getInferredTypes(context);
    }
    function checkTypeArguments(signature, typeArgumentNodes, reportErrors, headMessage) {
        let isJavascript = ts.isInJavaScriptFile(signature.declaration);
        let typeParameters = signature.typeParameters;
        let typeArgumentTypes = fillMissingTypeArguments(ts.map(typeArgumentNodes, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isJavascript);
        let mapper;
        for (let i = 0; i < typeArgumentNodes.length; i++) {
            ts.Debug.assert(typeParameters[i] !== undefined, "Should not call checkTypeArguments with too many type arguments");
            let constraint = getConstraintOfTypeParameter(typeParameters[i]);
            if (!constraint)
                continue;
            let errorInfo = reportErrors && headMessage && ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
            let typeArgumentHeadMessage = headMessage || ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1;
            if (!mapper) {
                mapper = createTypeMapper(typeParameters, typeArgumentTypes);
            }
            let typeArgument = typeArgumentTypes[i];
            if (!checkTypeAssignableTo(typeArgument, getTypeWithThisArgument(instantiateType(constraint, mapper), typeArgument), reportErrors ? typeArgumentNodes[i] : undefined, typeArgumentHeadMessage, errorInfo)) {
                return false;
            }
        }
        return typeArgumentTypes;
    }
    /**
     * Check if the given signature can possibly be a signature called by the JSX opening-like element.
     * @param node a JSX opening-like element we are trying to figure its call signature
     * @param signature a candidate signature we are trying whether it is a call signature
     * @param relation a relationship to check parameter and argument type
     * @param excludeArgument
     */
    function checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation) {
        // JSX opening-like element has correct arity for stateless-function component if the one of the following condition is true:
        //      1. callIsIncomplete
        //      2. attributes property has same number of properties as the parameter object type.
        //         We can figure that out by resolving attributes property and check number of properties in the resolved type
        // If the call has correct arity, we will then check if the argument type and parameter type is assignable
        let callIsIncomplete = node.attributes.end === node.end; // If we are missing the close "/>", the call is incomplete
        if (callIsIncomplete) {
            return true;
        }
        let headMessage = ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1;
        // Stateless function components can have maximum of three arguments: "props", "context", and "updater".
        // However "context" and "updater" are implicit and can't be specify by users. Only the first parameter, props,
        // can be specified by users through attributes property.
        let paramType = getTypeAtPosition(signature, 0);
        let attributesType = checkExpressionWithContextualType(node.attributes, paramType, /*contextualMapper*/ undefined);
        let argProperties = getPropertiesOfType(attributesType);
        for (let _i = 0, argProperties_1 = argProperties; _i < argProperties_1.length; _i++) {
            let arg = argProperties_1[_i];
            if (!getPropertyOfType(paramType, arg.escapedName) && isUnhyphenatedJsxName(arg.escapedName)) {
                return false;
            }
        }
        return checkTypeRelatedTo(attributesType, paramType, relation, /*errorNode*/ undefined, headMessage);
    }
    function checkApplicableSignature(node, args, signature, relation, excludeArgument, reportErrors) {
        if (ts.isJsxOpeningLikeElement(node)) {
            return checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation);
        }
        let thisType = getThisTypeOfSignature(signature);
        if (thisType && thisType !== voidType && node.kind !== 182 /* NewExpression */) {
            // If the called expression is not of the form `x.f` or `x["f"]`, then sourceType = voidType
            // If the signature's 'this' type is voidType, then the check is skipped -- anything is compatible.
            // If the expression is a new expression, then the check is skipped.
            let thisArgumentNode = getThisArgumentOfCall(node);
            let thisArgumentType = thisArgumentNode ? checkExpression(thisArgumentNode) : voidType;
            let errorNode = reportErrors ? (thisArgumentNode || node) : undefined;
            let headMessage_1 = ts.Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1;
            if (!checkTypeRelatedTo(thisArgumentType, getThisTypeOfSignature(signature), relation, errorNode, headMessage_1)) {
                return false;
            }
        }
        let headMessage = ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1;
        let argCount = getEffectiveArgumentCount(node, args, signature);
        for (let i = 0; i < argCount; i++) {
            let arg = getEffectiveArgument(node, args, i);
            // If the effective argument is 'undefined', then it is an argument that is present but is synthetic.
            if (arg === undefined || arg.kind !== 200 /* OmittedExpression */) {
                // Check spread elements against rest type (from arity check we know spread argument corresponds to a rest parameter)
                let paramType = getTypeAtPosition(signature, i);
                // If the effective argument type is undefined, there is no synthetic type for the argument.
                // In that case, we should check the argument.
                let argType = getEffectiveArgumentType(node, i) ||
                    checkExpressionWithContextualType(arg, paramType, excludeArgument && excludeArgument[i] ? identityMapper : undefined);
                // If one or more arguments are still excluded (as indicated by a non-null excludeArgument parameter),
                // we obtain the regular type of any object literal arguments because we may not have inferred complete
                // parameter types yet and therefore excess property checks may yield false positives (see #17041).
                let checkArgType = excludeArgument ? getRegularTypeOfObjectLiteral(argType) : argType;
                // Use argument expression as error location when reporting errors
                let errorNode = reportErrors ? getEffectiveArgumentErrorNode(node, i, arg) : undefined;
                if (!checkTypeRelatedTo(checkArgType, paramType, relation, errorNode, headMessage)) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * Returns the this argument in calls like x.f(...) and x[f](...). Undefined otherwise.
     */
    function getThisArgumentOfCall(node) {
        if (node.kind === 181 /* CallExpression */) {
            let callee = node.expression;
            if (callee.kind === 179 /* PropertyAccessExpression */) {
                return callee.expression;
            }
            else if (callee.kind === 180 /* ElementAccessExpression */) {
                return callee.expression;
            }
        }
    }
    /**
     * Returns the effective arguments for an expression that works like a function invocation.
     *
     * If 'node' is a CallExpression or a NewExpression, then its argument list is returned.
     * If 'node' is a TaggedTemplateExpression, a new argument list is constructed from the substitution
     *    expressions, where the first element of the list is `undefined`.
     * If 'node' is a Decorator, the argument list will be `undefined`, and its arguments and types
     *    will be supplied from calls to `getEffectiveArgumentCount` and `getEffectiveArgumentType`.
     */
    function getEffectiveCallArguments(node) {
        if (node.kind === 183 /* TaggedTemplateExpression */) {
            let template = node.template;
            let args_4 = [undefined];
            if (template.kind === 196 /* TemplateExpression */) {
                ts.forEach(template.templateSpans, function (span) {
                    args_4.push(span.expression);
                });
            }
            return args_4;
        }
        else if (node.kind === 147 /* Decorator */) {
            // For a decorator, we return undefined as we will determine
            // the number and types of arguments for a decorator using
            // `getEffectiveArgumentCount` and `getEffectiveArgumentType` below.
            return undefined;
        }
        else if (ts.isJsxOpeningLikeElement(node)) {
            return node.attributes.properties.length > 0 ? [node.attributes] : ts.emptyArray;
        }
        else {
            return node.arguments || ts.emptyArray;
        }
    }
    /**
     * Returns the effective argument count for a node that works like a function invocation.
     * If 'node' is a Decorator, the number of arguments is derived from the decoration
     *    target and the signature:
     *    If 'node.target' is a class declaration or class expression, the effective argument
     *       count is 1.
     *    If 'node.target' is a parameter declaration, the effective argument count is 3.
     *    If 'node.target' is a property declaration, the effective argument count is 2.
     *    If 'node.target' is a method or accessor declaration, the effective argument count
     *       is 3, although it can be 2 if the signature only accepts two arguments, allowing
     *       us to match a property decorator.
     * Otherwise, the argument count is the length of the 'args' array.
     */
    function getEffectiveArgumentCount(node, args, signature) {
        if (node.kind === 147 /* Decorator */) {
            switch (node.parent.kind) {
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.ClassExpression:
                    // A class decorator will have one argument (see `ClassDecorator` in core.d.ts)
                    return 1;
                case SyntaxKind.PropertyDeclaration:
                    // A property declaration decorator will have two arguments (see
                    // `PropertyDecorator` in core.d.ts)
                    return 2;
                case SyntaxKind.MethodDeclaration:
                case 153 /* GetAccessor */:
                case 154 /* SetAccessor */:
                    // A method or accessor declaration decorator will have two or three arguments (see
                    // `PropertyDecorator` and `MethodDecorator` in core.d.ts)
                    // If we are emitting decorators for ES3, we will only pass two arguments.
                    if (languageVersion === 0 /* ES3 */) {
                        return 2;
                    }
                    // If the method decorator signature only accepts a target and a key, we will only
                    // type check those arguments.
                    return signature.parameters.length >= 3 ? 3 : 2;
                case SyntaxKind.Parameter:
                    // A parameter declaration decorator will have three arguments (see
                    // `ParameterDecorator` in core.d.ts)
                    return 3;
            }
        }
        else {
            return args.length;
        }
    }
    /**
     * Returns the effective type of the first argument to a decorator.
     * If 'node' is a class declaration or class expression, the effective argument type
     *    is the type of the static side of the class.
     * If 'node' is a parameter declaration, the effective argument type is either the type
     *    of the static or instance side of the class for the parameter's parent method,
     *    depending on whether the method is declared static.
     *    For a constructor, the type is always the type of the static side of the class.
     * If 'node' is a property, method, or accessor declaration, the effective argument
     *    type is the type of the static or instance side of the parent class for class
     *    element, depending on whether the element is declared static.
     */
    function getEffectiveDecoratorFirstArgumentType(node) {
        // The first argument to a decorator is its `target`.
        if (node.kind === SyntaxKind.ClassDeclaration) {
            // For a class decorator, the `target` is the type of the class (e.g. the
            // "static" or "constructor" side of the class)
            let classSymbol = getSymbolOfNode(node);
            return getTypeOfSymbol(classSymbol);
        }
        if (node.kind === SyntaxKind.Parameter) {
            // For a parameter decorator, the `target` is the parent type of the
            // parameter's containing method.
            node = node.parent;
            if (node.kind === 152 /* Constructor */) {
                let classSymbol = getSymbolOfNode(node);
                return getTypeOfSymbol(classSymbol);
            }
        }
        if (node.kind === SyntaxKind.PropertyDeclaration ||
            node.kind === SyntaxKind.MethodDeclaration ||
            node.kind === 153 /* GetAccessor */ ||
            node.kind === 154 /* SetAccessor */) {
            // For a property or method decorator, the `target` is the
            // "static"-side type of the parent of the member if the member is
            // declared "static"; otherwise, it is the "instance"-side type of the
            // parent of the member.
            return getParentTypeOfClassElement(node);
        }
        ts.Debug.fail("Unsupported decorator target.");
        return unknownType;
    }
    /**
     * Returns the effective type for the second argument to a decorator.
     * If 'node' is a parameter, its effective argument type is one of the following:
     *    If 'node.parent' is a constructor, the effective argument type is 'any', as we
     *       will emit `undefined`.
     *    If 'node.parent' is a member with an identifier, numeric, or string literal name,
     *       the effective argument type will be a string literal type for the member name.
     *    If 'node.parent' is a computed property name, the effective argument type will
     *       either be a symbol type or the string type.
     * If 'node' is a member with an identifier, numeric, or string literal name, the
     *    effective argument type will be a string literal type for the member name.
     * If 'node' is a computed property name, the effective argument type will either
     *    be a symbol type or the string type.
     * A class decorator does not have a second argument type.
     */
    function getEffectiveDecoratorSecondArgumentType(node) {
        // The second argument to a decorator is its `propertyKey`
        if (node.kind === SyntaxKind.ClassDeclaration) {
            ts.Debug.fail("Class decorators should not have a second synthetic argument.");
            return unknownType;
        }
        if (node.kind === SyntaxKind.Parameter) {
            node = node.parent;
            if (node.kind === 152 /* Constructor */) {
                // For a constructor parameter decorator, the `propertyKey` will be `undefined`.
                return anyType;
            }
            // For a non-constructor parameter decorator, the `propertyKey` will be either
            // a string or a symbol, based on the name of the parameter's containing method.
        }
        if (node.kind === SyntaxKind.PropertyDeclaration ||
            node.kind === SyntaxKind.MethodDeclaration ||
            node.kind === 153 /* GetAccessor */ ||
            node.kind === 154 /* SetAccessor */) {
            // The `propertyKey` for a property or method decorator will be a
            // string literal type if the member name is an identifier, number, or string;
            // otherwise, if the member name is a computed property name it will
            // be either string or symbol.
            let element = node;
            switch (element.name.kind) {
                case 71 /* Identifier */:
                    return getLiteralType(ts.idText(element.name));
                case 8 /* NumericLiteral */:
                case 9 /* StringLiteral */:
                    return getLiteralType(element.name.text);
                case 144 /* ComputedPropertyName */:
                    let nameType = checkComputedPropertyName(element.name);
                    if (isTypeAssignableToKind(nameType, 512 /* ESSymbol */)) {
                        return nameType;
                    }
                    else {
                        return stringType;
                    }
                default:
                    ts.Debug.fail("Unsupported property name.");
                    return unknownType;
            }
        }
        ts.Debug.fail("Unsupported decorator target.");
        return unknownType;
    }
    /**
     * Returns the effective argument type for the third argument to a decorator.
     * If 'node' is a parameter, the effective argument type is the number type.
     * If 'node' is a method or accessor, the effective argument type is a
     *    `TypedPropertyDescriptor<T>` instantiated with the type of the member.
     * Class and property decorators do not have a third effective argument.
     */
    function getEffectiveDecoratorThirdArgumentType(node) {
        // The third argument to a decorator is either its `descriptor` for a method decorator
        // or its `parameterIndex` for a parameter decorator
        if (node.kind === SyntaxKind.ClassDeclaration) {
            ts.Debug.fail("Class decorators should not have a third synthetic argument.");
            return unknownType;
        }
        if (node.kind === SyntaxKind.Parameter) {
            // The `parameterIndex` for a parameter decorator is always a number
            return numberType;
        }
        if (node.kind === SyntaxKind.PropertyDeclaration) {
            ts.Debug.fail("Property decorators should not have a third synthetic argument.");
            return unknownType;
        }
        if (node.kind === SyntaxKind.MethodDeclaration ||
            node.kind === 153 /* GetAccessor */ ||
            node.kind === 154 /* SetAccessor */) {
            // The `descriptor` for a method decorator will be a `TypedPropertyDescriptor<T>`
            // for the type of the member.
            let propertyType = getTypeOfNode(node);
            return createTypedPropertyDescriptorType(propertyType);
        }
        ts.Debug.fail("Unsupported decorator target.");
        return unknownType;
    }
    /**
     * Returns the effective argument type for the provided argument to a decorator.
     */
    function getEffectiveDecoratorArgumentType(node, argIndex) {
        if (argIndex === 0) {
            return getEffectiveDecoratorFirstArgumentType(node.parent);
        }
        else if (argIndex === 1) {
            return getEffectiveDecoratorSecondArgumentType(node.parent);
        }
        else if (argIndex === 2) {
            return getEffectiveDecoratorThirdArgumentType(node.parent);
        }
        ts.Debug.fail("Decorators should not have a fourth synthetic argument.");
        return unknownType;
    }
    /**
     * Gets the effective argument type for an argument in a call expression.
     */
    function getEffectiveArgumentType(node, argIndex) {
        // Decorators provide special arguments, a tagged template expression provides
        // a special first argument, and string literals get string literal types
        // unless we're reporting errors
        if (node.kind === 147 /* Decorator */) {
            return getEffectiveDecoratorArgumentType(node, argIndex);
        }
        else if (argIndex === 0 && node.kind === 183 /* TaggedTemplateExpression */) {
            return getGlobalTemplateStringsArrayType();
        }
        // This is not a synthetic argument, so we return 'undefined'
        // to signal that the caller needs to check the argument.
        return undefined;
    }
    /**
     * Gets the effective argument expression for an argument in a call expression.
     */
    function getEffectiveArgument(node, args, argIndex) {
        // For a decorator or the first argument of a tagged template expression we return undefined.
        if (node.kind === 147 /* Decorator */ ||
            (argIndex === 0 && node.kind === 183 /* TaggedTemplateExpression */)) {
            return undefined;
        }
        return args[argIndex];
    }
    /**
     * Gets the error node to use when reporting errors for an effective argument.
     */
    function getEffectiveArgumentErrorNode(node, argIndex, arg) {
        if (node.kind === 147 /* Decorator */) {
            // For a decorator, we use the expression of the decorator for error reporting.
            return node.expression;
        }
        else if (argIndex === 0 && node.kind === 183 /* TaggedTemplateExpression */) {
            // For a the first argument of a tagged template expression, we use the template of the tag for error reporting.
            return node.template;
        }
        else {
            return arg;
        }
    }
    function resolveCall(node, signatures, candidatesOutArray, fallbackError) {
        let isTaggedTemplate = node.kind === 183 /* TaggedTemplateExpression */;
        let isDecorator = node.kind === 147 /* Decorator */;
        let isJsxOpeningOrSelfClosingElement = ts.isJsxOpeningLikeElement(node);
        let typeArguments;
        if (!isTaggedTemplate && !isDecorator && !isJsxOpeningOrSelfClosingElement) {
            typeArguments = node.typeArguments;
            // We already perform checking on the type arguments on the class declaration itself.
            if (node.expression.kind !== 97 /* SuperKeyword */) {
                ts.forEach(typeArguments, checkSourceElement);
            }
        }
        let candidates = candidatesOutArray || [];
        // reorderCandidates fills up the candidates array directly
        reorderCandidates(signatures, candidates);
        if (!candidates.length) {
            diagnostics.add(ts.createDiagnosticForNode(node, ts.Diagnostics.Call_target_does_not_contain_any_signatures));
            return resolveErrorCall(node);
        }
        let args = getEffectiveCallArguments(node);
        // The following applies to any value of 'excludeArgument[i]':
        //    - true:      the argument at 'i' is susceptible to a one-time permanent contextual typing.
        //    - undefined: the argument at 'i' is *not* susceptible to permanent contextual typing.
        //    - false:     the argument at 'i' *was* and *has been* permanently contextually typed.
        //
        // The idea is that we will perform type argument inference & assignability checking once
        // without using the susceptible parameters that are functions, and once more for each of those
        // parameters, contextually typing each as we go along.
        //
        // For a tagged template, then the first argument be 'undefined' if necessary
        // because it represents a TemplateStringsArray.
        //
        // For a decorator, no arguments are susceptible to contextual typing due to the fact
        // decorators are applied to a declaration by the emitter, and not to an expression.
        let isSingleNonGenericCandidate = candidates.length === 1 && !candidates[0].typeParameters;
        let excludeArgument;
        let excludeCount = 0;
        if (!isDecorator && !isSingleNonGenericCandidate) {
            // We do not need to call `getEffectiveArgumentCount` here as it only
            // applies when calculating the number of arguments for a decorator.
            for (let i = isTaggedTemplate ? 1 : 0; i < args.length; i++) {
                if (isContextSensitive(args[i])) {
                    if (!excludeArgument) {
                        excludeArgument = new Array(args.length);
                    }
                    excludeArgument[i] = true;
                    excludeCount++;
                }
            }
        }
        // The following variables are captured and modified by calls to chooseOverload.
        // If overload resolution or type argument inference fails, we want to report the
        // best error possible. The best error is one which says that an argument was not
        // assignable to a parameter. This implies that everything else about the overload
        // was fine. So if there is any overload that is only incorrect because of an
        // argument, we will report an error on that one.
        //
        //     function foo(s: string): void;
        //     function foo(n: number): void; // Report argument error on this overload
        //     function foo(): void;
        //     foo(true);
        //
        // If none of the overloads even made it that far, there are two possibilities.
        // There was a problem with type arguments for some overload, in which case
        // report an error on that. Or none of the overloads even had correct arity,
        // in which case give an arity error.
        //
        //     function foo<T extends string>(x: T): void; // Report type argument error
        //     function foo(): void;
        //     foo<number>(0);
        //
        let candidateForArgumentError;
        let candidateForTypeArgumentError;
        let result;
        // If we are in signature help, a trailing comma indicates that we intend to provide another argument,
        // so we will only accept overloads with arity at least 1 higher than the current number of provided arguments.
        let signatureHelpTrailingComma = candidatesOutArray && node.kind === 181 /* CallExpression */ && node.arguments.hasTrailingComma;
        // Section 4.12.1:
        // if the candidate list contains one or more signatures for which the type of each argument
        // expression is a subtype of each corresponding parameter type, the return type of the first
        // of those signatures becomes the return type of the function call.
        // Otherwise, the return type of the first signature in the candidate list becomes the return
        // type of the function call.
        //
        // Whether the call is an error is determined by assignability of the arguments. The subtype pass
        // is just important for choosing the best signature. So in the case where there is only one
        // signature, the subtype pass is useless. So skipping it is an optimization.
        if (candidates.length > 1) {
            result = chooseOverload(candidates, subtypeRelation, signatureHelpTrailingComma);
        }
        if (!result) {
            result = chooseOverload(candidates, assignableRelation, signatureHelpTrailingComma);
        }
        if (result) {
            return result;
        }
        // No signatures were applicable. Now report errors based on the last applicable signature with
        // no arguments excluded from assignability checks.
        // If candidate is undefined, it means that no candidates had a suitable arity. In that case,
        // skip the checkApplicableSignature check.
        if (candidateForArgumentError) {
            if (isJsxOpeningOrSelfClosingElement) {
                // We do not report any error here because any error will be handled in "resolveCustomJsxElementAttributesType".
                return candidateForArgumentError;
            }
            // excludeArgument is undefined, in this case also equivalent to [undefined, undefined, ...]
            // The importance of excludeArgument is to prevent us from typing function expression parameters
            // in arguments too early. If possible, we'd like to only type them once we know the correct
            // overload. However, this matters for the case where the call is correct. When the call is
            // an error, we don't need to exclude any arguments, although it would cause no harm to do so.
            checkApplicableSignature(node, args, candidateForArgumentError, assignableRelation, /*excludeArgument*/ undefined, /*reportErrors*/ true);
        }
        else if (candidateForTypeArgumentError) {
            checkTypeArguments(candidateForTypeArgumentError, node.typeArguments, /*reportErrors*/ true, fallbackError);
        }
        else if (typeArguments && ts.every(signatures, function (sig) { return ts.length(sig.typeParameters) !== typeArguments.length; })) {
            let min = Number.POSITIVE_INFINITY;
            let max = Number.NEGATIVE_INFINITY;
            for (let _i = 0, signatures_5 = signatures; _i < signatures_5.length; _i++) {
                let sig = signatures_5[_i];
                min = Math.min(min, getMinTypeArgumentCount(sig.typeParameters));
                max = Math.max(max, ts.length(sig.typeParameters));
            }
            let paramCount = min < max ? min + "-" + max : min;
            diagnostics.add(ts.createDiagnosticForNode(node, ts.Diagnostics.Expected_0_type_arguments_but_got_1, paramCount, typeArguments.length));
        }
        else if (args) {
            let min = Number.POSITIVE_INFINITY;
            let max = Number.NEGATIVE_INFINITY;
            for (let _a = 0, signatures_6 = signatures; _a < signatures_6.length; _a++) {
                let sig = signatures_6[_a];
                min = Math.min(min, sig.minArgumentCount);
                max = Math.max(max, sig.parameters.length);
            }
            let hasRestParameter_1 = ts.some(signatures, function (sig) { return sig.hasRestParameter; });
            let hasSpreadArgument = getSpreadArgumentIndex(args) > -1;
            let paramCount = hasRestParameter_1 ? min :
                min < max ? min + "-" + max :
                    min;
            let argCount = args.length - (hasSpreadArgument ? 1 : 0);
            let error_1 = hasRestParameter_1 && hasSpreadArgument ? ts.Diagnostics.Expected_at_least_0_arguments_but_got_a_minimum_of_1 :
                hasRestParameter_1 ? ts.Diagnostics.Expected_at_least_0_arguments_but_got_1 :
                    hasSpreadArgument ? ts.Diagnostics.Expected_0_arguments_but_got_a_minimum_of_1 :
                        ts.Diagnostics.Expected_0_arguments_but_got_1;
            diagnostics.add(ts.createDiagnosticForNode(node, error_1, paramCount, argCount));
        }
        else if (fallbackError) {
            diagnostics.add(ts.createDiagnosticForNode(node, fallbackError));
        }
        // No signature was applicable. We have already reported the errors for the invalid signature.
        // If this is a type resolution session, e.g. Language Service, try to get better information than anySignature.
        // Pick the longest signature. This way we can get a contextual type for cases like:
        //     declare function f(a: { xa: number; xb: number; }, b: number);
        //     f({ |
        // Also, use explicitly-supplied type arguments if they are provided, so we can get a contextual signature in cases like:
        //     declare function f<T>(k: keyof T);
        //     f<Foo>("
        if (!produceDiagnostics) {
            ts.Debug.assert(candidates.length > 0); // Else would have exited above.
            let bestIndex = getLongestCandidateIndex(candidates, apparentArgumentCount === undefined ? args.length : apparentArgumentCount);
            let candidate = candidates[bestIndex];
            let typeParameters = candidate.typeParameters;
            if (typeParameters && callLikeExpressionMayHaveTypeArguments(node) && node.typeArguments) {
                let typeArguments_1 = node.typeArguments.map(getTypeOfNode);
                while (typeArguments_1.length > typeParameters.length) {
                    typeArguments_1.pop();
                }
                while (typeArguments_1.length < typeParameters.length) {
                    typeArguments_1.push(getDefaultTypeArgumentType(ts.isInJavaScriptFile(node)));
                }
                let instantiated = createSignatureInstantiation(candidate, typeArguments_1);
                candidates[bestIndex] = instantiated;
                return instantiated;
            }
            return candidate;
        }
        return resolveErrorCall(node);
        function chooseOverload(candidates, relation, signatureHelpTrailingComma) {
            if (signatureHelpTrailingComma === void 0) { signatureHelpTrailingComma = false; }
            candidateForArgumentError = undefined;
            candidateForTypeArgumentError = undefined;
            if (isSingleNonGenericCandidate) {
                let candidate = candidates[0];
                if (!hasCorrectArity(node, args, candidate, signatureHelpTrailingComma)) {
                    return undefined;
                }
                if (!checkApplicableSignature(node, args, candidate, relation, excludeArgument, /*reportErrors*/ false)) {
                    candidateForArgumentError = candidate;
                    return undefined;
                }
                return candidate;
            }
            for (let candidateIndex = 0; candidateIndex < candidates.length; candidateIndex++) {
                let originalCandidate = candidates[candidateIndex];
                if (!hasCorrectArity(node, args, originalCandidate, signatureHelpTrailingComma)) {
                    continue;
                }
                let candidate = void 0;
                let inferenceContext = originalCandidate.typeParameters ?
                    createInferenceContext(originalCandidate, /*flags*/ ts.isInJavaScriptFile(node) ? 4 /* AnyDefault */ : 0) :
                    undefined;
                while (true) {
                    candidate = originalCandidate;
                    if (candidate.typeParameters) {
                        let typeArgumentTypes = void 0;
                        if (typeArguments) {
                            let typeArgumentResult = checkTypeArguments(candidate, typeArguments, /*reportErrors*/ false);
                            if (typeArgumentResult) {
                                typeArgumentTypes = typeArgumentResult;
                            }
                            else {
                                candidateForTypeArgumentError = originalCandidate;
                                break;
                            }
                        }
                        else {
                            typeArgumentTypes = inferTypeArguments(node, candidate, args, excludeArgument, inferenceContext);
                        }
                        let isJavascript = ts.isInJavaScriptFile(candidate.declaration);
                        candidate = getSignatureInstantiation(candidate, typeArgumentTypes, isJavascript);
                    }
                    if (!checkApplicableSignature(node, args, candidate, relation, excludeArgument, /*reportErrors*/ false)) {
                        candidateForArgumentError = candidate;
                        break;
                    }
                    if (excludeCount === 0) {
                        candidates[candidateIndex] = candidate;
                        return candidate;
                    }
                    excludeCount--;
                    if (excludeCount > 0) {
                        excludeArgument[ts.indexOf(excludeArgument, /*value*/ true)] = false;
                    }
                    else {
                        excludeArgument = undefined;
                    }
                }
            }
            return undefined;
        }
    }
    function getLongestCandidateIndex(candidates, argsCount) {
        let maxParamsIndex = -1;
        let maxParams = -1;
        for (let i = 0; i < candidates.length; i++) {
            let candidate = candidates[i];
            if (candidate.hasRestParameter || candidate.parameters.length >= argsCount) {
                return i;
            }
            if (candidate.parameters.length > maxParams) {
                maxParams = candidate.parameters.length;
                maxParamsIndex = i;
            }
        }
        return maxParamsIndex;
    }
    function resolveCallExpression(node, candidatesOutArray) {
        if (node.expression.kind === 97 /* SuperKeyword */) {
            let superType = checkSuperExpression(node.expression);
            if (superType !== unknownType) {
                // In super call, the candidate signatures are the matching arity signatures of the base constructor function instantiated
                // with the type arguments specified in the extends clause.
                let baseTypeNode = ts.getClassExtendsHeritageClauseElement(ts.getContainingClass(node));
                if (baseTypeNode) {
                    let baseConstructors = getInstantiatedConstructorsForTypeArguments(superType, baseTypeNode.typeArguments, baseTypeNode);
                    return resolveCall(node, baseConstructors, candidatesOutArray);
                }
            }
            return resolveUntypedCall(node);
        }
        let funcType = checkNonNullExpression(node.expression);
        if (funcType === silentNeverType) {
            return silentNeverSignature;
        }
        let apparentType = getApparentType(funcType);
        if (apparentType === unknownType) {
            // Another error has already been reported
            return resolveErrorCall(node);
        }
        // Technically, this signatures list may be incomplete. We are taking the apparent type,
        // but we are not including call signatures that may have been added to the Object or
        // Function interface, since they have none by default. This is a bit of a leap of faith
        // that the user will not add any.
        let callSignatures = getSignaturesOfType(apparentType, 0 /* Call */);
        let constructSignatures = getSignaturesOfType(apparentType, 1 /* Construct */);
        // TS 1.0 Spec: 4.12
        // In an untyped function call no TypeArgs are permitted, Args can be any argument list, no contextual
        // types are provided for the argument expressions, and the result is always of type Any.
        if (isUntypedFunctionCall(funcType, apparentType, callSignatures.length, constructSignatures.length)) {
            // The unknownType indicates that an error already occurred (and was reported).  No
            // need to report another error in this case.
            if (funcType !== unknownType && node.typeArguments) {
                error(node, ts.Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
            }
            return resolveUntypedCall(node);
        }
        // If FuncExpr's apparent type(section 3.8.1) is a function type, the call is a typed function call.
        // TypeScript employs overload resolution in typed function calls in order to support functions
        // with multiple call signatures.
        if (!callSignatures.length) {
            if (constructSignatures.length) {
                error(node, ts.Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
            }
            else {
                error(node, ts.Diagnostics.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures, typeToString(apparentType));
            }
            return resolveErrorCall(node);
        }
        return resolveCall(node, callSignatures, candidatesOutArray);
    }
    /**
     * TS 1.0 spec: 4.12
     * If FuncExpr is of type Any, or of an object type that has no call or construct signatures
     * but is a subtype of the Function interface, the call is an untyped function call.
     */
    function isUntypedFunctionCall(funcType, apparentFuncType, numCallSignatures, numConstructSignatures) {
        if (isTypeAny(funcType)) {
            return true;
        }
        if (isTypeAny(apparentFuncType) && funcType.flags & 16384 /* TypeParameter */) {
            return true;
        }
        if (!numCallSignatures && !numConstructSignatures) {
            // We exclude union types because we may have a union of function types that happen to have
            // no common signatures.
            if (funcType.flags & 65536 /* Union */) {
                return false;
            }
            return isTypeAssignableTo(funcType, globalFunctionType);
        }
        return false;
    }
    function resolveNewExpression(node, candidatesOutArray) {
        if (node.arguments && languageVersion < 1 /* ES5 */) {
            let spreadIndex = getSpreadArgumentIndex(node.arguments);
            if (spreadIndex >= 0) {
                error(node.arguments[spreadIndex], ts.Diagnostics.Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher);
            }
        }
        let expressionType = checkNonNullExpression(node.expression);
        if (expressionType === silentNeverType) {
            return silentNeverSignature;
        }
        // If expressionType's apparent type(section 3.8.1) is an object type with one or
        // more construct signatures, the expression is processed in the same manner as a
        // function call, but using the construct signatures as the initial set of candidate
        // signatures for overload resolution. The result type of the function call becomes
        // the result type of the operation.
        expressionType = getApparentType(expressionType);
        if (expressionType === unknownType) {
            // Another error has already been reported
            return resolveErrorCall(node);
        }
        // TS 1.0 spec: 4.11
        // If expressionType is of type Any, Args can be any argument
        // list and the result of the operation is of type Any.
        if (isTypeAny(expressionType)) {
            if (node.typeArguments) {
                error(node, ts.Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
            }
            return resolveUntypedCall(node);
        }
        // Technically, this signatures list may be incomplete. We are taking the apparent type,
        // but we are not including construct signatures that may have been added to the Object or
        // Function interface, since they have none by default. This is a bit of a leap of faith
        // that the user will not add any.
        let constructSignatures = getSignaturesOfType(expressionType, 1 /* Construct */);
        if (constructSignatures.length) {
            if (!isConstructorAccessible(node, constructSignatures[0])) {
                return resolveErrorCall(node);
            }
            // If the expression is a class of abstract type, then it cannot be instantiated.
            // Note, only class declarations can be declared abstract.
            // In the case of a merged class-module or class-interface declaration,
            // only the class declaration node will have the Abstract flag set.
            let valueDecl = expressionType.symbol && getClassLikeDeclarationOfSymbol(expressionType.symbol);
            if (valueDecl && ts.hasModifier(valueDecl, 128 /* Abstract */)) {
                error(node, ts.Diagnostics.Cannot_create_an_instance_of_the_abstract_class_0, ts.declarationNameToString(ts.getNameOfDeclaration(valueDecl)));
                return resolveErrorCall(node);
            }
            return resolveCall(node, constructSignatures, candidatesOutArray);
        }
        // If expressionType's apparent type is an object type with no construct signatures but
        // one or more call signatures, the expression is processed as a function call. A compile-time
        // error occurs if the result of the function call is not Void. The type of the result of the
        // operation is Any. It is an error to have a Void this type.
        let callSignatures = getSignaturesOfType(expressionType, 0 /* Call */);
        if (callSignatures.length) {
            let signature = resolveCall(node, callSignatures, candidatesOutArray);
            if (!isJavaScriptConstructor(signature.declaration) && getReturnTypeOfSignature(signature) !== voidType) {
                error(node, ts.Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword);
            }
            if (getThisTypeOfSignature(signature) === voidType) {
                error(node, ts.Diagnostics.A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void);
            }
            return signature;
        }
        error(node, ts.Diagnostics.Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature);
        return resolveErrorCall(node);
    }
    function isConstructorAccessible(node, signature) {
        if (!signature || !signature.declaration) {
            return true;
        }
        let declaration = signature.declaration;
        let modifiers = ts.getSelectedModifierFlags(declaration, 24 /* NonPublicAccessibilityModifier */);
        // Public constructor is accessible.
        if (!modifiers) {
            return true;
        }
        let declaringClassDeclaration = getClassLikeDeclarationOfSymbol(declaration.parent.symbol);
        let declaringClass = getDeclaredTypeOfSymbol(declaration.parent.symbol);
        // A private or protected constructor can only be instantiated within its own class (or a subclass, for protected)
        if (!isNodeWithinClass(node, declaringClassDeclaration)) {
            let containingClass = ts.getContainingClass(node);
            if (containingClass) {
                let containingType = getTypeOfNode(containingClass);
                let baseTypes = getBaseTypes(containingType);
                while (baseTypes.length) {
                    let baseType = baseTypes[0];
                    if (modifiers & 16 /* Protected */ &&
                        baseType.symbol === declaration.parent.symbol) {
                        return true;
                    }
                    baseTypes = getBaseTypes(baseType);
                }
            }
            if (modifiers & 8 /* Private */) {
                error(node, ts.Diagnostics.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration, typeToString(declaringClass));
            }
            if (modifiers & 16 /* Protected */) {
                error(node, ts.Diagnostics.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration, typeToString(declaringClass));
            }
            return false;
        }
        return true;
    }
    function resolveTaggedTemplateExpression(node, candidatesOutArray) {
        let tagType = checkExpression(node.tag);
        let apparentType = getApparentType(tagType);
        if (apparentType === unknownType) {
            // Another error has already been reported
            return resolveErrorCall(node);
        }
        let callSignatures = getSignaturesOfType(apparentType, 0 /* Call */);
        let constructSignatures = getSignaturesOfType(apparentType, 1 /* Construct */);
        if (isUntypedFunctionCall(tagType, apparentType, callSignatures.length, constructSignatures.length)) {
            return resolveUntypedCall(node);
        }
        if (!callSignatures.length) {
            error(node, ts.Diagnostics.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures, typeToString(apparentType));
            return resolveErrorCall(node);
        }
        return resolveCall(node, callSignatures, candidatesOutArray);
    }
    /**
     * Gets the localized diagnostic head message to use for errors when resolving a decorator as a call expression.
     */
    function getDiagnosticHeadMessageForDecoratorResolution(node) {
        switch (node.parent.kind) {
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.ClassExpression:
                return ts.Diagnostics.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression;
            case SyntaxKind.Parameter:
                return ts.Diagnostics.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression;
            case SyntaxKind.PropertyDeclaration:
                return ts.Diagnostics.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression;
            case SyntaxKind.MethodDeclaration:
            case 153 /* GetAccessor */:
            case 154 /* SetAccessor */:
                return ts.Diagnostics.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression;
        }
    }
    /**
     * Resolves a decorator as if it were a call expression.
     */
    function resolveDecorator(node, candidatesOutArray) {
        let funcType = checkExpression(node.expression);
        let apparentType = getApparentType(funcType);
        if (apparentType === unknownType) {
            return resolveErrorCall(node);
        }
        let callSignatures = getSignaturesOfType(apparentType, 0 /* Call */);
        let constructSignatures = getSignaturesOfType(apparentType, 1 /* Construct */);
        if (isUntypedFunctionCall(funcType, apparentType, callSignatures.length, constructSignatures.length)) {
            return resolveUntypedCall(node);
        }
        if (isPotentiallyUncalledDecorator(node, callSignatures)) {
            let nodeStr = ts.getTextOfNode(node.expression, /*includeTrivia*/ false);
            error(node, ts.Diagnostics._0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0, nodeStr);
            return resolveErrorCall(node);
        }
        let headMessage = getDiagnosticHeadMessageForDecoratorResolution(node);
        if (!callSignatures.length) {
            let errorInfo = void 0;
            errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures, typeToString(apparentType));
            errorInfo = ts.chainDiagnosticMessages(errorInfo, headMessage);
            diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(node, errorInfo));
            return resolveErrorCall(node);
        }
        return resolveCall(node, callSignatures, candidatesOutArray, headMessage);
    }
    /**
     * Sometimes, we have a decorator that could accept zero arguments,
     * but is receiving too many arguments as part of the decorator invocation.
     * In those cases, a user may have meant to *call* the expression before using it as a decorator.
     */
    function isPotentiallyUncalledDecorator(decorator, signatures) {
        return signatures.length && ts.every(signatures, function (signature) {
            return signature.minArgumentCount === 0 &&
                !signature.hasRestParameter &&
                signature.parameters.length < getEffectiveArgumentCount(decorator, /*args*/ undefined, signature);
        });
    }
    /**
     * This function is similar to getResolvedSignature but is exclusively for trying to resolve JSX stateless-function component.
     * The main reason we have to use this function instead of getResolvedSignature because, the caller of this function will already check the type of openingLikeElement's tagName
     * and pass the type as elementType. The elementType can not be a union (as such case should be handled by the caller of this function)
     * Note: at this point, we are still not sure whether the opening-like element is a stateless function component or not.
     * @param openingLikeElement an opening-like JSX element to try to resolve as JSX stateless function
     * @param elementType an element type of the opneing-like element by checking opening-like element's tagname.
     * @param candidatesOutArray an array of signature to be filled in by the function. It is passed by signature help in the language service;
     *                           the function will fill it up with appropriate candidate signatures
     */
    function getResolvedJsxStatelessFunctionSignature(openingLikeElement, elementType, candidatesOutArray) {
        ts.Debug.assert(!(elementType.flags & 65536 /* Union */));
        return resolveStatelessJsxOpeningLikeElement(openingLikeElement, elementType, candidatesOutArray);
    }
    /**
     * Try treating a given opening-like element as stateless function component and resolve a tagName to a function signature.
     * @param openingLikeElement an JSX opening-like element we want to try resolve its stateless function if possible
     * @param elementType a type of the opening-like JSX element, a result of resolving tagName in opening-like element.
     * @param candidatesOutArray an array of signature to be filled in by the function. It is passed by signature help in the language service;
     *                           the function will fill it up with appropriate candidate signatures
     * @return a resolved signature if we can find function matching function signature through resolve call or a first signature in the list of functions.
     *         otherwise return undefined if tag-name of the opening-like element doesn't have call signatures
     */
    function resolveStatelessJsxOpeningLikeElement(openingLikeElement, elementType, candidatesOutArray) {
        // If this function is called from language service, elementType can be a union type. This is not possible if the function is called from compiler (see: resolveCustomJsxElementAttributesType)
        if (elementType.flags & 65536 /* Union */) {
            let types = elementType.types;
            let result = void 0;
            for (let _i = 0, types_17 = types; _i < types_17.length; _i++) {
                let type = types_17[_i];
                result = result || resolveStatelessJsxOpeningLikeElement(openingLikeElement, type, candidatesOutArray);
            }
            return result;
        }
        let callSignatures = elementType && getSignaturesOfType(elementType, 0 /* Call */);
        if (callSignatures && callSignatures.length > 0) {
            return resolveCall(openingLikeElement, callSignatures, candidatesOutArray);
        }
        return undefined;
    }
    function resolveSignature(node, candidatesOutArray) {
        switch (node.kind) {
            case 181 /* CallExpression */:
                return resolveCallExpression(node, candidatesOutArray);
            case 182 /* NewExpression */:
                return resolveNewExpression(node, candidatesOutArray);
            case 183 /* TaggedTemplateExpression */:
                return resolveTaggedTemplateExpression(node, candidatesOutArray);
            case 147 /* Decorator */:
                return resolveDecorator(node, candidatesOutArray);
            case 251 /* JsxOpeningElement */:
            case 250 /* JsxSelfClosingElement */:
                // This code-path is called by language service
                return resolveStatelessJsxOpeningLikeElement(node, checkExpression(node.tagName), candidatesOutArray) || unknownSignature;
        }
        ts.Debug.assertNever(node, "Branch in 'resolveSignature' should be unreachable.");
    }
    /**
     * Resolve a signature of a given call-like expression.
     * @param node a call-like expression to try resolve a signature for
     * @param candidatesOutArray an array of signature to be filled in by the function. It is passed by signature help in the language service;
     *                           the function will fill it up with appropriate candidate signatures
     * @return a signature of the call-like expression or undefined if one can't be found
     */
    function getResolvedSignature(node, candidatesOutArray) {
        let links = getNodeLinks(node);
        // If getResolvedSignature has already been called, we will have cached the resolvedSignature.
        // However, it is possible that either candidatesOutArray was not passed in the first time,
        // or that a different candidatesOutArray was passed in. Therefore, we need to redo the work
        // to correctly fill the candidatesOutArray.
        let cached = links.resolvedSignature;
        if (cached && cached !== resolvingSignature && !candidatesOutArray) {
            return cached;
        }
        links.resolvedSignature = resolvingSignature;
        let result = resolveSignature(node, candidatesOutArray);
        // If signature resolution originated in control flow type analysis (for example to compute the
        // assigned type in a flow assignment) we don't cache the result as it may be based on temporary
        // types from the control flow analysis.
        links.resolvedSignature = flowLoopStart === flowLoopCount ? result : cached;
        return result;
    }
    /**
     * Indicates whether a declaration can be treated as a constructor in a JavaScript
     * file.
     */
    function isJavaScriptConstructor(node) {
        if (node && ts.isInJavaScriptFile(node)) {
            // If the node has a @class tag, treat it like a constructor.
            if (ts.getJSDocClassTag(node))
                return true;
            // If the symbol of the node has members, treat it like a constructor.
            let symbol = ts.isFunctionDeclaration(node) || ts.isFunctionExpression(node) ? getSymbolOfNode(node) :
                ts.isVariableDeclaration(node) && node.initializer && ts.isFunctionExpression(node.initializer) ? getSymbolOfNode(node.initializer) :
                    undefined;
            return symbol && symbol.members !== undefined;
        }
        return false;
    }
    function getJavaScriptClassType(symbol) {
        if (ts.isDeclarationOfFunctionOrClassExpression(symbol)) {
            symbol = getSymbolOfNode(symbol.valueDeclaration.initializer);
        }
        if (isJavaScriptConstructor(symbol.valueDeclaration)) {
            return getInferredClassType(symbol);
        }
        if (symbol.flags & 3 /* Variable */) {
            let valueType = getTypeOfSymbol(symbol);
            if (valueType.symbol && !isInferredClassType(valueType) && isJavaScriptConstructor(valueType.symbol.valueDeclaration)) {
                return getInferredClassType(valueType.symbol);
            }
        }
    }
    function getInferredClassType(symbol) {
        let links = getSymbolLinks(symbol);
        if (!links.inferredClassType) {
            links.inferredClassType = createAnonymousType(symbol, symbol.members || emptySymbols, ts.emptyArray, ts.emptyArray, /*stringIndexType*/ undefined, /*numberIndexType*/ undefined);
        }
        return links.inferredClassType;
    }
    function isInferredClassType(type) {
        return type.symbol
            && getObjectFlags(type) & 16 /* Anonymous */
            && getSymbolLinks(type.symbol).inferredClassType === type;
    }
    /**
     * Syntactically and semantically checks a call or new expression.
     * @param node The call/new expression to be checked.
     * @returns On success, the expression's signature's return type. On failure, anyType.
     */
    function checkCallExpression(node) {
        // Grammar checking; stop grammar-checking if checkGrammarTypeArguments return true
        checkGrammarTypeArguments(node, node.typeArguments) || checkGrammarArguments(node.arguments);
        let signature = getResolvedSignature(node);
        if (node.expression.kind === 97 /* SuperKeyword */) {
            return voidType;
        }
        if (node.kind === 182 /* NewExpression */) {
            let declaration = signature.declaration;
            if (declaration &&
                declaration.kind !== 152 /* Constructor */ &&
                declaration.kind !== 156 /* ConstructSignature */ &&
                declaration.kind !== 161 /* ConstructorType */ &&
                !ts.isJSDocConstructSignature(declaration)) {
                // When resolved signature is a call signature (and not a construct signature) the result type is any, unless
                // the declaring function had members created through 'x.prototype.y = expr' or 'this.y = expr' psuedodeclarations
                // in a JS file
                // Note:JS inferred classes might come from a variable declaration instead of a function declaration.
                // In this case, using getResolvedSymbol directly is required to avoid losing the members from the declaration.
                let funcSymbol = checkExpression(node.expression).symbol;
                if (!funcSymbol && node.expression.kind === 71 /* Identifier */) {
                    funcSymbol = getResolvedSymbol(node.expression);
                }
                let type = funcSymbol && getJavaScriptClassType(funcSymbol);
                if (type) {
                    return type;
                }
                if (noImplicitAny) {
                    error(node, ts.Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type);
                }
                return anyType;
            }
        }
        // In JavaScript files, calls to any identifier 'require' are treated as external module imports
        if (ts.isInJavaScriptFile(node) && isCommonJsRequire(node)) {
            return resolveExternalModuleTypeByLiteral(node.arguments[0]);
        }
        return getReturnTypeOfSignature(signature);
    }
    function checkImportCallExpression(node) {
        // Check grammar of dynamic import
        checkGrammarArguments(node.arguments) || checkGrammarImportCallExpression(node);
        if (node.arguments.length === 0) {
            return createPromiseReturnType(node, anyType);
        }
        let specifier = node.arguments[0];
        let specifierType = checkExpressionCached(specifier);
        // Even though multiple arugments is grammatically incorrect, type-check extra arguments for completion
        for (let i = 1; i < node.arguments.length; ++i) {
            checkExpressionCached(node.arguments[i]);
        }
        if (specifierType.flags & 2048 /* Undefined */ || specifierType.flags & 4096 /* Null */ || !isTypeAssignableTo(specifierType, stringType)) {
            error(specifier, ts.Diagnostics.Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0, typeToString(specifierType));
        }
        // resolveExternalModuleName will return undefined if the moduleReferenceExpression is not a string literal
        let moduleSymbol = resolveExternalModuleName(node, specifier);
        if (moduleSymbol) {
            let esModuleSymbol = resolveESModuleSymbol(moduleSymbol, specifier, /*dontRecursivelyResolve*/ true);
            if (esModuleSymbol) {
                return createPromiseReturnType(node, getTypeWithSyntheticDefaultImportType(getTypeOfSymbol(esModuleSymbol), esModuleSymbol));
            }
        }
        return createPromiseReturnType(node, anyType);
    }
    function getTypeWithSyntheticDefaultImportType(type, symbol) {
        if (allowSyntheticDefaultImports && type && type !== unknownType) {
            let synthType = type;
            if (!synthType.syntheticType) {
                if (!getPropertyOfType(type, "default" /* Default */)) {
                    let memberTable = ts.createSymbolTable();
                    let newSymbol = createSymbol(SymbolFlags.Alias, "default" /* Default */);
                    newSymbol.target = resolveSymbol(symbol);
                    memberTable.set("default" /* Default */, newSymbol);
                    let anonymousSymbol = createSymbol(2048 /* TypeLiteral */, "__type" /* Type */);
                    let defaultContainingObject = createAnonymousType(anonymousSymbol, memberTable, ts.emptyArray, ts.emptyArray, /*stringIndexInfo*/ undefined, /*numberIndexInfo*/ undefined);
                    anonymousSymbol.type = defaultContainingObject;
                    synthType.syntheticType = getIntersectionType([type, defaultContainingObject]);
                }
                else {
                    synthType.syntheticType = type;
                }
            }
            return synthType.syntheticType;
        }
        return type;
    }
    function isCommonJsRequire(node) {
        if (!ts.isRequireCall(node, /*checkArgumentIsStringLiteral*/ true)) {
            return false;
        }
        // Make sure require is not a local function
        if (!ts.isIdentifier(node.expression))
            throw ts.Debug.fail();
        let resolvedRequire = resolveName(node.expression, node.expression.escapedText, SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ true);
        if (!resolvedRequire) {
            // project does not contain symbol named 'require' - assume commonjs require
            return true;
        }
        // project includes symbol named 'require' - make sure that it it ambient and local non-alias
        if (resolvedRequire.flags & SymbolFlags.Alias) {
            return false;
        }
        let targetDeclarationKind = resolvedRequire.flags & 16 /* Function */
            ? 228 /* FunctionDeclaration */
            : resolvedRequire.flags & 3 /* Variable */
                ? SyntaxKind.VariableDeclaration
                : 0 /* Unknown */;
        if (targetDeclarationKind !== 0 /* Unknown */) {
            let decl = ts.getDeclarationOfKind(resolvedRequire, targetDeclarationKind);
            // function/variable declaration should be ambient
            return ts.isInAmbientContext(decl);
        }
        return false;
    }
    function checkTaggedTemplateExpression(node) {
        if (languageVersion < 2 /* ES2015 */) {
            checkExternalEmitHelpers(node, 65536 /* MakeTemplateObject */);
        }
        return getReturnTypeOfSignature(getResolvedSignature(node));
    }
    function checkAssertion(node) {
        return checkAssertionWorker(node, node.type, node.expression);
    }
    function checkAssertionWorker(errNode, type, expression, checkMode) {
        let exprType = getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(checkExpression(expression, checkMode)));
        checkSourceElement(type);
        let targetType = getTypeFromTypeNode(type);
        if (produceDiagnostics && targetType !== unknownType) {
            let widenedType = getWidenedType(exprType);
            if (!isTypeComparableTo(targetType, widenedType)) {
                checkTypeComparableTo(exprType, targetType, errNode, ts.Diagnostics.Type_0_cannot_be_converted_to_type_1);
            }
        }
        return targetType;
    }
    function checkNonNullAssertion(node) {
        return getNonNullableType(checkExpression(node.expression));
    }
    function checkMetaProperty(node) {
        checkGrammarMetaProperty(node);
        let container = ts.getNewTargetContainer(node);
        if (!container) {
            error(node, ts.Diagnostics.Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor, "new.target");
            return unknownType;
        }
        else if (container.kind === 152 /* Constructor */) {
            let symbol = getSymbolOfNode(container.parent);
            return getTypeOfSymbol(symbol);
        }
        else {
            let symbol = getSymbolOfNode(container);
            return getTypeOfSymbol(symbol);
        }
    }
    function getTypeOfParameter(symbol) {
        let type = getTypeOfSymbol(symbol);
        if (strictNullChecks) {
            let declaration = symbol.valueDeclaration;
            if (declaration && declaration.initializer) {
                return getNullableType(type, 2048 /* Undefined */);
            }
        }
        return type;
    }
    function getTypeAtPosition(signature, pos) {
        return signature.hasRestParameter ?
            pos < signature.parameters.length - 1 ? getTypeOfParameter(signature.parameters[pos]) : getRestTypeOfSignature(signature) :
            pos < signature.parameters.length ? getTypeOfParameter(signature.parameters[pos]) : anyType;
    }
    function getTypeOfFirstParameterOfSignature(signature) {
        return signature.parameters.length > 0 ? getTypeAtPosition(signature, 0) : neverType;
    }
    function inferFromAnnotatedParameters(signature, context, mapper) {
        let len = signature.parameters.length - (signature.hasRestParameter ? 1 : 0);
        for (let i = 0; i < len; i++) {
            let declaration = signature.parameters[i].valueDeclaration;
            if (declaration.type) {
                let typeNode = ts.getEffectiveTypeAnnotationNode(declaration);
                if (typeNode) {
                    inferTypes(mapper.inferences, getTypeFromTypeNode(typeNode), getTypeAtPosition(context, i));
                }
            }
        }
    }
    function assignContextualParameterTypes(signature, context) {
        signature.typeParameters = context.typeParameters;
        if (context.thisParameter) {
            let parameter = signature.thisParameter;
            if (!parameter || parameter.valueDeclaration && !parameter.valueDeclaration.type) {
                if (!parameter) {
                    signature.thisParameter = createSymbolWithType(context.thisParameter, /*type*/ undefined);
                }
                assignTypeToParameterAndFixTypeParameters(signature.thisParameter, getTypeOfSymbol(context.thisParameter));
            }
        }
        let len = signature.parameters.length - (signature.hasRestParameter ? 1 : 0);
        for (let i = 0; i < len; i++) {
            let parameter = signature.parameters[i];
            if (!ts.getEffectiveTypeAnnotationNode(parameter.valueDeclaration)) {
                let contextualParameterType = getTypeAtPosition(context, i);
                assignTypeToParameterAndFixTypeParameters(parameter, contextualParameterType);
            }
        }
        if (signature.hasRestParameter && isRestParameterIndex(context, signature.parameters.length - 1)) {
            // parameter might be a transient symbol generated by use of `arguments` in the function body.
            let parameter = ts.lastOrUndefined(signature.parameters);
            if (isTransientSymbol(parameter) || !ts.getEffectiveTypeAnnotationNode(parameter.valueDeclaration)) {
                let contextualParameterType = getTypeOfSymbol(ts.lastOrUndefined(context.parameters));
                assignTypeToParameterAndFixTypeParameters(parameter, contextualParameterType);
            }
        }
    }
    // When contextual typing assigns a type to a parameter that contains a binding pattern, we also need to push
    // the destructured type into the contained binding elements.
    function assignBindingElementTypes(pattern) {
        for (let _i = 0, _a = pattern.elements; _i < _a.length; _i++) {
            let element = _a[_i];
            if (!ts.isOmittedExpression(element)) {
                if (element.name.kind === 71 /* Identifier */) {
                    getSymbolLinks(getSymbolOfNode(element)).type = getTypeForBindingElement(element);
                }
                else {
                    assignBindingElementTypes(element.name);
                }
            }
        }
    }
    function assignTypeToParameterAndFixTypeParameters(parameter, contextualType) {
        let links = getSymbolLinks(parameter);
        if (!links.type) {
            links.type = contextualType;
            let decl = parameter.valueDeclaration;
            if (decl.name.kind !== 71 /* Identifier */) {
                // if inference didn't come up with anything but {}, fall back to the binding pattern if present.
                if (links.type === emptyObjectType) {
                    links.type = getTypeFromBindingPattern(decl.name);
                }
                assignBindingElementTypes(decl.name);
            }
        }
    }
    function createPromiseType(promisedType) {
        // creates a `Promise<T>` type where `T` is the promisedType argument
        let globalPromiseType = getGlobalPromiseType(/*reportErrors*/ true);
        if (globalPromiseType !== emptyGenericType) {
            // if the promised type is itself a promise, get the underlying type; otherwise, fallback to the promised type
            promisedType = getAwaitedType(promisedType) || emptyObjectType;
            return createTypeReference(globalPromiseType, [promisedType]);
        }
        return emptyObjectType;
    }
    function createPromiseReturnType(func, promisedType) {
        let promiseType = createPromiseType(promisedType);
        if (promiseType === emptyObjectType) {
            error(func, ts.isImportCall(func) ?
                ts.Diagnostics.A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option :
                ts.Diagnostics.An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option);
            return unknownType;
        }
        else if (!getGlobalPromiseConstructorSymbol(/*reportErrors*/ true)) {
            error(func, ts.isImportCall(func) ?
                ts.Diagnostics.A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option :
                ts.Diagnostics.An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option);
        }
        return promiseType;
    }
    function getReturnTypeFromBody(func, checkMode) {
        let contextualSignature = getContextualSignatureForFunctionLikeDeclaration(func);
        if (!func.body) {
            return unknownType;
        }
        let functionFlags = ts.getFunctionFlags(func);
        let type;
        if (func.body.kind !== 207 /* Block */) {
            type = checkExpressionCached(func.body, checkMode);
            if (functionFlags & 2 /* Async */) {
                // From within an async function you can return either a non-promise value or a promise. Any
                // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
                // return type of the body should be unwrapped to its awaited type, which we will wrap in
                // the native Promise<T> type later in this function.
                type = checkAwaitedType(type, /*errorNode*/ func, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
            }
        }
        else {
            let types = void 0;
            if (functionFlags & 1 /* Generator */) {
                types = ts.concatenate(checkAndAggregateYieldOperandTypes(func, checkMode), checkAndAggregateReturnExpressionTypes(func, checkMode));
                if (!types || types.length === 0) {
                    let iterableIteratorAny = functionFlags & 2 /* Async */
                        ? createAsyncIterableIteratorType(anyType) // AsyncGenerator function
                        : createIterableIteratorType(anyType); // Generator function
                    if (noImplicitAny) {
                        error(func.asteriskToken, ts.Diagnostics.Generator_implicitly_has_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type, typeToString(iterableIteratorAny));
                    }
                    return iterableIteratorAny;
                }
            }
            else {
                types = checkAndAggregateReturnExpressionTypes(func, checkMode);
                if (!types) {
                    // For an async function, the return type will not be never, but rather a Promise for never.
                    return functionFlags & 2 /* Async */
                        ? createPromiseReturnType(func, neverType) // Async function
                        : neverType; // Normal function
                }
                if (types.length === 0) {
                    // For an async function, the return type will not be void, but rather a Promise for void.
                    return functionFlags & 2 /* Async */
                        ? createPromiseReturnType(func, voidType) // Async function
                        : voidType; // Normal function
                }
            }
            // Return a union of the return expression types.
            type = getUnionType(types, /*subtypeReduction*/ true);
            if (functionFlags & 1 /* Generator */) {
                type = functionFlags & 2 /* Async */
                    ? createAsyncIterableIteratorType(type) // AsyncGenerator function
                    : createIterableIteratorType(type); // Generator function
            }
        }
        if (!contextualSignature) {
            reportErrorsFromWidening(func, type);
        }
        if (isUnitType(type) &&
            !(contextualSignature &&
                isLiteralContextualType(contextualSignature === getSignatureFromDeclaration(func) ? type : getReturnTypeOfSignature(contextualSignature)))) {
            type = getWidenedLiteralType(type);
        }
        let widenedType = getWidenedType(type);
        // From within an async function you can return either a non-promise value or a promise. Any
        // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
        // return type of the body is awaited type of the body, wrapped in a native Promise<T> type.
        return (functionFlags & 3 /* AsyncGenerator */) === 2 /* Async */
            ? createPromiseReturnType(func, widenedType) // Async function
            : widenedType; // Generator function, AsyncGenerator function, or normal function
    }
    function checkAndAggregateYieldOperandTypes(func, checkMode) {
        let aggregatedTypes = [];
        let functionFlags = ts.getFunctionFlags(func);
        ts.forEachYieldExpression(func.body, function (yieldExpression) {
            let expr = yieldExpression.expression;
            if (expr) {
                let type = checkExpressionCached(expr, checkMode);
                if (yieldExpression.asteriskToken) {
                    // A yield* expression effectively yields everything that its operand yields
                    type = checkIteratedTypeOrElementType(type, yieldExpression.expression, /*allowStringInput*/ false, (functionFlags & 2 /* Async */) !== 0);
                }
                if (functionFlags & 2 /* Async */) {
                    type = checkAwaitedType(type, expr, yieldExpression.asteriskToken
                        ? ts.Diagnostics.Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member
                        : ts.Diagnostics.Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
                }
                ts.pushIfUnique(aggregatedTypes, type);
            }
        });
        return aggregatedTypes;
    }
    function isExhaustiveSwitchStatement(node) {
        if (!node.possiblyExhaustive) {
            return false;
        }
        let type = getTypeOfExpression(node.expression);
        if (!isLiteralType(type)) {
            return false;
        }
        let switchTypes = getSwitchClauseTypes(node);
        if (!switchTypes.length) {
            return false;
        }
        return eachTypeContainedIn(mapType(type, getRegularTypeOfLiteralType), switchTypes);
    }
    function functionHasImplicitReturn(func) {
        if (!(func.flags & 128 /* HasImplicitReturn */)) {
            return false;
        }
        let lastStatement = ts.lastOrUndefined(func.body.statements);
        if (lastStatement && lastStatement.kind === 221 /* SwitchStatement */ && isExhaustiveSwitchStatement(lastStatement)) {
            return false;
        }
        return true;
    }
    function checkAndAggregateReturnExpressionTypes(func, checkMode) {
        let functionFlags = ts.getFunctionFlags(func);
        let aggregatedTypes = [];
        let hasReturnWithNoExpression = functionHasImplicitReturn(func);
        let hasReturnOfTypeNever = false;
        ts.forEachReturnStatement(func.body, function (returnStatement) {
            let expr = returnStatement.expression;
            if (expr) {
                let type = checkExpressionCached(expr, checkMode);
                if (functionFlags & 2 /* Async */) {
                    // From within an async function you can return either a non-promise value or a promise. Any
                    // Promise/A+ compatible implementation will always assimilate any foreign promise, so the
                    // return type of the body should be unwrapped to its awaited type, which should be wrapped in
                    // the native Promise<T> type by the caller.
                    type = checkAwaitedType(type, func, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
                }
                if (type.flags & 8192 /* Never */) {
                    hasReturnOfTypeNever = true;
                }
                ts.pushIfUnique(aggregatedTypes, type);
            }
            else {
                hasReturnWithNoExpression = true;
            }
        });
        if (aggregatedTypes.length === 0 && !hasReturnWithNoExpression && (hasReturnOfTypeNever ||
            func.kind === 186 /* FunctionExpression */ || func.kind === 187 /* ArrowFunction */)) {
            return undefined;
        }
        if (strictNullChecks && aggregatedTypes.length && hasReturnWithNoExpression) {
            ts.pushIfUnique(aggregatedTypes, undefinedType);
        }
        return aggregatedTypes;
    }
    /**
     * TypeScript Specification 1.0 (6.3) - July 2014
     *   An explicitly typed function whose return type isn't the Void type,
     *   the Any type, or a union type containing the Void or Any type as a constituent
     *   must have at least one return statement somewhere in its body.
     *   An exception to this rule is if the function implementation consists of a single 'throw' statement.
     *
     * @param returnType - return type of the function, can be undefined if return type is not explicitly specified
     */
    function checkAllCodePathsInNonVoidFunctionReturnOrThrow(func, returnType) {
        if (!produceDiagnostics) {
            return;
        }
        // Functions with with an explicitly specified 'void' or 'any' return type don't need any return expressions.
        if (returnType && maybeTypeOfKind(returnType, 1 /* Any */ | 1024 /* Void */)) {
            return;
        }
        // If all we have is a function signature, or an arrow function with an expression body, then there is nothing to check.
        // also if HasImplicitReturn flag is not set this means that all codepaths in function body end with return or throw
        if (ts.nodeIsMissing(func.body) || func.body.kind !== 207 /* Block */ || !functionHasImplicitReturn(func)) {
            return;
        }
        let hasExplicitReturn = func.flags & 256 /* HasExplicitReturn */;
        if (returnType && returnType.flags & 8192 /* Never */) {
            error(ts.getEffectiveReturnTypeNode(func), ts.Diagnostics.A_function_returning_never_cannot_have_a_reachable_end_point);
        }
        else if (returnType && !hasExplicitReturn) {
            // minimal check: function has syntactic return type annotation and no explicit return statements in the body
            // this function does not conform to the specification.
            // NOTE: having returnType !== undefined is a precondition for entering this branch so func.type will always be present
            error(ts.getEffectiveReturnTypeNode(func), ts.Diagnostics.A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value);
        }
        else if (returnType && strictNullChecks && !isTypeAssignableTo(undefinedType, returnType)) {
            error(ts.getEffectiveReturnTypeNode(func), ts.Diagnostics.Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined);
        }
        else if (compilerOptions.noImplicitReturns) {
            if (!returnType) {
                // If return type annotation is omitted check if function has any explicit return statements.
                // If it does not have any - its inferred return type is void - don't do any checks.
                // Otherwise get inferred return type from function body and report error only if it is not void / anytype
                if (!hasExplicitReturn) {
                    return;
                }
                let inferredReturnType = getReturnTypeOfSignature(getSignatureFromDeclaration(func));
                if (isUnwrappedReturnTypeVoidOrAny(func, inferredReturnType)) {
                    return;
                }
            }
            error(ts.getEffectiveReturnTypeNode(func) || func, ts.Diagnostics.Not_all_code_paths_return_a_value);
        }
    }
    function checkFunctionExpressionOrObjectLiteralMethod(node, checkMode) {
        ts.Debug.assert(node.kind !== SyntaxKind.MethodDeclaration || ts.isObjectLiteralMethod(node));
        // The identityMapper object is used to indicate that function expressions are wildcards
        if (checkMode === 1 /* SkipContextSensitive */ && isContextSensitive(node)) {
            checkNodeDeferred(node);
            return anyFunctionType;
        }
        // Grammar checking
        let hasGrammarError = checkGrammarFunctionLikeDeclaration(node);
        if (!hasGrammarError && node.kind === 186 /* FunctionExpression */) {
            checkGrammarForGenerator(node);
        }
        let links = getNodeLinks(node);
        let type = getTypeOfSymbol(node.symbol);
        // Check if function expression is contextually typed and assign parameter types if so.
        if (!(links.flags & 1024 /* ContextChecked */)) {
            let contextualSignature = getContextualSignature(node);
            // If a type check is started at a function expression that is an argument of a function call, obtaining the
            // contextual type may recursively get back to here during overload resolution of the call. If so, we will have
            // already assigned contextual types.
            if (!(links.flags & 1024 /* ContextChecked */)) {
                links.flags |= 1024 /* ContextChecked */;
                if (contextualSignature) {
                    let signature = getSignaturesOfType(type, 0 /* Call */)[0];
                    if (isContextSensitive(node)) {
                        let contextualMapper = getContextualMapper(node);
                        if (checkMode === 2 /* Inferential */) {
                            inferFromAnnotatedParameters(signature, contextualSignature, contextualMapper);
                        }
                        let instantiatedContextualSignature = contextualMapper === identityMapper ?
                            contextualSignature : instantiateSignature(contextualSignature, contextualMapper);
                        assignContextualParameterTypes(signature, instantiatedContextualSignature);
                    }
                    if (!ts.getEffectiveReturnTypeNode(node) && !signature.resolvedReturnType) {
                        let returnType = getReturnTypeFromBody(node, checkMode);
                        if (!signature.resolvedReturnType) {
                            signature.resolvedReturnType = returnType;
                        }
                    }
                }
                checkSignatureDeclaration(node);
                checkNodeDeferred(node);
            }
        }
        if (produceDiagnostics && node.kind !== SyntaxKind.MethodDeclaration) {
            checkCollisionWithCapturedSuperVariable(node, node.name);
            checkCollisionWithCapturedThisVariable(node, node.name);
            checkCollisionWithCapturedNewTargetVariable(node, node.name);
        }
        return type;
    }
    function checkFunctionExpressionOrObjectLiteralMethodDeferred(node) {
        ts.Debug.assert(node.kind !== SyntaxKind.MethodDeclaration || ts.isObjectLiteralMethod(node));
        let functionFlags = ts.getFunctionFlags(node);
        let returnTypeNode = ts.getEffectiveReturnTypeNode(node);
        let returnOrPromisedType = returnTypeNode &&
            ((functionFlags & 3 /* AsyncGenerator */) === 2 /* Async */ ?
                checkAsyncFunctionReturnType(node) : // Async function
                getTypeFromTypeNode(returnTypeNode)); // AsyncGenerator function, Generator function, or normal function
        if ((functionFlags & 1 /* Generator */) === 0) {
            // return is not necessary in the body of generators
            checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnOrPromisedType);
        }
        if (node.body) {
            if (!returnTypeNode) {
                // There are some checks that are only performed in getReturnTypeFromBody, that may produce errors
                // we need. An example is the noImplicitAny errors resulting from widening the return expression
                // of a function. Because checking of function expression bodies is deferred, there was never an
                // appropriate time to do this during the main walk of the file (see the comment at the top of
                // checkFunctionExpressionBodies). So it must be done now.
                getReturnTypeOfSignature(getSignatureFromDeclaration(node));
            }
            if (node.body.kind === 207 /* Block */) {
                checkSourceElement(node.body);
            }
            else {
                // From within an async function you can return either a non-promise value or a promise. Any
                // Promise/A+ compatible implementation will always assimilate any foreign promise, so we
                // should not be checking assignability of a promise to the return type. Instead, we need to
                // check assignability of the awaited type of the expression body against the promised type of
                // its return type annotation.
                let exprType = checkExpression(node.body);
                if (returnOrPromisedType) {
                    if ((functionFlags & 3 /* AsyncGenerator */) === 2 /* Async */) {
                        let awaitedType = checkAwaitedType(exprType, node.body, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
                        checkTypeAssignableTo(awaitedType, returnOrPromisedType, node.body);
                    }
                    else {
                        checkTypeAssignableTo(exprType, returnOrPromisedType, node.body);
                    }
                }
            }
            registerForUnusedIdentifiersCheck(node);
        }
    }
    function checkArithmeticOperandType(operand, type, diagnostic) {
        if (!isTypeAssignableToKind(type, 84 /* NumberLike */)) {
            error(operand, diagnostic);
            return false;
        }
        return true;
    }
    function isReadonlySymbol(symbol) {
        // The following symbols are considered read-only:
        // Properties with a 'readonly' modifier
        // Variables declared with 'const'
        // Get accessors without matching set accessors
        // Enum members
        // Unions and intersections of the above (unions and intersections eagerly set isReadonly on creation)
        return !!(ts.getCheckFlags(symbol) & 8 /* Readonly */ ||
            symbol.flags & SymbolFlags.Property && ts.getDeclarationModifierFlagsFromSymbol(symbol) & 64 /* Readonly */ ||
            symbol.flags & 3 /* Variable */ && getDeclarationNodeFlagsFromSymbol(symbol) & 2 /* Const */ ||
            symbol.flags & 98304 /* Accessor */ && !(symbol.flags & 65536 /* SetAccessor */) ||
            symbol.flags & 8 /* EnumMember */);
    }
    function isReferenceToReadonlyEntity(expr, symbol) {
        if (isReadonlySymbol(symbol)) {
            // Allow assignments to readonly properties within constructors of the same class declaration.
            if (symbol.flags & SymbolFlags.Property &&
                (expr.kind === 179 /* PropertyAccessExpression */ || expr.kind === 180 /* ElementAccessExpression */) &&
                expr.expression.kind === 99 /* ThisKeyword */) {
                // Look for if this is the constructor for the class that `symbol` is a property of.
                let func = ts.getContainingFunction(expr);
                if (!(func && func.kind === 152 /* Constructor */)) {
                    return true;
                }
                // If func.parent is a class and symbol is a (readonly) property of that class, or
                // if func is a constructor and symbol is a (readonly) parameter property declared in it,
                // then symbol is writeable here.
                return !(func.parent === symbol.valueDeclaration.parent || func === symbol.valueDeclaration.parent);
            }
            return true;
        }
        return false;
    }
    function isReferenceThroughNamespaceImport(expr) {
        if (expr.kind === 179 /* PropertyAccessExpression */ || expr.kind === 180 /* ElementAccessExpression */) {
            let node = ts.skipParentheses(expr.expression);
            if (node.kind === 71 /* Identifier */) {
                let symbol = getNodeLinks(node).resolvedSymbol;
                if (symbol.flags & SymbolFlags.Alias) {
                    let declaration = getDeclarationOfAliasSymbol(symbol);
                    return declaration && declaration.kind === 240 /* NamespaceImport */;
                }
            }
        }
        return false;
    }
    function checkReferenceExpression(expr, invalidReferenceMessage) {
        // References are combinations of identifiers, parentheses, and property accesses.
        let node = ts.skipOuterExpressions(expr, 2 /* Assertions */ | 1 /* Parentheses */);
        if (node.kind !== 71 /* Identifier */ && node.kind !== 179 /* PropertyAccessExpression */ && node.kind !== 180 /* ElementAccessExpression */) {
            error(expr, invalidReferenceMessage);
            return false;
        }
        return true;
    }
    function checkDeleteExpression(node) {
        checkExpression(node.expression);
        let expr = ts.skipParentheses(node.expression);
        if (expr.kind !== 179 /* PropertyAccessExpression */ && expr.kind !== 180 /* ElementAccessExpression */) {
            error(expr, ts.Diagnostics.The_operand_of_a_delete_operator_must_be_a_property_reference);
            return booleanType;
        }
        let links = getNodeLinks(expr);
        let symbol = getExportSymbolOfValueSymbolIfExported(links.resolvedSymbol);
        if (symbol && isReadonlySymbol(symbol)) {
            error(expr, ts.Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_read_only_property);
        }
        return booleanType;
    }
    function checkTypeOfExpression(node) {
        checkExpression(node.expression);
        return typeofType;
    }
    function checkVoidExpression(node) {
        checkExpression(node.expression);
        return undefinedWideningType;
    }
    function checkAwaitExpression(node) {
        // Grammar checking
        if (produceDiagnostics) {
            if (!(node.flags & 16384 /* AwaitContext */)) {
                grammarErrorOnFirstToken(node, ts.Diagnostics.await_expression_is_only_allowed_within_an_async_function);
            }
            if (isInParameterInitializerBeforeContainingFunction(node)) {
                error(node, ts.Diagnostics.await_expressions_cannot_be_used_in_a_parameter_initializer);
            }
        }
        let operandType = checkExpression(node.expression);
        return checkAwaitedType(operandType, node, ts.Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
    }
    function checkPrefixUnaryExpression(node) {
        let operandType = checkExpression(node.operand);
        if (operandType === silentNeverType) {
            return silentNeverType;
        }
        if (node.operand.kind === 8 /* NumericLiteral */) {
            if (node.operator === 38 /* MinusToken */) {
                return getFreshTypeOfLiteralType(getLiteralType(-node.operand.text));
            }
            else if (node.operator === 37 /* PlusToken */) {
                return getFreshTypeOfLiteralType(getLiteralType(+node.operand.text));
            }
        }
        switch (node.operator) {
            case 37 /* PlusToken */:
            case 38 /* MinusToken */:
            case 52 /* TildeToken */:
                checkNonNullType(operandType, node.operand);
                if (maybeTypeOfKind(operandType, 512 /* ESSymbol */)) {
                    error(node.operand, ts.Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, ts.tokenToString(node.operator));
                }
                return numberType;
            case 51 /* ExclamationToken */:
                let facts = getTypeFacts(operandType) & (1048576 /* Truthy */ | 2097152 /* Falsy */);
                return facts === 1048576 /* Truthy */ ? falseType :
                    facts === 2097152 /* Falsy */ ? trueType :
                        booleanType;
            case 43 /* PlusPlusToken */:
            case 44 /* MinusMinusToken */:
                let ok = checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), ts.Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type);
                if (ok) {
                    // run check only if former checks succeeded to avoid reporting cascading errors
                    checkReferenceExpression(node.operand, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access);
                }
                return numberType;
        }
        return unknownType;
    }
    function checkPostfixUnaryExpression(node) {
        let operandType = checkExpression(node.operand);
        if (operandType === silentNeverType) {
            return silentNeverType;
        }
        let ok = checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), ts.Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type);
        if (ok) {
            // run check only if former checks succeeded to avoid reporting cascading errors
            checkReferenceExpression(node.operand, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access);
        }
        return numberType;
    }
    // Return true if type might be of the given kind. A union or intersection type might be of a given
    // kind if at least one constituent type is of the given kind.
    function maybeTypeOfKind(type, kind) {
        if (type.flags & kind) {
            return true;
        }
        if (type.flags & 196608 /* UnionOrIntersection */) {
            let types = type.types;
            for (let _i = 0, types_18 = types; _i < types_18.length; _i++) {
                let t = types_18[_i];
                if (maybeTypeOfKind(t, kind)) {
                    return true;
                }
            }
        }
        return false;
    }
    function isTypeAssignableToKind(source, kind, strict) {
        if (source.flags & kind) {
            return true;
        }
        if (strict && source.flags & (1 /* Any */ | 1024 /* Void */ | 2048 /* Undefined */ | 4096 /* Null */)) {
            return false;
        }
        return (kind & 84 /* NumberLike */ && isTypeAssignableTo(source, numberType)) ||
            (kind & 262178 /* StringLike */ && isTypeAssignableTo(source, stringType)) ||
            (kind & 136 /* BooleanLike */ && isTypeAssignableTo(source, booleanType)) ||
            (kind & 1024 /* Void */ && isTypeAssignableTo(source, voidType)) ||
            (kind & 8192 /* Never */ && isTypeAssignableTo(source, neverType)) ||
            (kind & 4096 /* Null */ && isTypeAssignableTo(source, nullType)) ||
            (kind & 2048 /* Undefined */ && isTypeAssignableTo(source, undefinedType)) ||
            (kind & 512 /* ESSymbol */ && isTypeAssignableTo(source, esSymbolType)) ||
            (kind & 16777216 /* NonPrimitive */ && isTypeAssignableTo(source, nonPrimitiveType));
    }
    function isConstEnumObjectType(type) {
        return getObjectFlags(type) & 16 /* Anonymous */ && type.symbol && isConstEnumSymbol(type.symbol);
    }
    function isConstEnumSymbol(symbol) {
        return (symbol.flags & 128 /* ConstEnum */) !== 0;
    }
    function checkInstanceOfExpression(left, right, leftType, rightType) {
        if (leftType === silentNeverType || rightType === silentNeverType) {
            return silentNeverType;
        }
        // TypeScript 1.0 spec (April 2014): 4.15.4
        // The instanceof operator requires the left operand to be of type Any, an object type, or a type parameter type,
        // and the right operand to be of type Any, a subtype of the 'Function' interface type, or have a call or construct signature.
        // The result is always of the Boolean primitive type.
        // NOTE: do not raise error if leftType is unknown as related error was already reported
        if (!isTypeAny(leftType) && isTypeAssignableToKind(leftType, 8190 /* Primitive */)) {
            error(left, ts.Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
        }
        // NOTE: do not raise error if right is unknown as related error was already reported
        if (!(isTypeAny(rightType) ||
            getSignaturesOfType(rightType, 0 /* Call */).length ||
            getSignaturesOfType(rightType, 1 /* Construct */).length ||
            isTypeSubtypeOf(rightType, globalFunctionType))) {
            error(right, ts.Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type);
        }
        return booleanType;
    }
    function checkInExpression(left, right, leftType, rightType) {
        if (leftType === silentNeverType || rightType === silentNeverType) {
            return silentNeverType;
        }
        leftType = checkNonNullType(leftType, left);
        rightType = checkNonNullType(rightType, right);
        // TypeScript 1.0 spec (April 2014): 4.15.5
        // The in operator requires the left operand to be of type Any, the String primitive type, or the Number primitive type,
        // and the right operand to be of type Any, an object type, or a type parameter type.
        // The result is always of the Boolean primitive type.
        if (!(isTypeComparableTo(leftType, stringType) || isTypeAssignableToKind(leftType, 84 /* NumberLike */ | 512 /* ESSymbol */))) {
            error(left, ts.Diagnostics.The_left_hand_side_of_an_in_expression_must_be_of_type_any_string_number_or_symbol);
        }
        if (!isTypeAssignableToKind(rightType, 16777216 /* NonPrimitive */ | 540672 /* TypeVariable */)) {
            error(right, ts.Diagnostics.The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
        }
        return booleanType;
    }
    function checkObjectLiteralAssignment(node, sourceType) {
        let properties = node.properties;
        for (let _i = 0, properties_7 = properties; _i < properties_7.length; _i++) {
            let p = properties_7[_i];
            checkObjectLiteralDestructuringPropertyAssignment(sourceType, p, properties);
        }
        return sourceType;
    }
    /** Note: If property cannot be a SpreadAssignment, then allProperties does not need to be provided */
    function checkObjectLiteralDestructuringPropertyAssignment(objectLiteralType, property, allProperties) {
        if (property.kind === 264 /* PropertyAssignment */ || property.kind === 265 /* ShorthandPropertyAssignment */) {
            let name = property.name;
            if (name.kind === 144 /* ComputedPropertyName */) {
                checkComputedPropertyName(name);
            }
            if (isComputedNonLiteralName(name)) {
                return undefined;
            }
            let text = ts.getTextOfPropertyName(name);
            let type = isTypeAny(objectLiteralType)
                ? objectLiteralType
                : getTypeOfPropertyOfType(objectLiteralType, text) ||
                isNumericLiteralName(text) && getIndexTypeOfType(objectLiteralType, 1 /* Number */) ||
                getIndexTypeOfType(objectLiteralType, 0 /* String */);
            if (type) {
                if (property.kind === 265 /* ShorthandPropertyAssignment */) {
                    return checkDestructuringAssignment(property, type);
                }
                else {
                    // non-shorthand property assignments should always have initializers
                    return checkDestructuringAssignment(property.initializer, type);
                }
            }
            else {
                error(name, ts.Diagnostics.Type_0_has_no_property_1_and_no_string_index_signature, typeToString(objectLiteralType), ts.declarationNameToString(name));
            }
        }
        else if (property.kind === 266 /* SpreadAssignment */) {
            if (languageVersion < 5 /* ESNext */) {
                checkExternalEmitHelpers(property, 4 /* Rest */);
            }
            let nonRestNames = [];
            if (allProperties) {
                for (let i = 0; i < allProperties.length - 1; i++) {
                    nonRestNames.push(allProperties[i].name);
                }
            }
            let type = getRestType(objectLiteralType, nonRestNames, objectLiteralType.symbol);
            return checkDestructuringAssignment(property.expression, type);
        }
        else {
            error(property, ts.Diagnostics.Property_assignment_expected);
        }
    }
    function checkArrayLiteralAssignment(node, sourceType, checkMode) {
        if (languageVersion < 2 /* ES2015 */ && compilerOptions.downlevelIteration) {
            checkExternalEmitHelpers(node, 512 /* Read */);
        }
        // This elementType will be used if the specific property corresponding to this index is not
        // present (aka the tuple element property). This call also checks that the parentType is in
        // fact an iterable or array (depending on target language).
        let elementType = checkIteratedTypeOrElementType(sourceType, node, /*allowStringInput*/ false, /*allowAsyncIterables*/ false) || unknownType;
        let elements = node.elements;
        for (let i = 0; i < elements.length; i++) {
            checkArrayLiteralDestructuringElementAssignment(node, sourceType, i, elementType, checkMode);
        }
        return sourceType;
    }
    function checkArrayLiteralDestructuringElementAssignment(node, sourceType, elementIndex, elementType, checkMode) {
        let elements = node.elements;
        let element = elements[elementIndex];
        if (element.kind !== 200 /* OmittedExpression */) {
            if (element.kind !== 198 /* SpreadElement */) {
                let propName = "" + elementIndex;
                let type = isTypeAny(sourceType)
                    ? sourceType
                    : isTupleLikeType(sourceType)
                        ? getTypeOfPropertyOfType(sourceType, propName)
                        : elementType;
                if (type) {
                    return checkDestructuringAssignment(element, type, checkMode);
                }
                else {
                    // We still need to check element expression here because we may need to set appropriate flag on the expression
                    // such as NodeCheckFlags.LexicalThis on "this"expression.
                    checkExpression(element);
                    if (isTupleType(sourceType)) {
                        error(element, ts.Diagnostics.Tuple_type_0_with_length_1_cannot_be_assigned_to_tuple_with_length_2, typeToString(sourceType), getTypeReferenceArity(sourceType), elements.length);
                    }
                    else {
                        error(element, ts.Diagnostics.Type_0_has_no_property_1, typeToString(sourceType), propName);
                    }
                }
            }
            else {
                if (elementIndex < elements.length - 1) {
                    error(element, ts.Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern);
                }
                else {
                    let restExpression = element.expression;
                    if (restExpression.kind === 194 /* BinaryExpression */ && restExpression.operatorToken.kind === 58 /* EqualsToken */) {
                        error(restExpression.operatorToken, ts.Diagnostics.A_rest_element_cannot_have_an_initializer);
                    }
                    else {
                        return checkDestructuringAssignment(restExpression, createArrayType(elementType), checkMode);
                    }
                }
            }
        }
        return undefined;
    }
    function checkDestructuringAssignment(exprOrAssignment, sourceType, checkMode) {
        let target;
        if (exprOrAssignment.kind === 265 /* ShorthandPropertyAssignment */) {
            let prop = exprOrAssignment;
            if (prop.objectAssignmentInitializer) {
                // In strict null checking mode, if a default value of a non-undefined type is specified, remove
                // undefined from the final type.
                if (strictNullChecks &&
                    !(getFalsyFlags(checkExpression(prop.objectAssignmentInitializer)) & 2048 /* Undefined */)) {
                    sourceType = getTypeWithFacts(sourceType, 131072 /* NEUndefined */);
                }
                checkBinaryLikeExpression(prop.name, prop.equalsToken, prop.objectAssignmentInitializer, checkMode);
            }
            target = exprOrAssignment.name;
        }
        else {
            target = exprOrAssignment;
        }
        if (target.kind === 194 /* BinaryExpression */ && target.operatorToken.kind === 58 /* EqualsToken */) {
            checkBinaryExpression(target, checkMode);
            target = target.left;
        }
        if (target.kind === 178 /* ObjectLiteralExpression */) {
            return checkObjectLiteralAssignment(target, sourceType);
        }
        if (target.kind === 177 /* ArrayLiteralExpression */) {
            return checkArrayLiteralAssignment(target, sourceType, checkMode);
        }
        return checkReferenceAssignment(target, sourceType, checkMode);
    }
    function checkReferenceAssignment(target, sourceType, checkMode) {
        let targetType = checkExpression(target, checkMode);
        let error = target.parent.kind === 266 /* SpreadAssignment */ ?
            ts.Diagnostics.The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access :
            ts.Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access;
        if (checkReferenceExpression(target, error)) {
            checkTypeAssignableTo(sourceType, targetType, target, /*headMessage*/ undefined);
        }
        return sourceType;
    }
    /**
     * This is a *shallow* check: An expression is side-effect-free if the
     * evaluation of the expression *itself* cannot produce side effects.
     * For example, x++ / 3 is side-effect free because the / operator
     * does not have side effects.
     * The intent is to "smell test" an expression for correctness in positions where
     * its value is discarded (e.g. the left side of the comma operator).
     */
    function isSideEffectFree(node) {
        node = ts.skipParentheses(node);
        switch (node.kind) {
            case 71 /* Identifier */:
            case 9 /* StringLiteral */:
            case 12 /* RegularExpressionLiteral */:
            case 183 /* TaggedTemplateExpression */:
            case 196 /* TemplateExpression */:
            case 13 /* NoSubstitutionTemplateLiteral */:
            case 8 /* NumericLiteral */:
            case 101 /* TrueKeyword */:
            case 86 /* FalseKeyword */:
            case 95 /* NullKeyword */:
            case 139 /* UndefinedKeyword */:
            case 186 /* FunctionExpression */:
            case SyntaxKind.ClassExpression:
            case 187 /* ArrowFunction */:
            case 177 /* ArrayLiteralExpression */:
            case 178 /* ObjectLiteralExpression */:
            case 189 /* TypeOfExpression */:
            case 203 /* NonNullExpression */:
            case 250 /* JsxSelfClosingElement */:
            case 249 /* JsxElement */:
                return true;
            case 195 /* ConditionalExpression */:
                return isSideEffectFree(node.whenTrue) &&
                    isSideEffectFree(node.whenFalse);
            case 194 /* BinaryExpression */:
                if (ts.isAssignmentOperator(node.operatorToken.kind)) {
                    return false;
                }
                return isSideEffectFree(node.left) &&
                    isSideEffectFree(node.right);
            case 192 /* PrefixUnaryExpression */:
            case 193 /* PostfixUnaryExpression */:
                // Unary operators ~, !, +, and - have no side effects.
                // The rest do.
                switch (node.operator) {
                    case 51 /* ExclamationToken */:
                    case 37 /* PlusToken */:
                    case 38 /* MinusToken */:
                    case 52 /* TildeToken */:
                        return true;
                }
                return false;
            // Some forms listed here for clarity
            case 190 /* VoidExpression */: // Explicit opt-out
            case 184 /* TypeAssertionExpression */: // Not SEF, but can produce useful type warnings
            case 202 /* AsExpression */: // Not SEF, but can produce useful type warnings
            default:
                return false;
        }
    }
    function isTypeEqualityComparableTo(source, target) {
        return (target.flags & 6144 /* Nullable */) !== 0 || isTypeComparableTo(source, target);
    }
    function getBestChoiceType(type1, type2) {
        let firstAssignableToSecond = isTypeAssignableTo(type1, type2);
        let secondAssignableToFirst = isTypeAssignableTo(type2, type1);
        return secondAssignableToFirst && !firstAssignableToSecond ? type1 :
            firstAssignableToSecond && !secondAssignableToFirst ? type2 :
                getUnionType([type1, type2], /*subtypeReduction*/ true);
    }
    function checkBinaryExpression(node, checkMode) {
        return checkBinaryLikeExpression(node.left, node.operatorToken, node.right, checkMode, node);
    }
    function checkBinaryLikeExpression(left, operatorToken, right, checkMode, errorNode) {
        let operator = operatorToken.kind;
        if (operator === 58 /* EqualsToken */ && (left.kind === 178 /* ObjectLiteralExpression */ || left.kind === 177 /* ArrayLiteralExpression */)) {
            return checkDestructuringAssignment(left, checkExpression(right, checkMode), checkMode);
        }
        let leftType = checkExpression(left, checkMode);
        let rightType = checkExpression(right, checkMode);
        switch (operator) {
            case 39 /* AsteriskToken */:
            case 40 /* AsteriskAsteriskToken */:
            case 61 /* AsteriskEqualsToken */:
            case 62 /* AsteriskAsteriskEqualsToken */:
            case 41 /* SlashToken */:
            case 63 /* SlashEqualsToken */:
            case 42 /* PercentToken */:
            case 64 /* PercentEqualsToken */:
            case 38 /* MinusToken */:
            case 60 /* MinusEqualsToken */:
            case 45 /* LessThanLessThanToken */:
            case 65 /* LessThanLessThanEqualsToken */:
            case 46 /* GreaterThanGreaterThanToken */:
            case 66 /* GreaterThanGreaterThanEqualsToken */:
            case 47 /* GreaterThanGreaterThanGreaterThanToken */:
            case 67 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
            case 49 /* BarToken */:
            case 69 /* BarEqualsToken */:
            case 50 /* CaretToken */:
            case 70 /* CaretEqualsToken */:
            case 48 /* AmpersandToken */:
            case 68 /* AmpersandEqualsToken */:
                if (leftType === silentNeverType || rightType === silentNeverType) {
                    return silentNeverType;
                }
                leftType = checkNonNullType(leftType, left);
                rightType = checkNonNullType(rightType, right);
                let suggestedOperator = void 0;
                // if a user tries to apply a bitwise operator to 2 boolean operands
                // try and return them a helpful suggestion
                if ((leftType.flags & 136 /* BooleanLike */) &&
                    (rightType.flags & 136 /* BooleanLike */) &&
                    (suggestedOperator = getSuggestedBooleanOperator(operatorToken.kind)) !== undefined) {
                    error(errorNode || operatorToken, ts.Diagnostics.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead, ts.tokenToString(operatorToken.kind), ts.tokenToString(suggestedOperator));
                }
                else {
                    // otherwise just check each operand separately and report errors as normal
                    let leftOk = checkArithmeticOperandType(left, leftType, ts.Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type);
                    let rightOk = checkArithmeticOperandType(right, rightType, ts.Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type);
                    if (leftOk && rightOk) {
                        checkAssignmentOperator(numberType);
                    }
                }
                return numberType;
            case 37 /* PlusToken */:
            case 59 /* PlusEqualsToken */:
                if (leftType === silentNeverType || rightType === silentNeverType) {
                    return silentNeverType;
                }
                if (!isTypeAssignableToKind(leftType, 262178 /* StringLike */) && !isTypeAssignableToKind(rightType, 262178 /* StringLike */)) {
                    leftType = checkNonNullType(leftType, left);
                    rightType = checkNonNullType(rightType, right);
                }
                let resultType = void 0;
                if (isTypeAssignableToKind(leftType, 84 /* NumberLike */, /*strict*/ true) && isTypeAssignableToKind(rightType, 84 /* NumberLike */, /*strict*/ true)) {
                    // Operands of an enum type are treated as having the primitive type Number.
                    // If both operands are of the Number primitive type, the result is of the Number primitive type.
                    resultType = numberType;
                }
                else if (isTypeAssignableToKind(leftType, 262178 /* StringLike */, /*strict*/ true) || isTypeAssignableToKind(rightType, 262178 /* StringLike */, /*strict*/ true)) {
                    // If one or both operands are of the String primitive type, the result is of the String primitive type.
                    resultType = stringType;
                }
                else if (isTypeAny(leftType) || isTypeAny(rightType)) {
                    // Otherwise, the result is of type Any.
                    // NOTE: unknown type here denotes error type. Old compiler treated this case as any type so do we.
                    resultType = leftType === unknownType || rightType === unknownType ? unknownType : anyType;
                }
                // Symbols are not allowed at all in arithmetic expressions
                if (resultType && !checkForDisallowedESSymbolOperand(operator)) {
                    return resultType;
                }
                if (!resultType) {
                    reportOperatorError();
                    return anyType;
                }
                if (operator === 59 /* PlusEqualsToken */) {
                    checkAssignmentOperator(resultType);
                }
                return resultType;
            case 27 /* LessThanToken */:
            case 29 /* GreaterThanToken */:
            case 30 /* LessThanEqualsToken */:
            case 31 /* GreaterThanEqualsToken */:
                if (checkForDisallowedESSymbolOperand(operator)) {
                    leftType = getBaseTypeOfLiteralType(checkNonNullType(leftType, left));
                    rightType = getBaseTypeOfLiteralType(checkNonNullType(rightType, right));
                    if (!isTypeComparableTo(leftType, rightType) && !isTypeComparableTo(rightType, leftType)) {
                        reportOperatorError();
                    }
                }
                return booleanType;
            case 32 /* EqualsEqualsToken */:
            case 33 /* ExclamationEqualsToken */:
            case 34 /* EqualsEqualsEqualsToken */:
            case 35 /* ExclamationEqualsEqualsToken */:
                let leftIsLiteral = isLiteralType(leftType);
                let rightIsLiteral = isLiteralType(rightType);
                if (!leftIsLiteral || !rightIsLiteral) {
                    leftType = leftIsLiteral ? getBaseTypeOfLiteralType(leftType) : leftType;
                    rightType = rightIsLiteral ? getBaseTypeOfLiteralType(rightType) : rightType;
                }
                if (!isTypeEqualityComparableTo(leftType, rightType) && !isTypeEqualityComparableTo(rightType, leftType)) {
                    reportOperatorError();
                }
                return booleanType;
            case 93 /* InstanceOfKeyword */:
                return checkInstanceOfExpression(left, right, leftType, rightType);
            case 92 /* InKeyword */:
                return checkInExpression(left, right, leftType, rightType);
            case 53 /* AmpersandAmpersandToken */:
                return getTypeFacts(leftType) & 1048576 /* Truthy */ ?
                    getUnionType([extractDefinitelyFalsyTypes(strictNullChecks ? leftType : getBaseTypeOfLiteralType(rightType)), rightType]) :
                    leftType;
            case 54 /* BarBarToken */:
                return getTypeFacts(leftType) & 2097152 /* Falsy */ ?
                    getBestChoiceType(removeDefinitelyFalsyTypes(leftType), rightType) :
                    leftType;
            case 58 /* EqualsToken */:
                checkAssignmentOperator(rightType);
                return getRegularTypeOfObjectLiteral(rightType);
            case 26 /* CommaToken */:
                if (!compilerOptions.allowUnreachableCode && isSideEffectFree(left) && !isEvalNode(right)) {
                    error(left, ts.Diagnostics.Left_side_of_comma_operator_is_unused_and_has_no_side_effects);
                }
                return rightType;
        }
        function isEvalNode(node) {
            return node.kind === 71 /* Identifier */ && node.escapedText === "eval";
        }
        // Return true if there was no error, false if there was an error.
        function checkForDisallowedESSymbolOperand(operator) {
            let offendingSymbolOperand = maybeTypeOfKind(leftType, 512 /* ESSymbol */) ? left :
                maybeTypeOfKind(rightType, 512 /* ESSymbol */) ? right :
                    undefined;
            if (offendingSymbolOperand) {
                error(offendingSymbolOperand, ts.Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, ts.tokenToString(operator));
                return false;
            }
            return true;
        }
        function getSuggestedBooleanOperator(operator) {
            switch (operator) {
                case 49 /* BarToken */:
                case 69 /* BarEqualsToken */:
                    return 54 /* BarBarToken */;
                case 50 /* CaretToken */:
                case 70 /* CaretEqualsToken */:
                    return 35 /* ExclamationEqualsEqualsToken */;
                case 48 /* AmpersandToken */:
                case 68 /* AmpersandEqualsToken */:
                    return 53 /* AmpersandAmpersandToken */;
                default:
                    return undefined;
            }
        }
        function checkAssignmentOperator(valueType) {
            if (produceDiagnostics && ts.isAssignmentOperator(operator)) {
                // TypeScript 1.0 spec (April 2014): 4.17
                // An assignment of the form
                //    VarExpr = ValueExpr
                // requires VarExpr to be classified as a reference
                // A compound assignment furthermore requires VarExpr to be classified as a reference (section 4.1)
                // and the type of the non - compound operation to be assignable to the type of VarExpr.
                if (checkReferenceExpression(left, ts.Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access)) {
                    // to avoid cascading errors check assignability only if 'isReference' check succeeded and no errors were reported
                    checkTypeAssignableTo(valueType, leftType, left, /*headMessage*/ undefined);
                }
            }
        }
        function reportOperatorError() {
            error(errorNode || operatorToken, ts.Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2, ts.tokenToString(operatorToken.kind), typeToString(leftType), typeToString(rightType));
        }
    }
    function isYieldExpressionInClass(node) {
        let current = node;
        let parent = node.parent;
        while (parent) {
            if (ts.isFunctionLike(parent) && current === parent.body) {
                return false;
            }
            else if (ts.isClassLike(current)) {
                return true;
            }
            current = parent;
            parent = parent.parent;
        }
        return false;
    }
    function checkYieldExpression(node) {
        // Grammar checking
        if (produceDiagnostics) {
            if (!(node.flags & 4096 /* YieldContext */) || isYieldExpressionInClass(node)) {
                grammarErrorOnFirstToken(node, ts.Diagnostics.A_yield_expression_is_only_allowed_in_a_generator_body);
            }
            if (isInParameterInitializerBeforeContainingFunction(node)) {
                error(node, ts.Diagnostics.yield_expressions_cannot_be_used_in_a_parameter_initializer);
            }
        }
        if (node.expression) {
            let func = ts.getContainingFunction(node);
            // If the user's code is syntactically correct, the func should always have a star. After all,
            // we are in a yield context.
            let functionFlags = func && ts.getFunctionFlags(func);
            if (node.asteriskToken) {
                // Async generator functions prior to ESNext require the __await, __asyncDelegator,
                // and __asyncValues helpers
                if ((functionFlags & 3 /* AsyncGenerator */) === 3 /* AsyncGenerator */ &&
                    languageVersion < 5 /* ESNext */) {
                    checkExternalEmitHelpers(node, 26624 /* AsyncDelegatorIncludes */);
                }
                // Generator functions prior to ES2015 require the __values helper
                if ((functionFlags & 3 /* AsyncGenerator */) === 1 /* Generator */ &&
                    languageVersion < 2 /* ES2015 */ && compilerOptions.downlevelIteration) {
                    checkExternalEmitHelpers(node, 256 /* Values */);
                }
            }
            if (functionFlags & 1 /* Generator */) {
                let expressionType = checkExpressionCached(node.expression);
                let expressionElementType = void 0;
                let nodeIsYieldStar = !!node.asteriskToken;
                if (nodeIsYieldStar) {
                    expressionElementType = checkIteratedTypeOrElementType(expressionType, node.expression, /*allowStringInput*/ false, (functionFlags & 2 /* Async */) !== 0);
                }
                // There is no point in doing an assignability check if the function
                // has no explicit return type because the return type is directly computed
                // from the yield expressions.
                let returnType = ts.getEffectiveReturnTypeNode(func);
                if (returnType) {
                    let signatureElementType = getIteratedTypeOfGenerator(getTypeFromTypeNode(returnType), (functionFlags & 2 /* Async */) !== 0) || anyType;
                    if (nodeIsYieldStar) {
                        checkTypeAssignableTo(functionFlags & 2 /* Async */
                            ? getAwaitedType(expressionElementType, node.expression, ts.Diagnostics.Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
                            : expressionElementType, signatureElementType, node.expression,
                        /*headMessage*/ undefined);
                    }
                    else {
                        checkTypeAssignableTo(functionFlags & 2 /* Async */
                            ? getAwaitedType(expressionType, node.expression, ts.Diagnostics.Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
                            : expressionType, signatureElementType, node.expression,
                        /*headMessage*/ undefined);
                    }
                }
            }
        }
        // Both yield and yield* expressions have type 'any'
        return anyType;
    }
    function checkConditionalExpression(node, checkMode) {
        checkExpression(node.condition);
        let type1 = checkExpression(node.whenTrue, checkMode);
        let type2 = checkExpression(node.whenFalse, checkMode);
        return getBestChoiceType(type1, type2);
    }
    function checkTemplateExpression(node) {
        // We just want to check each expressions, but we are unconcerned with
        // the type of each expression, as any value may be coerced into a string.
        // It is worth asking whether this is what we really want though.
        // A place where we actually *are* concerned with the expressions' types are
        // in tagged templates.
        ts.forEach(node.templateSpans, function (templateSpan) {
            checkExpression(templateSpan.expression);
        });
        return stringType;
    }
    function checkExpressionWithContextualType(node, contextualType, contextualMapper) {
        let saveContextualType = node.contextualType;
        let saveContextualMapper = node.contextualMapper;
        node.contextualType = contextualType;
        node.contextualMapper = contextualMapper;
        let checkMode = contextualMapper === identityMapper ? 1 /* SkipContextSensitive */ :
            contextualMapper ? 2 /* Inferential */ : 0 /* Normal */;
        let result = checkExpression(node, checkMode);
        node.contextualType = saveContextualType;
        node.contextualMapper = saveContextualMapper;
        return result;
    }
    function checkExpressionCached(node, checkMode) {
        let links = getNodeLinks(node);
        if (!links.resolvedType) {
            // When computing a type that we're going to cache, we need to ignore any ongoing control flow
            // analysis because variables may have transient types in indeterminable states. Moving flowLoopStart
            // to the top of the stack ensures all transient types are computed from a known point.
            let saveFlowLoopStart = flowLoopStart;
            flowLoopStart = flowLoopCount;
            links.resolvedType = checkExpression(node, checkMode);
            flowLoopStart = saveFlowLoopStart;
        }
        return links.resolvedType;
    }
    function isTypeAssertion(node) {
        node = ts.skipParentheses(node);
        return node.kind === 184 /* TypeAssertionExpression */ || node.kind === 202 /* AsExpression */;
    }
    function checkDeclarationInitializer(declaration) {
        let type = getTypeOfExpression(declaration.initializer, /*cache*/ true);
        return ts.getCombinedNodeFlags(declaration) & 2 /* Const */ ||
            ts.getCombinedModifierFlags(declaration) & 64 /* Readonly */ && !ts.isParameterPropertyDeclaration(declaration) ||
            isTypeAssertion(declaration.initializer) ? type : getWidenedLiteralType(type);
    }
    function isLiteralContextualType(contextualType) {
        if (contextualType) {
            if (contextualType.flags & 540672 /* TypeVariable */) {
                let constraint = getBaseConstraintOfType(contextualType) || emptyObjectType;
                // If the type parameter is constrained to the base primitive type we're checking for,
                // consider this a literal context. For example, given a type parameter 'T extends string',
                // this causes us to infer string literal types for T.
                if (constraint.flags & (2 /* String */ | 4 /* Number */ | 8 /* Boolean */ | 16 /* Enum */)) {
                    return true;
                }
                contextualType = constraint;
            }
            return maybeTypeOfKind(contextualType, (224 /* Literal */ | 262144 /* Index */));
        }
        return false;
    }
    function checkExpressionForMutableLocation(node, checkMode, contextualType) {
        if (arguments.length === 2) {
            contextualType = getContextualType(node);
        }
        let type = checkExpression(node, checkMode);
        let shouldWiden = isTypeAssertion(node) || isLiteralContextualType(contextualType);
        return shouldWiden ? type : getWidenedLiteralType(type);
    }
    function checkPropertyAssignment(node, checkMode) {
        // Do not use hasDynamicName here, because that returns false for well known symbols.
        // We want to perform checkComputedPropertyName for all computed properties, including
        // well known symbols.
        if (node.name.kind === 144 /* ComputedPropertyName */) {
            checkComputedPropertyName(node.name);
        }
        return checkExpressionForMutableLocation(node.initializer, checkMode);
    }
    function checkObjectLiteralMethod(node, checkMode) {
        // Grammar checking
        checkGrammarMethod(node);
        // Do not use hasDynamicName here, because that returns false for well known symbols.
        // We want to perform checkComputedPropertyName for all computed properties, including
        // well known symbols.
        if (node.name.kind === 144 /* ComputedPropertyName */) {
            checkComputedPropertyName(node.name);
        }
        let uninstantiatedType = checkFunctionExpressionOrObjectLiteralMethod(node, checkMode);
        return instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
    }
    function instantiateTypeWithSingleGenericCallSignature(node, type, checkMode) {
        if (checkMode === 2 /* Inferential */) {
            let signature = getSingleCallSignature(type);
            if (signature && signature.typeParameters) {
                let contextualType = getApparentTypeOfContextualType(node);
                if (contextualType) {
                    let contextualSignature = getSingleCallSignature(getNonNullableType(contextualType));
                    if (contextualSignature && !contextualSignature.typeParameters) {
                        return getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, getContextualMapper(node)));
                    }
                }
            }
        }
        return type;
    }
    /**
     * Returns the type of an expression. Unlike checkExpression, this function is simply concerned
     * with computing the type and may not fully check all contained sub-expressions for errors.
     * A cache argument of true indicates that if the function performs a full type check, it is ok
     * to cache the result.
     */
    function getTypeOfExpression(node, cache) {
        // Optimize for the common case of a call to a function with a single non-generic call
        // signature where we can just fetch the return type without checking the arguments.
        if (node.kind === 181 /* CallExpression */ && node.expression.kind !== 97 /* SuperKeyword */ && !ts.isRequireCall(node, /*checkArgumentIsStringLiteral*/ true)) {
            let funcType = checkNonNullExpression(node.expression);
            let signature = getSingleCallSignature(funcType);
            if (signature && !signature.typeParameters) {
                return getReturnTypeOfSignature(signature);
            }
        }
        // Otherwise simply call checkExpression. Ideally, the entire family of checkXXX functions
        // should have a parameter that indicates whether full error checking is required such that
        // we can perform the optimizations locally.
        return cache ? checkExpressionCached(node) : checkExpression(node);
    }
    /**
     * Returns the type of an expression. Unlike checkExpression, this function is simply concerned
     * with computing the type and may not fully check all contained sub-expressions for errors.
     * It is intended for uses where you know there is no contextual type,
     * and requesting the contextual type might cause a circularity or other bad behaviour.
     * It sets the contextual type of the node to any before calling getTypeOfExpression.
     */
    function getContextFreeTypeOfExpression(node) {
        let saveContextualType = node.contextualType;
        node.contextualType = anyType;
        let type = getTypeOfExpression(node);
        node.contextualType = saveContextualType;
        return type;
    }
    // Checks an expression and returns its type. The contextualMapper parameter serves two purposes: When
    // contextualMapper is not undefined and not equal to the identityMapper function object it indicates that the
    // expression is being inferentially typed (section 4.15.2 in spec) and provides the type mapper to use in
    // conjunction with the generic contextual type. When contextualMapper is equal to the identityMapper function
    // object, it serves as an indicator that all contained function and arrow expressions should be considered to
    // have the wildcard function type; this form of type check is used during overload resolution to exclude
    // contextually typed function and arrow expressions in the initial phase.
    function checkExpression(node, checkMode) {
        let type;
        if (node.kind === 143 /* QualifiedName */) {
            type = checkQualifiedName(node);
        }
        else {
            let uninstantiatedType = checkExpressionWorker(node, checkMode);
            type = instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
        }
        if (isConstEnumObjectType(type)) {
            // enum object type for const enums are only permitted in:
            // - 'left' in property access
            // - 'object' in indexed access
            // - target in rhs of import statement
            let ok = (node.parent.kind === 179 /* PropertyAccessExpression */ && node.parent.expression === node) ||
                (node.parent.kind === 180 /* ElementAccessExpression */ && node.parent.expression === node) ||
                ((node.kind === 71 /* Identifier */ || node.kind === 143 /* QualifiedName */) && isInRightSideOfImportOrExportAssignment(node));
            if (!ok) {
                error(node, ts.Diagnostics.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment);
            }
        }
        return type;
    }
    function checkParenthesizedExpression(node, checkMode) {
        let tag = ts.isInJavaScriptFile(node) ? ts.getJSDocTypeTag(node) : undefined;
        if (tag) {
            return checkAssertionWorker(tag, tag.typeExpression.type, node.expression, checkMode);
        }
        return checkExpression(node.expression, checkMode);
    }
    function checkExpressionWorker(node, checkMode) {
        switch (node.kind) {
            case 71 /* Identifier */:
                return checkIdentifier(node);
            case 99 /* ThisKeyword */:
                return checkThisExpression(node);
            case 97 /* SuperKeyword */:
                return checkSuperExpression(node);
            case 95 /* NullKeyword */:
                return nullWideningType;
            case 13 /* NoSubstitutionTemplateLiteral */:
            case 9 /* StringLiteral */:
                return getFreshTypeOfLiteralType(getLiteralType(node.text));
            case 8 /* NumericLiteral */:
                checkGrammarNumericLiteral(node);
                return getFreshTypeOfLiteralType(getLiteralType(+node.text));
            case 101 /* TrueKeyword */:
                return trueType;
            case 86 /* FalseKeyword */:
                return falseType;
            case 196 /* TemplateExpression */:
                return checkTemplateExpression(node);
            case 12 /* RegularExpressionLiteral */:
                return globalRegExpType;
            case 177 /* ArrayLiteralExpression */:
                return checkArrayLiteral(node, checkMode);
            case 178 /* ObjectLiteralExpression */:
                return checkObjectLiteral(node, checkMode);
            case 179 /* PropertyAccessExpression */:
                return checkPropertyAccessExpression(node);
            case 180 /* ElementAccessExpression */:
                return checkIndexedAccess(node);
            case 181 /* CallExpression */:
                if (node.expression.kind === 91 /* ImportKeyword */) {
                    return checkImportCallExpression(node);
                }
            /* falls through */
            case 182 /* NewExpression */:
                return checkCallExpression(node);
            case 183 /* TaggedTemplateExpression */:
                return checkTaggedTemplateExpression(node);
            case 185 /* ParenthesizedExpression */:
                return checkParenthesizedExpression(node, checkMode);
            case SyntaxKind.ClassExpression:
                return checkClassExpression(node);
            case 186 /* FunctionExpression */:
            case 187 /* ArrowFunction */:
                return checkFunctionExpressionOrObjectLiteralMethod(node, checkMode);
            case 189 /* TypeOfExpression */:
                return checkTypeOfExpression(node);
            case 184 /* TypeAssertionExpression */:
            case 202 /* AsExpression */:
                return checkAssertion(node);
            case 203 /* NonNullExpression */:
                return checkNonNullAssertion(node);
            case 204 /* MetaProperty */:
                return checkMetaProperty(node);
            case 188 /* DeleteExpression */:
                return checkDeleteExpression(node);
            case 190 /* VoidExpression */:
                return checkVoidExpression(node);
            case 191 /* AwaitExpression */:
                return checkAwaitExpression(node);
            case 192 /* PrefixUnaryExpression */:
                return checkPrefixUnaryExpression(node);
            case 193 /* PostfixUnaryExpression */:
                return checkPostfixUnaryExpression(node);
            case 194 /* BinaryExpression */:
                return checkBinaryExpression(node, checkMode);
            case 195 /* ConditionalExpression */:
                return checkConditionalExpression(node, checkMode);
            case 198 /* SpreadElement */:
                return checkSpreadExpression(node, checkMode);
            case 200 /* OmittedExpression */:
                return undefinedWideningType;
            case 197 /* YieldExpression */:
                return checkYieldExpression(node);
            case 259 /* JsxExpression */:
                return checkJsxExpression(node, checkMode);
            case 249 /* JsxElement */:
                return checkJsxElement(node);
            case 250 /* JsxSelfClosingElement */:
                return checkJsxSelfClosingElement(node);
            case 253 /* JsxFragment */:
                return checkJsxFragment(node);
            case 257 /* JsxAttributes */:
                return checkJsxAttributes(node, checkMode);
            case 251 /* JsxOpeningElement */:
                ts.Debug.fail("Shouldn't ever directly check a JsxOpeningElement");
        }
        return unknownType;
    }
    // DECLARATION AND STATEMENT TYPE CHECKING
    function checkTypeParameter(node) {
        // Grammar Checking
        if (node.expression) {
            grammarErrorOnFirstToken(node.expression, ts.Diagnostics.Type_expected);
        }
        checkSourceElement(node.constraint);
        checkSourceElement(node.default);
        let typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfNode(node));
        if (!hasNonCircularBaseConstraint(typeParameter)) {
            error(node.constraint, ts.Diagnostics.Type_parameter_0_has_a_circular_constraint, typeToString(typeParameter));
        }
        if (!hasNonCircularTypeParameterDefault(typeParameter)) {
            error(node.default, ts.Diagnostics.Type_parameter_0_has_a_circular_default, typeToString(typeParameter));
        }
        let constraintType = getConstraintOfTypeParameter(typeParameter);
        let defaultType = getDefaultFromTypeParameter(typeParameter);
        if (constraintType && defaultType) {
            checkTypeAssignableTo(defaultType, getTypeWithThisArgument(constraintType, defaultType), node.default, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
        }
        if (produceDiagnostics) {
            checkTypeNameIsReserved(node.name, ts.Diagnostics.Type_parameter_name_cannot_be_0);
        }
    }
    function checkParameter(node) {
        // Grammar checking
        // It is a SyntaxError if the Identifier "eval" or the Identifier "arguments" occurs as the
        // Identifier in a PropertySetParameterList of a PropertyAssignment that is contained in strict code
        // or if its FunctionBody is strict code(11.1.5).
        // Grammar checking
        checkGrammarDecorators(node) || checkGrammarModifiers(node);
        checkVariableLikeDeclaration(node);
        let func = ts.getContainingFunction(node);
        if (ts.hasModifier(node, 92 /* ParameterPropertyModifier */)) {
            if (!(func.kind === 152 /* Constructor */ && ts.nodeIsPresent(func.body))) {
                error(node, ts.Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation);
            }
        }
        if (node.questionToken && ts.isBindingPattern(node.name) && func.body) {
            error(node, ts.Diagnostics.A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature);
        }
        if (node.name && ts.isIdentifier(node.name) && (node.name.escapedText === "this" || node.name.escapedText === "new")) {
            if (ts.indexOf(func.parameters, node) !== 0) {
                error(node, ts.Diagnostics.A_0_parameter_must_be_the_first_parameter, node.name.escapedText);
            }
            if (func.kind === 152 /* Constructor */ || func.kind === 156 /* ConstructSignature */ || func.kind === 161 /* ConstructorType */) {
                error(node, ts.Diagnostics.A_constructor_cannot_have_a_this_parameter);
            }
        }
        // Only check rest parameter type if it's not a binding pattern. Since binding patterns are
        // not allowed in a rest parameter, we already have an error from checkGrammarParameterList.
        if (node.dotDotDotToken && !ts.isBindingPattern(node.name) && !isArrayType(getTypeOfSymbol(node.symbol))) {
            error(node, ts.Diagnostics.A_rest_parameter_must_be_of_an_array_type);
        }
    }
    function getTypePredicateParameterIndex(parameterList, parameter) {
        if (parameterList) {
            for (let i = 0; i < parameterList.length; i++) {
                let param = parameterList[i];
                if (param.name.kind === 71 /* Identifier */ && param.name.escapedText === parameter.escapedText) {
                    return i;
                }
            }
        }
        return -1;
    }
    function checkTypePredicate(node) {
        let parent = getTypePredicateParent(node);
        if (!parent) {
            // The parent must not be valid.
            error(node, ts.Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods);
            return;
        }
        let typePredicate = getSignatureFromDeclaration(parent).typePredicate;
        if (!typePredicate) {
            return;
        }
        checkSourceElement(node.type);
        let parameterName = node.parameterName;
        if (ts.isThisTypePredicate(typePredicate)) {
            getTypeFromThisTypeNode(parameterName);
        }
        else {
            if (typePredicate.parameterIndex >= 0) {
                if (parent.parameters[typePredicate.parameterIndex].dotDotDotToken) {
                    error(parameterName, ts.Diagnostics.A_type_predicate_cannot_reference_a_rest_parameter);
                }
                else {
                    let leadingError = ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type);
                    checkTypeAssignableTo(typePredicate.type, getTypeOfNode(parent.parameters[typePredicate.parameterIndex]), node.type,
                    /*headMessage*/ undefined, leadingError);
                }
            }
            else if (parameterName) {
                let hasReportedError = false;
                for (let _i = 0, _a = parent.parameters; _i < _a.length; _i++) {
                    let name = _a[_i].name;
                    if (ts.isBindingPattern(name) &&
                        checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, parameterName, typePredicate.parameterName)) {
                        hasReportedError = true;
                        break;
                    }
                }
                if (!hasReportedError) {
                    error(node.parameterName, ts.Diagnostics.Cannot_find_parameter_0, typePredicate.parameterName);
                }
            }
        }
    }
    function getTypePredicateParent(node) {
        switch (node.parent.kind) {
            case 187 /* ArrowFunction */:
            case 155 /* CallSignature */:
            case 228 /* FunctionDeclaration */:
            case 186 /* FunctionExpression */:
            case 160 /* FunctionType */:
            case SyntaxKind.MethodDeclaration:
            case 150 /* MethodSignature */:
                let parent = node.parent;
                if (node === parent.type) {
                    return parent;
                }
        }
    }
    function checkIfTypePredicateVariableIsDeclaredInBindingPattern(pattern, predicateVariableNode, predicateVariableName) {
        for (let _i = 0, _a = pattern.elements; _i < _a.length; _i++) {
            let element = _a[_i];
            if (ts.isOmittedExpression(element)) {
                continue;
            }
            let name = element.name;
            if (name.kind === 71 /* Identifier */ && name.escapedText === predicateVariableName) {
                error(predicateVariableNode, ts.Diagnostics.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern, predicateVariableName);
                return true;
            }
            else if (name.kind === 175 /* ArrayBindingPattern */ || name.kind === 174 /* ObjectBindingPattern */) {
                if (checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, predicateVariableNode, predicateVariableName)) {
                    return true;
                }
            }
        }
    }
    function checkSignatureDeclaration(node) {
        // Grammar checking
        if (node.kind === 157 /* IndexSignature */) {
            checkGrammarIndexSignature(node);
        }
        else if (node.kind === 160 /* FunctionType */ || node.kind === 228 /* FunctionDeclaration */ || node.kind === 161 /* ConstructorType */ ||
            node.kind === 155 /* CallSignature */ || node.kind === 152 /* Constructor */ ||
            node.kind === 156 /* ConstructSignature */) {
            checkGrammarFunctionLikeDeclaration(node);
        }
        let functionFlags = ts.getFunctionFlags(node);
        if (!(functionFlags & 4 /* Invalid */)) {
            // Async generators prior to ESNext require the __await and __asyncGenerator helpers
            if ((functionFlags & 3 /* AsyncGenerator */) === 3 /* AsyncGenerator */ && languageVersion < 5 /* ESNext */) {
                checkExternalEmitHelpers(node, 6144 /* AsyncGeneratorIncludes */);
            }
            // Async functions prior to ES2017 require the __awaiter helper
            if ((functionFlags & 3 /* AsyncGenerator */) === 2 /* Async */ && languageVersion < 4 /* ES2017 */) {
                checkExternalEmitHelpers(node, 64 /* Awaiter */);
            }
            // Generator functions, Async functions, and Async Generator functions prior to
            // ES2015 require the __generator helper
            if ((functionFlags & 3 /* AsyncGenerator */) !== 0 /* Normal */ && languageVersion < 2 /* ES2015 */) {
                checkExternalEmitHelpers(node, 128 /* Generator */);
            }
        }
        checkTypeParameters(node.typeParameters);
        ts.forEach(node.parameters, checkParameter);
        // TODO(rbuckton): Should we start checking JSDoc types?
        if (node.type) {
            checkSourceElement(node.type);
        }
        if (produceDiagnostics) {
            checkCollisionWithArgumentsInGeneratedCode(node);
            let returnTypeNode = ts.getEffectiveReturnTypeNode(node);
            if (noImplicitAny && !returnTypeNode) {
                switch (node.kind) {
                    case 156 /* ConstructSignature */:
                        error(node, ts.Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                        break;
                    case 155 /* CallSignature */:
                        error(node, ts.Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                        break;
                }
            }
            if (returnTypeNode) {
                let functionFlags_1 = ts.getFunctionFlags(node);
                if ((functionFlags_1 & (4 /* Invalid */ | 1 /* Generator */)) === 1 /* Generator */) {
                    let returnType = getTypeFromTypeNode(returnTypeNode);
                    if (returnType === voidType) {
                        error(returnTypeNode, ts.Diagnostics.A_generator_cannot_have_a_void_type_annotation);
                    }
                    else {
                        let generatorElementType = getIteratedTypeOfGenerator(returnType, (functionFlags_1 & 2 /* Async */) !== 0) || anyType;
                        let iterableIteratorInstantiation = functionFlags_1 & 2 /* Async */
                            ? createAsyncIterableIteratorType(generatorElementType) // AsyncGenerator function
                            : createIterableIteratorType(generatorElementType); // Generator function
                        // Naively, one could check that IterableIterator<any> is assignable to the return type annotation.
                        // However, that would not catch the error in the following case.
                        //
                        //    interface BadGenerator extends Iterable<number>, Iterator<string> { }
                        //    function* g(): BadGenerator { } // Iterable and Iterator have different types!
                        //
                        checkTypeAssignableTo(iterableIteratorInstantiation, returnType, returnTypeNode);
                    }
                }
                else if ((functionFlags_1 & 3 /* AsyncGenerator */) === 2 /* Async */) {
                    checkAsyncFunctionReturnType(node);
                }
            }
            if (noUnusedIdentifiers && !node.body) {
                checkUnusedTypeParameters(node);
            }
        }
    }
    function checkClassForDuplicateDeclarations(node) {
        let Declaration;
        (function (Declaration) {
            Declaration[Declaration["Getter"] = 1] = "Getter";
            Declaration[Declaration["Setter"] = 2] = "Setter";
            Declaration[Declaration["Method"] = 4] = "Method";
            Declaration[Declaration["Property"] = 3] = "Property";
        })(Declaration || (Declaration = {}));
        let instanceNames = ts.createUnderscoreEscapedMap();
        let staticNames = ts.createUnderscoreEscapedMap();
        for (let _i = 0, _a = node.members; _i < _a.length; _i++) {
            let member = _a[_i];
            if (member.kind === 152 /* Constructor */) {
                for (let _b = 0, _c = member.parameters; _b < _c.length; _b++) {
                    let param = _c[_b];
                    if (ts.isParameterPropertyDeclaration(param) && !ts.isBindingPattern(param.name)) {
                        addName(instanceNames, param.name, param.name.escapedText, 3 /* Property */);
                    }
                }
            }
            else {
                let isStatic = ts.hasModifier(member, ModifierFlags.Static);
                let names = isStatic ? staticNames : instanceNames;
                let memberName = member.name && ts.getPropertyNameForPropertyNameNode(member.name);
                if (memberName) {
                    switch (member.kind) {
                        case 153 /* GetAccessor */:
                            addName(names, member.name, memberName, 1 /* Getter */);
                            break;
                        case 154 /* SetAccessor */:
                            addName(names, member.name, memberName, 2 /* Setter */);
                            break;
                        case SyntaxKind.PropertyDeclaration:
                            addName(names, member.name, memberName, 3 /* Property */);
                            break;
                        case SyntaxKind.MethodDeclaration:
                            addName(names, member.name, memberName, 4 /* Method */);
                            break;
                    }
                }
            }
        }
        function addName(names, location, name, meaning) {
            let prev = names.get(name);
            if (prev) {
                if (prev & 4 /* Method */) {
                    if (meaning !== 4 /* Method */) {
                        error(location, ts.Diagnostics.Duplicate_identifier_0, ts.getTextOfNode(location));
                    }
                }
                else if (prev & meaning) {
                    error(location, ts.Diagnostics.Duplicate_identifier_0, ts.getTextOfNode(location));
                }
                else {
                    names.set(name, prev | meaning);
                }
            }
            else {
                names.set(name, meaning);
            }
        }
    }
    /**
     * Static members being set on a constructor function may conflict with built-in properties
     * of Function. Esp. in ECMAScript 5 there are non-configurable and non-writable
     * built-in properties. This check issues a transpile error when a class has a static
     * member with the same name as a non-writable built-in property.
     *
     * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.3
     * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.5
     * @see http://www.ecma-international.org/ecma-262/6.0/#sec-properties-of-the-function-constructor
     * @see http://www.ecma-international.org/ecma-262/6.0/#sec-function-instances
     */
    function checkClassForStaticPropertyNameConflicts(node) {
        for (let _i = 0, _a = node.members; _i < _a.length; _i++) {
            let member = _a[_i];
            let memberNameNode = member.name;
            let isStatic = ts.hasModifier(member, ModifierFlags.Static);
            if (isStatic && memberNameNode) {
                let memberName = ts.getPropertyNameForPropertyNameNode(memberNameNode);
                switch (memberName) {
                    case "name":
                    case "length":
                    case "caller":
                    case "arguments":
                    case "prototype":
                        let message = ts.Diagnostics.Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1;
                        let className = getNameOfSymbol(getSymbolOfNode(node));
                        error(memberNameNode, message, memberName, className);
                        break;
                }
            }
        }
    }
    function checkObjectTypeForDuplicateDeclarations(node) {
        let names = ts.createMap();
        for (let _i = 0, _a = node.members; _i < _a.length; _i++) {
            let member = _a[_i];
            if (member.kind === SyntaxKind.PropertySignature) {
                let memberName = void 0;
                switch (member.name.kind) {
                    case 9 /* StringLiteral */:
                    case 8 /* NumericLiteral */:
                        memberName = member.name.text;
                        break;
                    case 71 /* Identifier */:
                        memberName = ts.idText(member.name);
                        break;
                    default:
                        continue;
                }
                if (names.get(memberName)) {
                    error(ts.getNameOfDeclaration(member.symbol.valueDeclaration), ts.Diagnostics.Duplicate_identifier_0, memberName);
                    error(member.name, ts.Diagnostics.Duplicate_identifier_0, memberName);
                }
                else {
                    names.set(memberName, true);
                }
            }
        }
    }
    function checkTypeForDuplicateIndexSignatures(node) {
        if (node.kind === SyntaxKind.InterfaceDeclaration) {
            let nodeSymbol = getSymbolOfNode(node);
            // in case of merging interface declaration it is possible that we'll enter this check procedure several times for every declaration
            // to prevent this run check only for the first declaration of a given kind
            if (nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] !== node) {
                return;
            }
        }
        // TypeScript 1.0 spec (April 2014)
        // 3.7.4: An object type can contain at most one string index signature and one numeric index signature.
        // 8.5: A class declaration can have at most one string index member declaration and one numeric index member declaration
        let indexSymbol = getIndexSymbol(getSymbolOfNode(node));
        if (indexSymbol) {
            let seenNumericIndexer = false;
            let seenStringIndexer = false;
            for (let _i = 0, _a = indexSymbol.declarations; _i < _a.length; _i++) {
                let decl = _a[_i];
                let declaration = decl;
                if (declaration.parameters.length === 1 && declaration.parameters[0].type) {
                    switch (declaration.parameters[0].type.kind) {
                        case 136 /* StringKeyword */:
                            if (!seenStringIndexer) {
                                seenStringIndexer = true;
                            }
                            else {
                                error(declaration, ts.Diagnostics.Duplicate_string_index_signature);
                            }
                            break;
                        case 133 /* NumberKeyword */:
                            if (!seenNumericIndexer) {
                                seenNumericIndexer = true;
                            }
                            else {
                                error(declaration, ts.Diagnostics.Duplicate_number_index_signature);
                            }
                            break;
                    }
                }
            }
        }
    }
    function checkPropertyDeclaration(node) {
        // Grammar checking
        checkGrammarDecorators(node) || checkGrammarModifiers(node) || checkGrammarProperty(node) || checkGrammarComputedPropertyName(node.name);
        checkVariableLikeDeclaration(node);
    }
    function checkMethodDeclaration(node) {
        // Grammar checking
        checkGrammarMethod(node) || checkGrammarComputedPropertyName(node.name);
        // Grammar checking for modifiers is done inside the function checkGrammarFunctionLikeDeclaration
        checkFunctionOrMethodDeclaration(node);
        // Abstract methods cannot have an implementation.
        // Extra checks are to avoid reporting multiple errors relating to the "abstractness" of the node.
        if (ts.hasModifier(node, 128 /* Abstract */) && node.body) {
            error(node, ts.Diagnostics.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract, ts.declarationNameToString(node.name));
        }
    }
    function checkConstructorDeclaration(node) {
        // Grammar check on signature of constructor and modifier of the constructor is done in checkSignatureDeclaration function.
        checkSignatureDeclaration(node);
        // Grammar check for checking only related to constructorDeclaration
        checkGrammarConstructorTypeParameters(node) || checkGrammarConstructorTypeAnnotation(node);
        checkSourceElement(node.body);
        registerForUnusedIdentifiersCheck(node);
        let symbol = getSymbolOfNode(node);
        let firstDeclaration = ts.getDeclarationOfKind(symbol, node.kind);
        // Only type check the symbol once
        if (node === firstDeclaration) {
            checkFunctionOrConstructorSymbol(symbol);
        }
        // exit early in the case of signature - super checks are not relevant to them
        if (ts.nodeIsMissing(node.body)) {
            return;
        }
        if (!produceDiagnostics) {
            return;
        }
        function containsSuperCallAsComputedPropertyName(n) {
            let name = ts.getNameOfDeclaration(n);
            return name && containsSuperCall(name);
        }
        function containsSuperCall(n) {
            if (ts.isSuperCall(n)) {
                return true;
            }
            else if (ts.isFunctionLike(n)) {
                return false;
            }
            else if (ts.isClassLike(n)) {
                return ts.forEach(n.members, containsSuperCallAsComputedPropertyName);
            }
            return ts.forEachChild(n, containsSuperCall);
        }
        function isInstancePropertyWithInitializer(n) {
            return n.kind === SyntaxKind.PropertyDeclaration &&
                !ts.hasModifier(n, ModifierFlags.Static) &&
                !!n.initializer;
        }
        // TS 1.0 spec (April 2014): 8.3.2
        // Constructors of classes with no extends clause may not contain super calls, whereas
        // constructors of derived classes must contain at least one super call somewhere in their function body.
        let containingClassDecl = node.parent;
        if (ts.getClassExtendsHeritageClauseElement(containingClassDecl)) {
            captureLexicalThis(node.parent, containingClassDecl);
            let classExtendsNull = classDeclarationExtendsNull(containingClassDecl);
            let superCall = getSuperCallInConstructor(node);
            if (superCall) {
                if (classExtendsNull) {
                    error(superCall, ts.Diagnostics.A_constructor_cannot_contain_a_super_call_when_its_class_extends_null);
                }
                // The first statement in the body of a constructor (excluding prologue directives) must be a super call
                // if both of the following are true:
                // - The containing class is a derived class.
                // - The constructor declares parameter properties
                //   or the containing class declares instance member variables with initializers.
                let superCallShouldBeFirst = ts.some(node.parent.members, isInstancePropertyWithInitializer) ||
                    ts.some(node.parameters, function (p) { return ts.hasModifier(p, 92 /* ParameterPropertyModifier */); });
                // Skip past any prologue directives to find the first statement
                // to ensure that it was a super call.
                if (superCallShouldBeFirst) {
                    let statements = node.body.statements;
                    let superCallStatement = void 0;
                    for (let _i = 0, statements_2 = statements; _i < statements_2.length; _i++) {
                        let statement = statements_2[_i];
                        if (statement.kind === 210 /* ExpressionStatement */ && ts.isSuperCall(statement.expression)) {
                            superCallStatement = statement;
                            break;
                        }
                        if (!ts.isPrologueDirective(statement)) {
                            break;
                        }
                    }
                    if (!superCallStatement) {
                        error(node, ts.Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties);
                    }
                }
            }
            else if (!classExtendsNull) {
                error(node, ts.Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call);
            }
        }
    }
    function checkAccessorDeclaration(node) {
        if (produceDiagnostics) {
            // Grammar checking accessors
            checkGrammarFunctionLikeDeclaration(node) || checkGrammarAccessor(node) || checkGrammarComputedPropertyName(node.name);
            checkDecorators(node);
            checkSignatureDeclaration(node);
            if (node.kind === 153 /* GetAccessor */) {
                if (!ts.isInAmbientContext(node) && ts.nodeIsPresent(node.body) && (node.flags & 128 /* HasImplicitReturn */)) {
                    if (!(node.flags & 256 /* HasExplicitReturn */)) {
                        error(node.name, ts.Diagnostics.A_get_accessor_must_return_a_value);
                    }
                }
            }
            // Do not use hasDynamicName here, because that returns false for well known symbols.
            // We want to perform checkComputedPropertyName for all computed properties, including
            // well known symbols.
            if (node.name.kind === 144 /* ComputedPropertyName */) {
                checkComputedPropertyName(node.name);
            }
            if (!ts.hasDynamicName(node)) {
                // TypeScript 1.0 spec (April 2014): 8.4.3
                // Accessors for the same member name must specify the same accessibility.
                let otherKind = node.kind === 153 /* GetAccessor */ ? 154 /* SetAccessor */ : 153 /* GetAccessor */;
                let otherAccessor = ts.getDeclarationOfKind(node.symbol, otherKind);
                if (otherAccessor) {
                    let nodeFlags = ts.getModifierFlags(node);
                    let otherFlags = ts.getModifierFlags(otherAccessor);
                    if ((nodeFlags & 28 /* AccessibilityModifier */) !== (otherFlags & 28 /* AccessibilityModifier */)) {
                        error(node.name, ts.Diagnostics.Getter_and_setter_accessors_do_not_agree_in_visibility);
                    }
                    if ((nodeFlags & 128 /* Abstract */) !== (otherFlags & 128 /* Abstract */)) {
                        error(node.name, ts.Diagnostics.Accessors_must_both_be_abstract_or_non_abstract);
                    }
                    // TypeScript 1.0 spec (April 2014): 4.5
                    // If both accessors include type annotations, the specified types must be identical.
                    checkAccessorDeclarationTypesIdentical(node, otherAccessor, getAnnotatedAccessorType, ts.Diagnostics.get_and_set_accessor_must_have_the_same_type);
                    checkAccessorDeclarationTypesIdentical(node, otherAccessor, getThisTypeOfDeclaration, ts.Diagnostics.get_and_set_accessor_must_have_the_same_this_type);
                }
            }
            let returnType = getTypeOfAccessors(getSymbolOfNode(node));
            if (node.kind === 153 /* GetAccessor */) {
                checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType);
            }
        }
        checkSourceElement(node.body);
        registerForUnusedIdentifiersCheck(node);
    }
    function checkAccessorDeclarationTypesIdentical(first, second, getAnnotatedType, message) {
        let firstType = getAnnotatedType(first);
        let secondType = getAnnotatedType(second);
        if (firstType && secondType && !isTypeIdenticalTo(firstType, secondType)) {
            error(first, message);
        }
    }
    function checkMissingDeclaration(node) {
        checkDecorators(node);
    }
    function checkTypeArgumentConstraints(typeParameters, typeArgumentNodes) {
        let minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
        let typeArguments;
        let mapper;
        let result = true;
        for (let i = 0; i < typeParameters.length; i++) {
            let constraint = getConstraintOfTypeParameter(typeParameters[i]);
            if (constraint) {
                if (!typeArguments) {
                    typeArguments = fillMissingTypeArguments(ts.map(typeArgumentNodes, getTypeFromTypeNode), typeParameters, minTypeArgumentCount, ts.isInJavaScriptFile(typeArgumentNodes[i]));
                    mapper = createTypeMapper(typeParameters, typeArguments);
                }
                let typeArgument = typeArguments[i];
                result = result && checkTypeAssignableTo(typeArgument, instantiateType(constraint, mapper), typeArgumentNodes[i], ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
            }
        }
        return result;
    }
    function checkTypeReferenceNode(node) {
        checkGrammarTypeArguments(node, node.typeArguments);
        if (node.kind === 159 /* TypeReference */ && node.typeName.jsdocDotPos !== undefined && !ts.isInJavaScriptFile(node) && !ts.isInJSDoc(node)) {
            grammarErrorAtPos(node, node.typeName.jsdocDotPos, 1, ts.Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments);
        }
        let type = getTypeFromTypeReference(node);
        if (type !== unknownType) {
            if (node.typeArguments) {
                // Do type argument local checks only if referenced type is successfully resolved
                ts.forEach(node.typeArguments, checkSourceElement);
                if (produceDiagnostics) {
                    let symbol = getNodeLinks(node).resolvedSymbol;
                    if (!symbol) {
                        // There is no resolved symbol cached if the type resolved to a builtin
                        // via JSDoc type reference resolution (eg, Boolean became boolean), none
                        // of which are generic when they have no associated symbol
                        // (additionally, JSDoc's index signature syntax, Object<string, T> actually uses generic syntax without being generic)
                        if (!ts.isJSDocIndexSignature(node)) {
                            error(node, ts.Diagnostics.Type_0_is_not_generic, typeToString(type));
                        }
                        return;
                    }
                    let typeParameters = symbol.flags & 524288 /* TypeAlias */ && getSymbolLinks(symbol).typeParameters;
                    if (!typeParameters && getObjectFlags(type) & 4 /* Reference */) {
                        typeParameters = type.target.localTypeParameters;
                    }
                    checkTypeArgumentConstraints(typeParameters, node.typeArguments);
                }
            }
            if (type.flags & 16 /* Enum */ && getNodeLinks(node).resolvedSymbol.flags & 8 /* EnumMember */) {
                error(node, ts.Diagnostics.Enum_type_0_has_members_with_initializers_that_are_not_literals, typeToString(type));
            }
        }
    }
    function checkTypeQuery(node) {
        getTypeFromTypeQueryNode(node);
    }
    function checkTypeLiteral(node) {
        ts.forEach(node.members, checkSourceElement);
        if (produceDiagnostics) {
            let type = getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);
            checkIndexConstraints(type);
            checkTypeForDuplicateIndexSignatures(node);
            checkObjectTypeForDuplicateDeclarations(node);
        }
    }
    function checkArrayType(node) {
        checkSourceElement(node.elementType);
    }
    function checkTupleType(node) {
        // Grammar checking
        let hasErrorFromDisallowedTrailingComma = checkGrammarForDisallowedTrailingComma(node.elementTypes);
        if (!hasErrorFromDisallowedTrailingComma && node.elementTypes.length === 0) {
            grammarErrorOnNode(node, ts.Diagnostics.A_tuple_type_element_list_cannot_be_empty);
        }
        ts.forEach(node.elementTypes, checkSourceElement);
    }
    function checkUnionOrIntersectionType(node) {
        ts.forEach(node.types, checkSourceElement);
    }
    function checkIndexedAccessIndexType(type, accessNode) {
        if (!(type.flags & 524288 /* IndexedAccess */)) {
            return type;
        }
        // Check if the index type is assignable to 'keyof T' for the object type.
        let objectType = type.objectType;
        let indexType = type.indexType;
        if (isTypeAssignableTo(indexType, getIndexType(objectType))) {
            if (accessNode.kind === 180 /* ElementAccessExpression */ && ts.isAssignmentTarget(accessNode) &&
                getObjectFlags(objectType) & 32 /* Mapped */ && objectType.declaration.readonlyToken) {
                error(accessNode, ts.Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
            }
            return type;
        }
        // Check if we're indexing with a numeric type and if either object or index types
        // is a generic type with a constraint that has a numeric index signature.
        if (getIndexInfoOfType(getApparentType(objectType), 1 /* Number */) && isTypeAssignableToKind(indexType, 84 /* NumberLike */)) {
            return type;
        }
        error(accessNode, ts.Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(objectType));
        return type;
    }
    function checkIndexedAccessType(node) {
        checkSourceElement(node.objectType);
        checkSourceElement(node.indexType);
        checkIndexedAccessIndexType(getTypeFromIndexedAccessTypeNode(node), node);
    }
    function checkMappedType(node) {
        checkSourceElement(node.typeParameter);
        checkSourceElement(node.type);
        let type = getTypeFromMappedTypeNode(node);
        let constraintType = getConstraintTypeFromMappedType(type);
        checkTypeAssignableTo(constraintType, stringType, node.typeParameter.constraint);
    }
    function isPrivateWithinAmbient(node) {
        return ts.hasModifier(node, 8 /* Private */) && ts.isInAmbientContext(node);
    }
    function getEffectiveDeclarationFlags(n, flagsToCheck) {
        let flags = ts.getCombinedModifierFlags(n);
        // children of classes (even ambient classes) should not be marked as ambient or export
        // because those flags have no useful semantics there.
        if (n.parent.kind !== SyntaxKind.InterfaceDeclaration &&
            n.parent.kind !== SyntaxKind.ClassDeclaration &&
            n.parent.kind !== SyntaxKind.ClassExpression &&
            ts.isInAmbientContext(n)) {
            if (!(flags & 2 /* Ambient */)) {
                // It is nested in an ambient context, which means it is automatically exported
                flags |= 1 /* Export */;
            }
            flags |= 2 /* Ambient */;
        }
        return flags & flagsToCheck;
    }
    function checkFunctionOrConstructorSymbol(symbol) {
        if (!produceDiagnostics) {
            return;
        }
        function getCanonicalOverload(overloads, implementation) {
            // Consider the canonical set of flags to be the flags of the bodyDeclaration or the first declaration
            // Error on all deviations from this canonical set of flags
            // The caveat is that if some overloads are defined in lib.d.ts, we don't want to
            // report the errors on those. To achieve this, we will say that the implementation is
            // the canonical signature only if it is in the same container as the first overload
            let implementationSharesContainerWithFirstOverload = implementation !== undefined && implementation.parent === overloads[0].parent;
            return implementationSharesContainerWithFirstOverload ? implementation : overloads[0];
        }
        function checkFlagAgreementBetweenOverloads(overloads, implementation, flagsToCheck, someOverloadFlags, allOverloadFlags) {
            // Error if some overloads have a flag that is not shared by all overloads. To find the
            // deviations, we XOR someOverloadFlags with allOverloadFlags
            let someButNotAllOverloadFlags = someOverloadFlags ^ allOverloadFlags;
            if (someButNotAllOverloadFlags !== 0) {
                let canonicalFlags_1 = getEffectiveDeclarationFlags(getCanonicalOverload(overloads, implementation), flagsToCheck);
                ts.forEach(overloads, function (o) {
                    let deviation = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags_1;
                    if (deviation & 1 /* Export */) {
                        error(ts.getNameOfDeclaration(o), ts.Diagnostics.Overload_signatures_must_all_be_exported_or_non_exported);
                    }
                    else if (deviation & 2 /* Ambient */) {
                        error(ts.getNameOfDeclaration(o), ts.Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient);
                    }
                    else if (deviation & (8 /* Private */ | 16 /* Protected */)) {
                        error(ts.getNameOfDeclaration(o) || o, ts.Diagnostics.Overload_signatures_must_all_be_public_private_or_protected);
                    }
                    else if (deviation & 128 /* Abstract */) {
                        error(ts.getNameOfDeclaration(o), ts.Diagnostics.Overload_signatures_must_all_be_abstract_or_non_abstract);
                    }
                });
            }
        }
        function checkQuestionTokenAgreementBetweenOverloads(overloads, implementation, someHaveQuestionToken, allHaveQuestionToken) {
            if (someHaveQuestionToken !== allHaveQuestionToken) {
                let canonicalHasQuestionToken_1 = ts.hasQuestionToken(getCanonicalOverload(overloads, implementation));
                ts.forEach(overloads, function (o) {
                    let deviation = ts.hasQuestionToken(o) !== canonicalHasQuestionToken_1;
                    if (deviation) {
                        error(ts.getNameOfDeclaration(o), ts.Diagnostics.Overload_signatures_must_all_be_optional_or_required);
                    }
                });
            }
        }
        let flagsToCheck = 1 /* Export */ | 2 /* Ambient */ | 8 /* Private */ | 16 /* Protected */ | 128 /* Abstract */;
        let someNodeFlags = 0 /* None */;
        let allNodeFlags = flagsToCheck;
        let someHaveQuestionToken = false;
        let allHaveQuestionToken = true;
        let hasOverloads = false;
        let bodyDeclaration;
        let lastSeenNonAmbientDeclaration;
        let previousDeclaration;
        let declarations = symbol.declarations;
        let isConstructor = (symbol.flags & 16384 /* Constructor */) !== 0;
        function reportImplementationExpectedError(node) {
            if (node.name && ts.nodeIsMissing(node.name)) {
                return;
            }
            let seen = false;
            let subsequentNode = ts.forEachChild(node.parent, function (c) {
                if (seen) {
                    return c;
                }
                else {
                    seen = c === node;
                }
            });
            // We may be here because of some extra nodes between overloads that could not be parsed into a valid node.
            // In this case the subsequent node is not really consecutive (.pos !== node.end), and we must ignore it here.
            if (subsequentNode && subsequentNode.pos === node.end) {
                if (subsequentNode.kind === node.kind) {
                    let errorNode_1 = subsequentNode.name || subsequentNode;
                    // TODO: GH#17345: These are methods, so handle computed name case. (`Always allowing computed property names is *not* the correct behavior!)
                    let subsequentName = subsequentNode.name;
                    if (node.name && subsequentName &&
                        (ts.isComputedPropertyName(node.name) && ts.isComputedPropertyName(subsequentName) ||
                            !ts.isComputedPropertyName(node.name) && !ts.isComputedPropertyName(subsequentName) && ts.getEscapedTextOfIdentifierOrLiteral(node.name) === ts.getEscapedTextOfIdentifierOrLiteral(subsequentName))) {
                        let reportError = (node.kind === SyntaxKind.MethodDeclaration || node.kind === 150 /* MethodSignature */) &&
                            ts.hasModifier(node, ModifierFlags.Static) !== ts.hasModifier(subsequentNode, ModifierFlags.Static);
                        // we can get here in two cases
                        // 1. mixed static and instance class members
                        // 2. something with the same name was defined before the set of overloads that prevents them from merging
                        // here we'll report error only for the first case since for second we should already report error in binder
                        if (reportError) {
                            let diagnostic = ts.hasModifier(node, ModifierFlags.Static) ? ts.Diagnostics.Function_overload_must_be_static : ts.Diagnostics.Function_overload_must_not_be_static;
                            error(errorNode_1, diagnostic);
                        }
                        return;
                    }
                    else if (ts.nodeIsPresent(subsequentNode.body)) {
                        error(errorNode_1, ts.Diagnostics.Function_implementation_name_must_be_0, ts.declarationNameToString(node.name));
                        return;
                    }
                }
            }
            let errorNode = node.name || node;
            if (isConstructor) {
                error(errorNode, ts.Diagnostics.Constructor_implementation_is_missing);
            }
            else {
                // Report different errors regarding non-consecutive blocks of declarations depending on whether
                // the node in question is abstract.
                if (ts.hasModifier(node, 128 /* Abstract */)) {
                    error(errorNode, ts.Diagnostics.All_declarations_of_an_abstract_method_must_be_consecutive);
                }
                else {
                    error(errorNode, ts.Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration);
                }
            }
        }
        let duplicateFunctionDeclaration = false;
        let multipleConstructorImplementation = false;
        for (let _i = 0, declarations_4 = declarations; _i < declarations_4.length; _i++) {
            let current = declarations_4[_i];
            let node = current;
            let inAmbientContext = ts.isInAmbientContext(node);
            let inAmbientContextOrInterface = node.parent.kind === SyntaxKind.InterfaceDeclaration || node.parent.kind === 163 /* TypeLiteral */ || inAmbientContext;
            if (inAmbientContextOrInterface) {
                // check if declarations are consecutive only if they are non-ambient
                // 1. ambient declarations can be interleaved
                // i.e. this is legal
                //     declare function foo();
                //     declare function bar();
                //     declare function foo();
                // 2. mixing ambient and non-ambient declarations is a separate error that will be reported - do not want to report an extra one
                previousDeclaration = undefined;
            }
            if (node.kind === 228 /* FunctionDeclaration */ || node.kind === SyntaxKind.MethodDeclaration || node.kind === 150 /* MethodSignature */ || node.kind === 152 /* Constructor */) {
                let currentNodeFlags = getEffectiveDeclarationFlags(node, flagsToCheck);
                someNodeFlags |= currentNodeFlags;
                allNodeFlags &= currentNodeFlags;
                someHaveQuestionToken = someHaveQuestionToken || ts.hasQuestionToken(node);
                allHaveQuestionToken = allHaveQuestionToken && ts.hasQuestionToken(node);
                if (ts.nodeIsPresent(node.body) && bodyDeclaration) {
                    if (isConstructor) {
                        multipleConstructorImplementation = true;
                    }
                    else {
                        duplicateFunctionDeclaration = true;
                    }
                }
                else if (previousDeclaration && previousDeclaration.parent === node.parent && previousDeclaration.end !== node.pos) {
                    reportImplementationExpectedError(previousDeclaration);
                }
                if (ts.nodeIsPresent(node.body)) {
                    if (!bodyDeclaration) {
                        bodyDeclaration = node;
                    }
                }
                else {
                    hasOverloads = true;
                }
                previousDeclaration = node;
                if (!inAmbientContextOrInterface) {
                    lastSeenNonAmbientDeclaration = node;
                }
            }
        }
        if (multipleConstructorImplementation) {
            ts.forEach(declarations, function (declaration) {
                error(declaration, ts.Diagnostics.Multiple_constructor_implementations_are_not_allowed);
            });
        }
        if (duplicateFunctionDeclaration) {
            ts.forEach(declarations, function (declaration) {
                error(ts.getNameOfDeclaration(declaration), ts.Diagnostics.Duplicate_function_implementation);
            });
        }
        // Abstract methods can't have an implementation -- in particular, they don't need one.
        if (lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body &&
            !ts.hasModifier(lastSeenNonAmbientDeclaration, 128 /* Abstract */) && !lastSeenNonAmbientDeclaration.questionToken) {
            reportImplementationExpectedError(lastSeenNonAmbientDeclaration);
        }
        if (hasOverloads) {
            checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags);
            checkQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken);
            if (bodyDeclaration) {
                let signatures = getSignaturesOfSymbol(symbol);
                let bodySignature = getSignatureFromDeclaration(bodyDeclaration);
                for (let _a = 0, signatures_7 = signatures; _a < signatures_7.length; _a++) {
                    let signature = signatures_7[_a];
                    if (!isImplementationCompatibleWithOverload(bodySignature, signature)) {
                        error(signature.declaration, ts.Diagnostics.Overload_signature_is_not_compatible_with_function_implementation);
                        break;
                    }
                }
            }
        }
    }
    function checkExportsOnMergedDeclarations(node) {
        if (!produceDiagnostics) {
            return;
        }
        // if localSymbol is defined on node then node itself is exported - check is required
        let symbol = node.localSymbol;
        if (!symbol) {
            // local symbol is undefined => this declaration is non-exported.
            // however symbol might contain other declarations that are exported
            symbol = getSymbolOfNode(node);
            if (!symbol.exportSymbol) {
                // this is a pure local symbol (all declarations are non-exported) - no need to check anything
                return;
            }
        }
        // run the check only for the first declaration in the list
        if (ts.getDeclarationOfKind(symbol, node.kind) !== node) {
            return;
        }
        let exportedDeclarationSpaces = 0 /* None */;
        let nonExportedDeclarationSpaces = 0 /* None */;
        let defaultExportedDeclarationSpaces = 0 /* None */;
        for (let _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
            let d = _a[_i];
            let declarationSpaces = getDeclarationSpaces(d);
            let effectiveDeclarationFlags = getEffectiveDeclarationFlags(d, 1 /* Export */ | 512 /* Default */);
            if (effectiveDeclarationFlags & 1 /* Export */) {
                if (effectiveDeclarationFlags & 512 /* Default */) {
                    defaultExportedDeclarationSpaces |= declarationSpaces;
                }
                else {
                    exportedDeclarationSpaces |= declarationSpaces;
                }
            }
            else {
                nonExportedDeclarationSpaces |= declarationSpaces;
            }
        }
        // Spaces for anything not declared a 'default export'.
        let nonDefaultExportedDeclarationSpaces = exportedDeclarationSpaces | nonExportedDeclarationSpaces;
        let commonDeclarationSpacesForExportsAndLocals = exportedDeclarationSpaces & nonExportedDeclarationSpaces;
        let commonDeclarationSpacesForDefaultAndNonDefault = defaultExportedDeclarationSpaces & nonDefaultExportedDeclarationSpaces;
        if (commonDeclarationSpacesForExportsAndLocals || commonDeclarationSpacesForDefaultAndNonDefault) {
            // declaration spaces for exported and non-exported declarations intersect
            for (let _b = 0, _c = symbol.declarations; _b < _c.length; _b++) {
                let d = _c[_b];
                let declarationSpaces = getDeclarationSpaces(d);
                let name = ts.getNameOfDeclaration(d);
                // Only error on the declarations that contributed to the intersecting spaces.
                if (declarationSpaces & commonDeclarationSpacesForDefaultAndNonDefault) {
                    error(name, ts.Diagnostics.Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead, ts.declarationNameToString(name));
                }
                else if (declarationSpaces & commonDeclarationSpacesForExportsAndLocals) {
                    error(name, ts.Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, ts.declarationNameToString(name));
                }
            }
        }
        let DeclarationSpaces;
        (function (DeclarationSpaces) {
            DeclarationSpaces[DeclarationSpaces["None"] = 0] = "None";
            DeclarationSpaces[DeclarationSpaces["ExportValue"] = 1] = "ExportValue";
            DeclarationSpaces[DeclarationSpaces["ExportType"] = 2] = "ExportType";
            DeclarationSpaces[DeclarationSpaces["ExportNamespace"] = 4] = "ExportNamespace";
        })(DeclarationSpaces || (DeclarationSpaces = {}));
        function getDeclarationSpaces(d) {
            switch (d.kind) {
                case SyntaxKind.InterfaceDeclaration:
                case 231 /* TypeAliasDeclaration */:
                // A jsdoc typedef is, by definition, a type alias
                case 286 /* JSDocTypedefTag */:
                    return 2 /* ExportType */;
                case SyntaxKind.ModuleDeclaration:
                    return ts.isAmbientModule(d) || ts.getModuleInstanceState(d) !== 0 /* NonInstantiated */
                        ? 4 /* ExportNamespace */ | 1 /* ExportValue */
                        : 4 /* ExportNamespace */;
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.EnumDeclaration:
                    return 2 /* ExportType */ | 1 /* ExportValue */;
                // The below options all declare an Alias, which is allowed to merge with other values within the importing module
                case 237 /* ImportEqualsDeclaration */:
                case 240 /* NamespaceImport */:
                case 239 /* ImportClause */:
                    let result_3 = 0 /* None */;
                    let target = resolveAlias(getSymbolOfNode(d));
                    ts.forEach(target.declarations, function (d) { result_3 |= getDeclarationSpaces(d); });
                    return result_3;
                case SyntaxKind.VariableDeclaration:
                case 176 /* BindingElement */:
                case 228 /* FunctionDeclaration */:
                case 242 /* ImportSpecifier */:// https://github.com/Microsoft/TypeScript/pull/7591
                    return 1 /* ExportValue */;
                default:
                    ts.Debug.fail(ts.SyntaxKind[d.kind]);
            }
        }
    }
    function getAwaitedTypeOfPromise(type, errorNode, diagnosticMessage) {
        let promisedType = getPromisedTypeOfPromise(type, errorNode);
        return promisedType && getAwaitedType(promisedType, errorNode, diagnosticMessage);
    }
    /**
     * Gets the "promised type" of a promise.
     * @param type The type of the promise.
     * @remarks The "promised type" of a type is the type of the "value" parameter of the "onfulfilled" callback.
     */
    function getPromisedTypeOfPromise(promise, errorNode) {
        //
        //  { // promise
        //      then( // thenFunction
        //          onfulfilled: ( // onfulfilledParameterType
        //              value: T // valueParameterType
        //          ) => any
        //      ): any;
        //  }
        //
        if (isTypeAny(promise)) {
            return undefined;
        }
        let typeAsPromise = promise;
        if (typeAsPromise.promisedTypeOfPromise) {
            return typeAsPromise.promisedTypeOfPromise;
        }
        if (isReferenceToType(promise, getGlobalPromiseType(/*reportErrors*/ false))) {
            return typeAsPromise.promisedTypeOfPromise = promise.typeArguments[0];
        }
        let thenFunction = getTypeOfPropertyOfType(promise, "then");
        if (isTypeAny(thenFunction)) {
            return undefined;
        }
        let thenSignatures = thenFunction ? getSignaturesOfType(thenFunction, 0 /* Call */) : ts.emptyArray;
        if (thenSignatures.length === 0) {
            if (errorNode) {
                error(errorNode, ts.Diagnostics.A_promise_must_have_a_then_method);
            }
            return undefined;
        }
        let onfulfilledParameterType = getTypeWithFacts(getUnionType(ts.map(thenSignatures, getTypeOfFirstParameterOfSignature)), 524288 /* NEUndefinedOrNull */);
        if (isTypeAny(onfulfilledParameterType)) {
            return undefined;
        }
        let onfulfilledParameterSignatures = getSignaturesOfType(onfulfilledParameterType, 0 /* Call */);
        if (onfulfilledParameterSignatures.length === 0) {
            if (errorNode) {
                error(errorNode, ts.Diagnostics.The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback);
            }
            return undefined;
        }
        return typeAsPromise.promisedTypeOfPromise = getUnionType(ts.map(onfulfilledParameterSignatures, getTypeOfFirstParameterOfSignature), /*subtypeReduction*/ true);
    }
    /**
     * Gets the "awaited type" of a type.
     * @param type The type to await.
     * @remarks The "awaited type" of an expression is its "promised type" if the expression is a
     * Promise-like type; otherwise, it is the type of the expression. This is used to reflect
     * The runtime behavior of the `await` keyword.
     */
    function checkAwaitedType(type, errorNode, diagnosticMessage) {
        return getAwaitedType(type, errorNode, diagnosticMessage) || unknownType;
    }
    function getAwaitedType(type, errorNode, diagnosticMessage) {
        let typeAsAwaitable = type;
        if (typeAsAwaitable.awaitedTypeOfType) {
            return typeAsAwaitable.awaitedTypeOfType;
        }
        if (isTypeAny(type)) {
            return typeAsAwaitable.awaitedTypeOfType = type;
        }
        if (type.flags & 65536 /* Union */) {
            let types = void 0;
            for (let _i = 0, _a = type.types; _i < _a.length; _i++) {
                let constituentType = _a[_i];
                types = ts.append(types, getAwaitedType(constituentType, errorNode, diagnosticMessage));
            }
            if (!types) {
                return undefined;
            }
            return typeAsAwaitable.awaitedTypeOfType = getUnionType(types);
        }
        let promisedType = getPromisedTypeOfPromise(type);
        if (promisedType) {
            if (type.id === promisedType.id || ts.indexOf(awaitedTypeStack, promisedType.id) >= 0) {
                // Verify that we don't have a bad actor in the form of a promise whose
                // promised type is the same as the promise type, or a mutually recursive
                // promise. If so, we return undefined as we cannot guess the shape. If this
                // were the actual case in the JavaScript, this Promise would never resolve.
                //
                // An example of a bad actor with a singly-recursive promise type might
                // be:
                //
                //  interface BadPromise {
                //      then(
                //          onfulfilled: (value: BadPromise) => any,
                //          onrejected: (error: any) => any): BadPromise;
                //  }
                // The above interface will pass the PromiseLike check, and return a
                // promised type of `BadPromise`. Since this is a self reference, we
                // don't want to keep recursing ad infinitum.
                //
                // An example of a bad actor in the form of a mutually-recursive
                // promise type might be:
                //
                //  interface BadPromiseA {
                //      then(
                //          onfulfilled: (value: BadPromiseB) => any,
                //          onrejected: (error: any) => any): BadPromiseB;
                //  }
                //
                //  interface BadPromiseB {
                //      then(
                //          onfulfilled: (value: BadPromiseA) => any,
                //          onrejected: (error: any) => any): BadPromiseA;
                //  }
                //
                if (errorNode) {
                    error(errorNode, ts.Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method);
                }
                return undefined;
            }
            // Keep track of the type we're about to unwrap to avoid bad recursive promise types.
            // See the comments above for more information.
            awaitedTypeStack.push(type.id);
            let awaitedType = getAwaitedType(promisedType, errorNode, diagnosticMessage);
            awaitedTypeStack.pop();
            if (!awaitedType) {
                return undefined;
            }
            return typeAsAwaitable.awaitedTypeOfType = awaitedType;
        }
        // The type was not a promise, so it could not be unwrapped any further.
        // As long as the type does not have a callable "then" property, it is
        // safe to return the type; otherwise, an error will be reported in
        // the call to getNonThenableType and we will return undefined.
        //
        // An example of a non-promise "thenable" might be:
        //
        //  await { then(): void {} }
        //
        // The "thenable" does not match the minimal definition for a promise. When
        // a Promise/A+-compatible or ES6 promise tries to adopt this value, the promise
        // will never settle. We treat this as an error to help flag an early indicator
        // of a runtime problem. If the user wants to return this value from an async
        // function, they would need to wrap it in some other value. If they want it to
        // be treated as a promise, they can cast to <any>.
        let thenFunction = getTypeOfPropertyOfType(type, "then");
        if (thenFunction && getSignaturesOfType(thenFunction, 0 /* Call */).length > 0) {
            if (errorNode) {
                ts.Debug.assert(!!diagnosticMessage);
                error(errorNode, diagnosticMessage);
            }
            return undefined;
        }
        return typeAsAwaitable.awaitedTypeOfType = type;
    }
    /**
     * Checks the return type of an async function to ensure it is a compatible
     * Promise implementation.
     *
     * This checks that an async function has a valid Promise-compatible return type,
     * and returns the *awaited type* of the promise. An async function has a valid
     * Promise-compatible return type if the resolved value of the return type has a
     * construct signature that takes in an `initializer` function that in turn supplies
     * a `resolve` function as one of its arguments and results in an object with a
     * callable `then` signature.
     *
     * @param node The signature to check
     */
    function checkAsyncFunctionReturnType(node) {
        // As part of our emit for an async function, we will need to emit the entity name of
        // the return type annotation as an expression. To meet the necessary runtime semantics
        // for __awaiter, we must also check that the type of the declaration (e.g. the static
        // side or "constructor" of the promise type) is compatible `PromiseConstructorLike`.
        //
        // An example might be (from lib.es6.d.ts):
        //
        //  interface Promise<T> { ... }
        //  interface PromiseConstructor {
        //      new <T>(...): Promise<T>;
        //  }
        //  declare let Promise: PromiseConstructor;
        //
        // When an async function declares a return type annotation of `Promise<T>`, we
        // need to get the type of the `Promise` variable declaration above, which would
        // be `PromiseConstructor`.
        //
        // The same case applies to a class:
        //
        //  declare class Promise<T> {
        //      constructor(...);
        //      then<U>(...): Promise<U>;
        //  }
        //
        let returnTypeNode = ts.getEffectiveReturnTypeNode(node);
        let returnType = getTypeFromTypeNode(returnTypeNode);
        if (languageVersion >= 2 /* ES2015 */) {
            if (returnType === unknownType) {
                return unknownType;
            }
            let globalPromiseType = getGlobalPromiseType(/*reportErrors*/ true);
            if (globalPromiseType !== emptyGenericType && !isReferenceToType(returnType, globalPromiseType)) {
                // The promise type was not a valid type reference to the global promise type, so we
                // report an error and return the unknown type.
                error(returnTypeNode, ts.Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type);
                return unknownType;
            }
        }
        else {
            // Always mark the type node as referenced if it points to a value
            markTypeNodeAsReferenced(returnTypeNode);
            if (returnType === unknownType) {
                return unknownType;
            }
            let promiseConstructorName = ts.getEntityNameFromTypeNode(returnTypeNode);
            if (promiseConstructorName === undefined) {
                error(returnTypeNode, ts.Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, typeToString(returnType));
                return unknownType;
            }
            let promiseConstructorSymbol = resolveEntityName(promiseConstructorName, SymbolFlags.Value, /*ignoreErrors*/ true);
            let promiseConstructorType = promiseConstructorSymbol ? getTypeOfSymbol(promiseConstructorSymbol) : unknownType;
            if (promiseConstructorType === unknownType) {
                if (promiseConstructorName.kind === 71 /* Identifier */ && promiseConstructorName.escapedText === "Promise" && getTargetType(returnType) === getGlobalPromiseType(/*reportErrors*/ false)) {
                    error(returnTypeNode, ts.Diagnostics.An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option);
                }
                else {
                    error(returnTypeNode, ts.Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, ts.entityNameToString(promiseConstructorName));
                }
                return unknownType;
            }
            let globalPromiseConstructorLikeType = getGlobalPromiseConstructorLikeType(/*reportErrors*/ true);
            if (globalPromiseConstructorLikeType === emptyObjectType) {
                // If we couldn't resolve the global PromiseConstructorLike type we cannot verify
                // compatibility with __awaiter.
                error(returnTypeNode, ts.Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, ts.entityNameToString(promiseConstructorName));
                return unknownType;
            }
            if (!checkTypeAssignableTo(promiseConstructorType, globalPromiseConstructorLikeType, returnTypeNode, ts.Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value)) {
                return unknownType;
            }
            // Verify there is no local declaration that could collide with the promise constructor.
            let rootName = promiseConstructorName && getFirstIdentifier(promiseConstructorName);
            let collidingSymbol = getSymbol(node.locals, rootName.escapedText, SymbolFlags.Value);
            if (collidingSymbol) {
                error(collidingSymbol.valueDeclaration, ts.Diagnostics.Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions, ts.idText(rootName), ts.entityNameToString(promiseConstructorName));
                return unknownType;
            }
        }
        // Get and return the awaited type of the return type.
        return checkAwaitedType(returnType, node, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
    }
    /** Check a decorator */
    function checkDecorator(node) {
        let signature = getResolvedSignature(node);
        let returnType = getReturnTypeOfSignature(signature);
        if (returnType.flags & 1 /* Any */) {
            return;
        }
        let expectedReturnType;
        let headMessage = getDiagnosticHeadMessageForDecoratorResolution(node);
        let errorInfo;
        switch (node.parent.kind) {
            case SyntaxKind.ClassDeclaration:
                let classSymbol = getSymbolOfNode(node.parent);
                let classConstructorType = getTypeOfSymbol(classSymbol);
                expectedReturnType = getUnionType([classConstructorType, voidType]);
                break;
            case SyntaxKind.Parameter:
                expectedReturnType = voidType;
                errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any);
                break;
            case SyntaxKind.PropertyDeclaration:
                expectedReturnType = voidType;
                errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.The_return_type_of_a_property_decorator_function_must_be_either_void_or_any);
                break;
            case SyntaxKind.MethodDeclaration:
            case 153 /* GetAccessor */:
            case 154 /* SetAccessor */:
                let methodType = getTypeOfNode(node.parent);
                let descriptorType = createTypedPropertyDescriptorType(methodType);
                expectedReturnType = getUnionType([descriptorType, voidType]);
                break;
        }
        checkTypeAssignableTo(returnType, expectedReturnType, node, headMessage, errorInfo);
    }
    /**
     * If a TypeNode can be resolved to a value symbol imported from an external module, it is
     * marked as referenced to prevent import elision.
     */
    function markTypeNodeAsReferenced(node) {
        markEntityNameOrEntityExpressionAsReference(node && ts.getEntityNameFromTypeNode(node));
    }
    function markEntityNameOrEntityExpressionAsReference(typeName) {
        if (!typeName)
            return;
        let rootName = getFirstIdentifier(typeName);
        let meaning = (typeName.kind === 71 /* Identifier */ ? SymbolFlags.Type : SymbolFlags.Namespace) | SymbolFlags.Alias;
        let rootSymbol = resolveName(rootName, rootName.escapedText, meaning, /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isRefernce*/ true);
        if (rootSymbol
            && rootSymbol.flags & SymbolFlags.Alias
            && symbolIsValue(rootSymbol)
            && !isConstEnumOrConstEnumOnlyModule(resolveAlias(rootSymbol))) {
            markAliasSymbolAsReferenced(rootSymbol);
        }
    }
    /**
     * This function marks the type used for metadata decorator as referenced if it is import
     * from external module.
     * This is different from markTypeNodeAsReferenced because it tries to simplify type nodes in
     * union and intersection type
     * @param node
     */
    function markDecoratorMedataDataTypeNodeAsReferenced(node) {
        let entityName = getEntityNameForDecoratorMetadata(node);
        if (entityName && ts.isEntityName(entityName)) {
            markEntityNameOrEntityExpressionAsReference(entityName);
        }
    }
    function getEntityNameForDecoratorMetadata(node) {
        if (node) {
            switch (node.kind) {
                case 167 /* IntersectionType */:
                case 166 /* UnionType */:
                    let commonEntityName = void 0;
                    for (let _i = 0, _a = node.types; _i < _a.length; _i++) {
                        let typeNode = _a[_i];
                        let individualEntityName = getEntityNameForDecoratorMetadata(typeNode);
                        if (!individualEntityName) {
                            // Individual is something like string number
                            // So it would be serialized to either that type or object
                            // Safe to return here
                            return undefined;
                        }
                        if (commonEntityName) {
                            // Note this is in sync with the transformation that happens for type node.
                            // Keep this in sync with serializeUnionOrIntersectionType
                            // Verify if they refer to same entity and is identifier
                            // return undefined if they dont match because we would emit object
                            if (!ts.isIdentifier(commonEntityName) ||
                                !ts.isIdentifier(individualEntityName) ||
                                commonEntityName.escapedText !== individualEntityName.escapedText) {
                                return undefined;
                            }
                        }
                        else {
                            commonEntityName = individualEntityName;
                        }
                    }
                    return commonEntityName;
                case 168 /* ParenthesizedType */:
                    return getEntityNameForDecoratorMetadata(node.type);
                case 159 /* TypeReference */:
                    return node.typeName;
            }
        }
    }
    function getParameterTypeNodeForDecoratorCheck(node) {
        let typeNode = ts.getEffectiveTypeAnnotationNode(node);
        return ts.isRestParameter(node) ? ts.getRestParameterElementType(typeNode) : typeNode;
    }
    /** Check the decorators of a node */
    function checkDecorators(node) {
        if (!node.decorators) {
            return;
        }
        // skip this check for nodes that cannot have decorators. These should have already had an error reported by
        // checkGrammarDecorators.
        if (!ts.nodeCanBeDecorated(node)) {
            return;
        }
        if (!compilerOptions.experimentalDecorators) {
            error(node, ts.Diagnostics.Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_the_experimentalDecorators_option_to_remove_this_warning);
        }
        let firstDecorator = node.decorators[0];
        checkExternalEmitHelpers(firstDecorator, 8 /* Decorate */);
        if (node.kind === SyntaxKind.Parameter) {
            checkExternalEmitHelpers(firstDecorator, 32 /* Param */);
        }
        if (compilerOptions.emitDecoratorMetadata) {
            checkExternalEmitHelpers(firstDecorator, 16 /* Metadata */);
            // we only need to perform these checks if we are emitting serialized type metadata for the target of a decorator.
            switch (node.kind) {
                case SyntaxKind.ClassDeclaration:
                    let constructor = ts.getFirstConstructorWithBody(node);
                    if (constructor) {
                        for (let _i = 0, _a = constructor.parameters; _i < _a.length; _i++) {
                            let parameter = _a[_i];
                            markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
                        }
                    }
                    break;
                case SyntaxKind.MethodDeclaration:
                case 153 /* GetAccessor */:
                case 154 /* SetAccessor */:
                    for (let _b = 0, _c = node.parameters; _b < _c.length; _b++) {
                        let parameter = _c[_b];
                        markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
                    }
                    markDecoratorMedataDataTypeNodeAsReferenced(ts.getEffectiveReturnTypeNode(node));
                    break;
                case SyntaxKind.PropertyDeclaration:
                    markDecoratorMedataDataTypeNodeAsReferenced(ts.getEffectiveTypeAnnotationNode(node));
                    break;
                case SyntaxKind.Parameter:
                    markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(node));
                    break;
            }
        }
        ts.forEach(node.decorators, checkDecorator);
    }
    function checkFunctionDeclaration(node) {
        if (produceDiagnostics) {
            checkFunctionOrMethodDeclaration(node);
            checkGrammarForGenerator(node);
            checkCollisionWithCapturedSuperVariable(node, node.name);
            checkCollisionWithCapturedThisVariable(node, node.name);
            checkCollisionWithCapturedNewTargetVariable(node, node.name);
            checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
            checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name);
        }
    }
    function checkJSDocTypedefTag(node) {
        if (!node.typeExpression) {
            // If the node had `@property` tags, `typeExpression` would have been set to the first property tag.
            error(node.name, ts.Diagnostics.JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags);
        }
    }
    function checkJSDocParameterTag(node) {
        checkSourceElement(node.typeExpression);
        if (!ts.getParameterSymbolFromJSDoc(node)) {
            error(node.name, ts.Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name, ts.idText(node.name.kind === 143 /* QualifiedName */ ? node.name.right : node.name));
        }
    }
    function checkJSDocAugmentsTag(node) {
        let classLike = ts.getJSDocHost(node);
        if (!ts.isClassDeclaration(classLike) && !ts.isClassExpression(classLike)) {
            error(classLike, ts.Diagnostics.JSDoc_0_is_not_attached_to_a_class, ts.idText(node.tagName));
            return;
        }
        let augmentsTags = ts.getAllJSDocTagsOfKind(classLike, 280 /* JSDocAugmentsTag */);
        ts.Debug.assert(augmentsTags.length > 0);
        if (augmentsTags.length > 1) {
            error(augmentsTags[1], ts.Diagnostics.Class_declarations_cannot_have_more_than_one_augments_or_extends_tag);
        }
        let name = getIdentifierFromEntityNameExpression(node.class.expression);
        let extend = ts.getClassExtendsHeritageClauseElement(classLike);
        if (extend) {
            let className = getIdentifierFromEntityNameExpression(extend.expression);
            if (className && name.escapedText !== className.escapedText) {
                error(name, ts.Diagnostics.JSDoc_0_1_does_not_match_the_extends_2_clause, ts.idText(node.tagName), ts.idText(name), ts.idText(className));
            }
        }
    }
    function getIdentifierFromEntityNameExpression(node) {
        switch (node.kind) {
            case 71 /* Identifier */:
                return node;
            case 179 /* PropertyAccessExpression */:
                return node.name;
            default:
                return undefined;
        }
    }
    function checkFunctionOrMethodDeclaration(node) {
        checkDecorators(node);
        checkSignatureDeclaration(node);
        let functionFlags = ts.getFunctionFlags(node);
        // Do not use hasDynamicName here, because that returns false for well known symbols.
        // We want to perform checkComputedPropertyName for all computed properties, including
        // well known symbols.
        if (node.name && node.name.kind === 144 /* ComputedPropertyName */) {
            // This check will account for methods in class/interface declarations,
            // as well as accessors in classes/object literals
            checkComputedPropertyName(node.name);
        }
        if (!ts.hasDynamicName(node)) {
            // first we want to check the local symbol that contain this declaration
            // - if node.localSymbol !== undefined - this is current declaration is exported and localSymbol points to the local symbol
            // - if node.localSymbol === undefined - this node is non-exported so we can just pick the result of getSymbolOfNode
            let symbol = getSymbolOfNode(node);
            let localSymbol = node.localSymbol || symbol;
            // Since the javascript won't do semantic analysis like typescript,
            // if the javascript file comes before the typescript file and both contain same name functions,
            // checkFunctionOrConstructorSymbol wouldn't be called if we didnt ignore javascript function.
            let firstDeclaration = ts.find(localSymbol.declarations,
                // Get first non javascript function declaration
                function (declaration) { return declaration.kind === node.kind && !(declaration.flags & 65536 /* JavaScriptFile */); });
            // Only type check the symbol once
            if (node === firstDeclaration) {
                checkFunctionOrConstructorSymbol(localSymbol);
            }
            if (symbol.parent) {
                // run check once for the first declaration
                if (ts.getDeclarationOfKind(symbol, node.kind) === node) {
                    // run check on export symbol to check that modifiers agree across all exported declarations
                    checkFunctionOrConstructorSymbol(symbol);
                }
            }
        }
        checkSourceElement(node.body);
        let returnTypeNode = ts.getEffectiveReturnTypeNode(node);
        if ((functionFlags & 1 /* Generator */) === 0) {
            let returnOrPromisedType = returnTypeNode && (functionFlags & 2 /* Async */
                ? checkAsyncFunctionReturnType(node) // Async function
                : getTypeFromTypeNode(returnTypeNode)); // normal function
            checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnOrPromisedType);
        }
        if (produceDiagnostics && !returnTypeNode) {
            // Report an implicit any error if there is no body, no explicit return type, and node is not a private method
            // in an ambient context
            if (noImplicitAny && ts.nodeIsMissing(node.body) && !isPrivateWithinAmbient(node)) {
                reportImplicitAnyError(node, anyType);
            }
            if (functionFlags & 1 /* Generator */ && ts.nodeIsPresent(node.body)) {
                // A generator with a body and no type annotation can still cause errors. It can error if the
                // yielded values have no common supertype, or it can give an implicit any error if it has no
                // yielded values. The only way to trigger these errors is to try checking its return type.
                getReturnTypeOfSignature(getSignatureFromDeclaration(node));
            }
        }
        registerForUnusedIdentifiersCheck(node);
    }
    function registerForUnusedIdentifiersCheck(node) {
        if (deferredUnusedIdentifierNodes) {
            deferredUnusedIdentifierNodes.push(node);
        }
    }
    function checkUnusedIdentifiers() {
        if (deferredUnusedIdentifierNodes) {
            for (let _i = 0, deferredUnusedIdentifierNodes_1 = deferredUnusedIdentifierNodes; _i < deferredUnusedIdentifierNodes_1.length; _i++) {
                let node = deferredUnusedIdentifierNodes_1[_i];
                switch (node.kind) {
                    case SyntaxKind.SourceFile:
                    case SyntaxKind.ModuleDeclaration:
                        checkUnusedModuleMembers(node);
                        break;
                    case SyntaxKind.ClassDeclaration:
                    case SyntaxKind.ClassExpression:
                        checkUnusedClassMembers(node);
                        checkUnusedTypeParameters(node);
                        break;
                    case SyntaxKind.InterfaceDeclaration:
                        checkUnusedTypeParameters(node);
                        break;
                    case 207 /* Block */:
                    case 235 /* CaseBlock */:
                    case SyntaxKind.ForStatement:
                    case 215 /* ForInStatement */:
                    case SyntaxKind.ForOfStatement:
                        checkUnusedLocalsAndParameters(node);
                        break;
                    case 152 /* Constructor */:
                    case 186 /* FunctionExpression */:
                    case 228 /* FunctionDeclaration */:
                    case 187 /* ArrowFunction */:
                    case SyntaxKind.MethodDeclaration:
                    case 153 /* GetAccessor */:
                    case 154 /* SetAccessor */:
                        if (node.body) {
                            checkUnusedLocalsAndParameters(node);
                        }
                        checkUnusedTypeParameters(node);
                        break;
                    case 150 /* MethodSignature */:
                    case 155 /* CallSignature */:
                    case 156 /* ConstructSignature */:
                    case 157 /* IndexSignature */:
                    case 160 /* FunctionType */:
                    case 161 /* ConstructorType */:
                        checkUnusedTypeParameters(node);
                        break;
                    case 231 /* TypeAliasDeclaration */:
                        checkUnusedTypeParameters(node);
                        break;
                }
            }
        }
    }
    function checkUnusedLocalsAndParameters(node) {
        if (node.parent.kind !== SyntaxKind.InterfaceDeclaration && noUnusedIdentifiers && !ts.isInAmbientContext(node)) {
            node.locals.forEach(function (local) {
                if (!local.isReferenced) {
                    if (local.valueDeclaration && ts.getRootDeclaration(local.valueDeclaration).kind === SyntaxKind.Parameter) {
                        let parameter = ts.getRootDeclaration(local.valueDeclaration);
                        let name = ts.getNameOfDeclaration(local.valueDeclaration);
                        if (compilerOptions.noUnusedParameters &&
                            !ts.isParameterPropertyDeclaration(parameter) &&
                            !ts.parameterIsThisKeyword(parameter) &&
                            !parameterNameStartsWithUnderscore(name)) {
                            error(name, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, ts.symbolName(local));
                        }
                    }
                    else if (compilerOptions.noUnusedLocals) {
                        ts.forEach(local.declarations, function (d) { return errorUnusedLocal(d, ts.symbolName(local)); });
                    }
                }
            });
        }
    }
    function isRemovedPropertyFromObjectSpread(node) {
        if (ts.isBindingElement(node) && ts.isObjectBindingPattern(node.parent)) {
            let lastElement = ts.lastOrUndefined(node.parent.elements);
            return lastElement !== node && !!lastElement.dotDotDotToken;
        }
        return false;
    }
    function errorUnusedLocal(declaration, name) {
        let node = ts.getNameOfDeclaration(declaration) || declaration;
        if (isIdentifierThatStartsWithUnderScore(node)) {
            let declaration_2 = ts.getRootDeclaration(node.parent);
            if ((declaration_2.kind === SyntaxKind.VariableDeclaration && ts.isForInOrOfStatement(declaration_2.parent.parent)) ||
                declaration_2.kind === SyntaxKind.TypeParameter) {
                return;
            }
        }
        if (!isRemovedPropertyFromObjectSpread(node.kind === 71 /* Identifier */ ? node.parent : node)) {
            error(node, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, name);
        }
    }
    function parameterNameStartsWithUnderscore(parameterName) {
        return parameterName && isIdentifierThatStartsWithUnderScore(parameterName);
    }
    function isIdentifierThatStartsWithUnderScore(node) {
        return node.kind === 71 /* Identifier */ && ts.idText(node).charCodeAt(0) === 95 /* _ */;
    }
    function checkUnusedClassMembers(node) {
        if (compilerOptions.noUnusedLocals && !ts.isInAmbientContext(node)) {
            if (node.members) {
                for (let _i = 0, _a = node.members; _i < _a.length; _i++) {
                    let member = _a[_i];
                    if (member.kind === SyntaxKind.MethodDeclaration || member.kind === SyntaxKind.PropertyDeclaration) {
                        if (!member.symbol.isReferenced && ts.hasModifier(member, 8 /* Private */)) {
                            error(member.name, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, ts.symbolName(member.symbol));
                        }
                    }
                    else if (member.kind === 152 /* Constructor */) {
                        for (let _b = 0, _c = member.parameters; _b < _c.length; _b++) {
                            let parameter = _c[_b];
                            if (!parameter.symbol.isReferenced && ts.hasModifier(parameter, 8 /* Private */)) {
                                error(parameter.name, ts.Diagnostics.Property_0_is_declared_but_its_value_is_never_read, ts.symbolName(parameter.symbol));
                            }
                        }
                    }
                }
            }
        }
    }
    function checkUnusedTypeParameters(node) {
        if (compilerOptions.noUnusedLocals && !ts.isInAmbientContext(node)) {
            if (node.typeParameters) {
                // Only report errors on the last declaration for the type parameter container;
                // this ensures that all uses have been accounted for.
                let symbol = getSymbolOfNode(node);
                let lastDeclaration = symbol && symbol.declarations && ts.lastOrUndefined(symbol.declarations);
                if (lastDeclaration !== node) {
                    return;
                }
                for (let _i = 0, _a = node.typeParameters; _i < _a.length; _i++) {
                    let typeParameter = _a[_i];
                    if (!getMergedSymbol(typeParameter.symbol).isReferenced && !isIdentifierThatStartsWithUnderScore(typeParameter.name)) {
                        error(typeParameter.name, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, ts.symbolName(typeParameter.symbol));
                    }
                }
            }
        }
    }
    function checkUnusedModuleMembers(node) {
        if (compilerOptions.noUnusedLocals && !ts.isInAmbientContext(node)) {
            node.locals.forEach(function (local) {
                if (!local.isReferenced && !local.exportSymbol) {
                    for (let _i = 0, _a = local.declarations; _i < _a.length; _i++) {
                        let declaration = _a[_i];
                        if (!ts.isAmbientModule(declaration)) {
                            errorUnusedLocal(declaration, ts.symbolName(local));
                        }
                    }
                }
            });
        }
    }
    function checkBlock(node) {
        // Grammar checking for SyntaxKind.Block
        if (node.kind === 207 /* Block */) {
            checkGrammarStatementInAmbientContext(node);
        }
        if (ts.isFunctionOrModuleBlock(node)) {
            let saveFlowAnalysisDisabled = flowAnalysisDisabled;
            ts.forEach(node.statements, checkSourceElement);
            flowAnalysisDisabled = saveFlowAnalysisDisabled;
        }
        else {
            ts.forEach(node.statements, checkSourceElement);
        }
        if (node.locals) {
            registerForUnusedIdentifiersCheck(node);
        }
    }
    function checkCollisionWithArgumentsInGeneratedCode(node) {
        // no rest parameters \ declaration context \ overload - no codegen impact
        if (!ts.hasRestParameter(node) || ts.isInAmbientContext(node) || ts.nodeIsMissing(node.body)) {
            return;
        }
        ts.forEach(node.parameters, function (p) {
            if (p.name && !ts.isBindingPattern(p.name) && p.name.escapedText === argumentsSymbol.escapedName) {
                error(p, ts.Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters);
            }
        });
    }
    function needCollisionCheckForIdentifier(node, identifier, name) {
        if (!(identifier && identifier.escapedText === name)) {
            return false;
        }
        if (node.kind === SyntaxKind.PropertyDeclaration ||
            node.kind === SyntaxKind.PropertySignature ||
            node.kind === SyntaxKind.MethodDeclaration ||
            node.kind === 150 /* MethodSignature */ ||
            node.kind === 153 /* GetAccessor */ ||
            node.kind === 154 /* SetAccessor */) {
            // it is ok to have member named '_super' or '_this' - member access is always qualified
            return false;
        }
        if (ts.isInAmbientContext(node)) {
            // ambient context - no codegen impact
            return false;
        }
        let root = ts.getRootDeclaration(node);
        if (root.kind === SyntaxKind.Parameter && ts.nodeIsMissing(root.parent.body)) {
            // just an overload - no codegen impact
            return false;
        }
        return true;
    }
    function checkCollisionWithCapturedThisVariable(node, name) {
        if (needCollisionCheckForIdentifier(node, name, "_this")) {
            potentialThisCollisions.push(node);
        }
    }
    function checkCollisionWithCapturedNewTargetVariable(node, name) {
        if (needCollisionCheckForIdentifier(node, name, "_newTarget")) {
            potentialNewTargetCollisions.push(node);
        }
    }
    // this function will run after checking the source file so 'CaptureThis' is correct for all nodes
    function checkIfThisIsCapturedInEnclosingScope(node) {
        ts.findAncestor(node, function (current) {
            if (getNodeCheckFlags(current) & 4 /* CaptureThis */) {
                let isDeclaration_1 = node.kind !== 71 /* Identifier */;
                if (isDeclaration_1) {
                    error(ts.getNameOfDeclaration(node), ts.Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference);
                }
                else {
                    error(node, ts.Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference);
                }
                return true;
            }
        });
    }
    function checkIfNewTargetIsCapturedInEnclosingScope(node) {
        ts.findAncestor(node, function (current) {
            if (getNodeCheckFlags(current) & 8 /* CaptureNewTarget */) {
                let isDeclaration_2 = node.kind !== 71 /* Identifier */;
                if (isDeclaration_2) {
                    error(ts.getNameOfDeclaration(node), ts.Diagnostics.Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference);
                }
                else {
                    error(node, ts.Diagnostics.Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference);
                }
                return true;
            }
        });
    }
    function checkCollisionWithCapturedSuperVariable(node, name) {
        if (!needCollisionCheckForIdentifier(node, name, "_super")) {
            return;
        }
        // bubble up and find containing type
        let enclosingClass = ts.getContainingClass(node);
        // if containing type was not found or it is ambient - exit (no codegen)
        if (!enclosingClass || ts.isInAmbientContext(enclosingClass)) {
            return;
        }
        if (ts.getClassExtendsHeritageClauseElement(enclosingClass)) {
            let isDeclaration_3 = node.kind !== 71 /* Identifier */;
            if (isDeclaration_3) {
                error(node, ts.Diagnostics.Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference);
            }
            else {
                error(node, ts.Diagnostics.Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference);
            }
        }
    }
    function checkCollisionWithRequireExportsInGeneratedCode(node, name) {
        // No need to check for require or exports for ES6 modules and later
        if (modulekind >= ts.ModuleKind.ES2015) {
            return;
        }
        if (!needCollisionCheckForIdentifier(node, name, "require") && !needCollisionCheckForIdentifier(node, name, "exports")) {
            return;
        }
        // Uninstantiated modules shouldnt do this check
        if (node.kind === SyntaxKind.ModuleDeclaration && ts.getModuleInstanceState(node) !== CheckFlags.Instantiated) {
            return;
        }
        // In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
        let parent = getDeclarationContainer(node);
        if (parent.kind === SyntaxKind.SourceFile && ts.isExternalOrCommonJsModule(parent)) {
            // If the declaration happens to be in external module, report error that require and exports are reserved keywords
            error(name, ts.Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module, ts.declarationNameToString(name), ts.declarationNameToString(name));
        }
    }
    function checkCollisionWithGlobalPromiseInGeneratedCode(node, name) {
        if (languageVersion >= 4 /* ES2017 */ || !needCollisionCheckForIdentifier(node, name, "Promise")) {
            return;
        }
        // Uninstantiated modules shouldnt do this check
        if (node.kind === SyntaxKind.ModuleDeclaration && ts.getModuleInstanceState(node) !== CheckFlags.Instantiated) {
            return;
        }
        // In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
        let parent = getDeclarationContainer(node);
        if (parent.kind === SyntaxKind.SourceFile && ts.isExternalOrCommonJsModule(parent) && parent.flags & 1024 /* HasAsyncFunctions */) {
            // If the declaration happens to be in external module, report error that Promise is a reserved identifier.
            error(name, ts.Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions, ts.declarationNameToString(name), ts.declarationNameToString(name));
        }
    }
    function checkVarDeclaredNamesNotShadowed(node) {
        // - ScriptBody : StatementList
        // It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
        // also occurs in the VarDeclaredNames of StatementList.
        // - Block : { StatementList }
        // It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
        // also occurs in the VarDeclaredNames of StatementList.
        // Variable declarations are hoisted to the top of their function scope. They can shadow
        // block scoped declarations, which bind tighter. this will not be flagged as duplicate definition
        // by the binder as the declaration scope is different.
        // A non-initialized declaration is a no-op as the block declaration will resolve before the var
        // declaration. the problem is if the declaration has an initializer. this will act as a write to the
        // block declared value. this is fine for let, but not const.
        // Only consider declarations with initializers, uninitialized const declarations will not
        // step on a let/const variable.
        // Do not consider const and const declarations, as duplicate block-scoped declarations
        // are handled by the binder.
        // We are only looking for const declarations that step on let\const declarations from a
        // different scope. e.g.:
        //      {
        //          const x = 0; // localDeclarationSymbol obtained after name resolution will correspond to this declaration
        //          const x = 0; // symbol for this declaration will be 'symbol'
        //      }
        // skip block-scoped variables and parameters
        if ((ts.getCombinedNodeFlags(node) & 3 /* BlockScoped */) !== 0 || ts.isParameterDeclaration(node)) {
            return;
        }
        // skip variable declarations that don't have initializers
        // NOTE: in ES6 spec initializer is required in variable declarations where name is binding pattern
        // so we'll always treat binding elements as initialized
        if (node.kind === SyntaxKind.VariableDeclaration && !node.initializer) {
            return;
        }
        let symbol = getSymbolOfNode(node);
        if (symbol.flags & 1 /* FunctionScopedVariable */) {
            if (!ts.isIdentifier(node.name))
                throw ts.Debug.fail();
            let localDeclarationSymbol = resolveName(node, node.name.escapedText, 3 /* Variable */, /*nodeNotFoundErrorMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ false);
            if (localDeclarationSymbol &&
                localDeclarationSymbol !== symbol &&
                localDeclarationSymbol.flags & SymbolFlags.BlockScopedVariable) {
                if (getDeclarationNodeFlagsFromSymbol(localDeclarationSymbol) & 3 /* BlockScoped */) {
                    let varDeclList = ts.getAncestor(localDeclarationSymbol.valueDeclaration, 227 /* VariableDeclarationList */);
                    let container = varDeclList.parent.kind === SyntaxKind.VariableStatement && varDeclList.parent.parent
                        ? varDeclList.parent.parent
                        : undefined;
                    // names of block-scoped and function scoped variables can collide only
                    // if block scoped variable is defined in the function\module\source file scope (because of variable hoisting)
                    let namesShareScope = container &&
                        (container.kind === 207 /* Block */ && ts.isFunctionLike(container.parent) ||
                            container.kind === 234 /* ModuleBlock */ ||
                            container.kind === SyntaxKind.ModuleDeclaration ||
                            container.kind === SyntaxKind.SourceFile);
                    // here we know that function scoped variable is shadowed by block scoped one
                    // if they are defined in the same scope - binder has already reported redeclaration error
                    // otherwise if variable has an initializer - show error that initialization will fail
                    // since LHS will be block scoped name instead of function scoped
                    if (!namesShareScope) {
                        let name = symbolToString(localDeclarationSymbol);
                        error(node, ts.Diagnostics.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1, name, name);
                    }
                }
            }
        }
    }
    // Check that a parameter initializer contains no references to parameters declared to the right of itself
    function checkParameterInitializer(node) {
        if (ts.getRootDeclaration(node).kind !== SyntaxKind.Parameter) {
            return;
        }
        let func = ts.getContainingFunction(node);
        visit(node.initializer);
        function visit(n) {
            if (ts.isTypeNode(n) || ts.isDeclarationName(n)) {
                // do not dive in types
                // skip declaration names (i.e. in object literal expressions)
                return;
            }
            if (n.kind === 179 /* PropertyAccessExpression */) {
                // skip property names in property access expression
                return visit(n.expression);
            }
            else if (n.kind === 71 /* Identifier */) {
                // check FunctionLikeDeclaration.locals (stores parameters\function local variable)
                // if it contains entry with a specified name
                let symbol = resolveName(n, n.escapedText, SymbolFlags.Value | SymbolFlags.Alias, /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ false);
                if (!symbol || symbol === unknownSymbol || !symbol.valueDeclaration) {
                    return;
                }
                if (symbol.valueDeclaration === node) {
                    error(n, ts.Diagnostics.Parameter_0_cannot_be_referenced_in_its_initializer, ts.declarationNameToString(node.name));
                    return;
                }
                // locals map for function contain both parameters and function locals
                // so we need to do a bit of extra work to check if reference is legal
                let enclosingContainer = ts.getEnclosingBlockScopeContainer(symbol.valueDeclaration);
                if (enclosingContainer === func) {
                    if (symbol.valueDeclaration.kind === SyntaxKind.Parameter ||
                        symbol.valueDeclaration.kind === 176 /* BindingElement */) {
                        // it is ok to reference parameter in initializer if either
                        // - parameter is located strictly on the left of current parameter declaration
                        if (symbol.valueDeclaration.pos < node.pos) {
                            return;
                        }
                        // - parameter is wrapped in function-like entity
                        if (ts.findAncestor(n, function (current) {
                            if (current === node.initializer) {
                                return "quit";
                            }
                            return ts.isFunctionLike(current.parent) ||
                                // computed property names/initializers in instance property declaration of class like entities
                                // are executed in constructor and thus deferred
                                (current.parent.kind === SyntaxKind.PropertyDeclaration &&
                                    !(ts.hasModifier(current.parent, ModifierFlags.Static)) &&
                                    ts.isClassLike(current.parent.parent));
                        })) {
                            return;
                        }
                        // fall through to report error
                    }
                    error(n, ts.Diagnostics.Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it, ts.declarationNameToString(node.name), ts.declarationNameToString(n));
                }
            }
            else {
                return ts.forEachChild(n, visit);
            }
        }
    }
    function convertAutoToAny(type) {
        return type === autoType ? anyType : type === autoArrayType ? anyArrayType : type;
    }
    // Check variable, parameter, or property declaration
    function checkVariableLikeDeclaration(node) {
        checkDecorators(node);
        checkSourceElement(node.type);
        // JSDoc `function(string, string): string` syntax results in parameters with no name
        if (!node.name) {
            return;
        }
        // For a computed property, just check the initializer and exit
        // Do not use hasDynamicName here, because that returns false for well known symbols.
        // We want to perform checkComputedPropertyName for all computed properties, including
        // well known symbols.
        if (node.name.kind === 144 /* ComputedPropertyName */) {
            checkComputedPropertyName(node.name);
            if (node.initializer) {
                checkExpressionCached(node.initializer);
            }
        }
        if (node.kind === 176 /* BindingElement */) {
            if (node.parent.kind === 174 /* ObjectBindingPattern */ && languageVersion < 5 /* ESNext */) {
                checkExternalEmitHelpers(node, 4 /* Rest */);
            }
            // check computed properties inside property names of binding elements
            if (node.propertyName && node.propertyName.kind === 144 /* ComputedPropertyName */) {
                checkComputedPropertyName(node.propertyName);
            }
            // check private/protected variable access
            let parent = node.parent.parent;
            let parentType = getTypeForBindingElementParent(parent);
            let name = node.propertyName || node.name;
            let property = getPropertyOfType(parentType, ts.getTextOfPropertyName(name));
            markPropertyAsReferenced(property, /*nodeForCheckWriteOnly*/ undefined, /*isThisAccess*/ false); // A destructuring is never a write-only reference.
            if (parent.initializer && property) {
                checkPropertyAccessibility(parent, parent.initializer, parentType, property);
            }
        }
        // For a binding pattern, check contained binding elements
        if (ts.isBindingPattern(node.name)) {
            if (node.name.kind === 175 /* ArrayBindingPattern */ && languageVersion < 2 /* ES2015 */ && compilerOptions.downlevelIteration) {
                checkExternalEmitHelpers(node, 512 /* Read */);
            }
            ts.forEach(node.name.elements, checkSourceElement);
        }
        // For a parameter declaration with an initializer, error and exit if the containing function doesn't have a body
        if (node.initializer && ts.getRootDeclaration(node).kind === SyntaxKind.Parameter && ts.nodeIsMissing(ts.getContainingFunction(node).body)) {
            error(node, ts.Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation);
            return;
        }
        // For a binding pattern, validate the initializer and exit
        if (ts.isBindingPattern(node.name)) {
            // Don't validate for-in initializer as it is already an error
            if (node.initializer && node.parent.parent.kind !== 215 /* ForInStatement */) {
                checkTypeAssignableTo(checkExpressionCached(node.initializer), getWidenedTypeForVariableLikeDeclaration(node), node, /*headMessage*/ undefined);
                checkParameterInitializer(node);
            }
            return;
        }
        let symbol = getSymbolOfNode(node);
        let type = convertAutoToAny(getTypeOfVariableOrParameterOrProperty(symbol));
        if (node === symbol.valueDeclaration) {
            // Node is the primary declaration of the symbol, just validate the initializer
            // Don't validate for-in initializer as it is already an error
            if (node.initializer && node.parent.parent.kind !== 215 /* ForInStatement */) {
                checkTypeAssignableTo(checkExpressionCached(node.initializer), type, node, /*headMessage*/ undefined);
                checkParameterInitializer(node);
            }
        }
        else {
            // Node is a secondary declaration, check that type is identical to primary declaration and check that
            // initializer is consistent with type associated with the node
            let declarationType = convertAutoToAny(getWidenedTypeForVariableLikeDeclaration(node));
            if (type !== unknownType && declarationType !== unknownType && !isTypeIdenticalTo(type, declarationType)) {
                error(node.name, ts.Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2, ts.declarationNameToString(node.name), typeToString(type), typeToString(declarationType));
            }
            if (node.initializer) {
                checkTypeAssignableTo(checkExpressionCached(node.initializer), declarationType, node, /*headMessage*/ undefined);
            }
            if (!areDeclarationFlagsIdentical(node, symbol.valueDeclaration)) {
                error(ts.getNameOfDeclaration(symbol.valueDeclaration), ts.Diagnostics.All_declarations_of_0_must_have_identical_modifiers, ts.declarationNameToString(node.name));
                error(node.name, ts.Diagnostics.All_declarations_of_0_must_have_identical_modifiers, ts.declarationNameToString(node.name));
            }
        }
        if (node.kind !== SyntaxKind.PropertyDeclaration && node.kind !== SyntaxKind.PropertySignature) {
            // We know we don't have a binding pattern or computed name here
            checkExportsOnMergedDeclarations(node);
            if (node.kind === SyntaxKind.VariableDeclaration || node.kind === 176 /* BindingElement */) {
                checkVarDeclaredNamesNotShadowed(node);
            }
            checkCollisionWithCapturedSuperVariable(node, node.name);
            checkCollisionWithCapturedThisVariable(node, node.name);
            checkCollisionWithCapturedNewTargetVariable(node, node.name);
            checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
            checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name);
        }
    }
    function areDeclarationFlagsIdentical(left, right) {
        if ((left.kind === SyntaxKind.Parameter && right.kind === SyntaxKind.VariableDeclaration) ||
            (left.kind === SyntaxKind.VariableDeclaration && right.kind === SyntaxKind.Parameter)) {
            // Differences in optionality between parameters and variables are allowed.
            return true;
        }
        if (ts.hasQuestionToken(left) !== ts.hasQuestionToken(right)) {
            return false;
        }
        let interestingFlags = 8 /* Private */ |
            16 /* Protected */ |
            256 /* Async */ |
            128 /* Abstract */ |
            64 /* Readonly */ |
            ModifierFlags.Static;
        return ts.getSelectedModifierFlags(left, interestingFlags) === ts.getSelectedModifierFlags(right, interestingFlags);
    }
    function checkVariableDeclaration(node) {
        checkGrammarVariableDeclaration(node);
        return checkVariableLikeDeclaration(node);
    }
    function checkBindingElement(node) {
        checkGrammarBindingElement(node);
        return checkVariableLikeDeclaration(node);
    }
    function checkVariableStatement(node) {
        // Grammar checking
        checkGrammarDecorators(node) || checkGrammarModifiers(node) || checkGrammarVariableDeclarationList(node.declarationList) || checkGrammarForDisallowedLetOrConstStatement(node);
        ts.forEach(node.declarationList.declarations, checkSourceElement);
    }
    function checkGrammarDisallowedModifiersOnObjectLiteralExpressionMethod(node) {
        // We only disallow modifier on a method declaration if it is a property of object-literal-expression
        if (node.modifiers && node.parent.kind === 178 /* ObjectLiteralExpression */) {
            if (ts.getFunctionFlags(node) & 2 /* Async */) {
                if (node.modifiers.length > 1) {
                    return grammarErrorOnFirstToken(node, ts.Diagnostics.Modifiers_cannot_appear_here);
                }
            }
            else {
                return grammarErrorOnFirstToken(node, ts.Diagnostics.Modifiers_cannot_appear_here);
            }
        }
    }
    function checkExpressionStatement(node) {
        // Grammar checking
        checkGrammarStatementInAmbientContext(node);
        checkExpression(node.expression);
    }
    function checkIfStatement(node) {
        // Grammar checking
        checkGrammarStatementInAmbientContext(node);
        checkExpression(node.expression);
        checkSourceElement(node.thenStatement);
        if (node.thenStatement.kind === 209 /* EmptyStatement */) {
            error(node.thenStatement, ts.Diagnostics.The_body_of_an_if_statement_cannot_be_the_empty_statement);
        }
        checkSourceElement(node.elseStatement);
    }
    function checkDoStatement(node) {
        // Grammar checking
        checkGrammarStatementInAmbientContext(node);
        checkSourceElement(node.statement);
        checkExpression(node.expression);
    }
    function checkWhileStatement(node) {
        // Grammar checking
        checkGrammarStatementInAmbientContext(node);
        checkExpression(node.expression);
        checkSourceElement(node.statement);
    }
    function checkForStatement(node) {
        // Grammar checking
        if (!checkGrammarStatementInAmbientContext(node)) {
            if (node.initializer && node.initializer.kind === 227 /* VariableDeclarationList */) {
                checkGrammarVariableDeclarationList(node.initializer);
            }
        }
        if (node.initializer) {
            if (node.initializer.kind === 227 /* VariableDeclarationList */) {
                ts.forEach(node.initializer.declarations, checkVariableDeclaration);
            }
            else {
                checkExpression(node.initializer);
            }
        }
        if (node.condition)
            checkExpression(node.condition);
        if (node.incrementor)
            checkExpression(node.incrementor);
        checkSourceElement(node.statement);
        if (node.locals) {
            registerForUnusedIdentifiersCheck(node);
        }
    }
    function checkForOfStatement(node) {
        checkGrammarForInOrForOfStatement(node);
        if (node.kind === SyntaxKind.ForOfStatement) {
            if (node.awaitModifier) {
                let functionFlags = ts.getFunctionFlags(ts.getContainingFunction(node));
                if ((functionFlags & (4 /* Invalid */ | 2 /* Async */)) === 2 /* Async */ && languageVersion < 5 /* ESNext */) {
                    // for..await..of in an async function or async generator function prior to ESNext requires the __asyncValues helper
                    checkExternalEmitHelpers(node, 16384 /* ForAwaitOfIncludes */);
                }
            }
            else if (compilerOptions.downlevelIteration && languageVersion < 2 /* ES2015 */) {
                // for..of prior to ES2015 requires the __values helper when downlevelIteration is enabled
                checkExternalEmitHelpers(node, 256 /* ForOfIncludes */);
            }
        }
        // Check the LHS and RHS
        // If the LHS is a declaration, just check it as a variable declaration, which will in turn check the RHS
        // via checkRightHandSideOfForOf.
        // If the LHS is an expression, check the LHS, as a destructuring assignment or as a reference.
        // Then check that the RHS is assignable to it.
        if (node.initializer.kind === 227 /* VariableDeclarationList */) {
            checkForInOrForOfVariableDeclaration(node);
        }
        else {
            let varExpr = node.initializer;
            let iteratedType = checkRightHandSideOfForOf(node.expression, node.awaitModifier);
            // There may be a destructuring assignment on the left side
            if (varExpr.kind === 177 /* ArrayLiteralExpression */ || varExpr.kind === 178 /* ObjectLiteralExpression */) {
                // iteratedType may be undefined. In this case, we still want to check the structure of
                // varExpr, in particular making sure it's a valid LeftHandSideExpression. But we'd like
                // to short circuit the type relation checking as much as possible, so we pass the unknownType.
                checkDestructuringAssignment(varExpr, iteratedType || unknownType);
            }
            else {
                let leftType = checkExpression(varExpr);
                checkReferenceExpression(varExpr, ts.Diagnostics.The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access);
                // iteratedType will be undefined if the rightType was missing properties/signatures
                // required to get its iteratedType (like [Symbol.iterator] or next). This may be
                // because we accessed properties from anyType, or it may have led to an error inside
                // getElementTypeOfIterable.
                if (iteratedType) {
                    checkTypeAssignableTo(iteratedType, leftType, varExpr, /*headMessage*/ undefined);
                }
            }
        }
        checkSourceElement(node.statement);
        if (node.locals) {
            registerForUnusedIdentifiersCheck(node);
        }
    }
    function checkForInStatement(node) {
        // Grammar checking
        checkGrammarForInOrForOfStatement(node);
        let rightType = checkNonNullExpression(node.expression);
        // TypeScript 1.0 spec  (April 2014): 5.4
        // In a 'for-in' statement of the form
        // for (let VarDecl in Expr) Statement
        //   VarDecl must be a variable declaration without a type annotation that declares a variable of type Any,
        //   and Expr must be an expression of type Any, an object type, or a type parameter type.
        if (node.initializer.kind === 227 /* VariableDeclarationList */) {
            let variable = node.initializer.declarations[0];
            if (variable && ts.isBindingPattern(variable.name)) {
                error(variable.name, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
            }
            checkForInOrForOfVariableDeclaration(node);
        }
        else {
            // In a 'for-in' statement of the form
            // for (let in Expr) Statement
            //   let must be an expression classified as a reference of type Any or the String primitive type,
            //   and Expr must be an expression of type Any, an object type, or a type parameter type.
            let varExpr = node.initializer;
            let leftType = checkExpression(varExpr);
            if (varExpr.kind === 177 /* ArrayLiteralExpression */ || varExpr.kind === 178 /* ObjectLiteralExpression */) {
                error(varExpr, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
            }
            else if (!isTypeAssignableTo(getIndexTypeOrString(rightType), leftType)) {
                error(varExpr, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any);
            }
            else {
                // run check only former check succeeded to avoid cascading errors
                checkReferenceExpression(varExpr, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access);
            }
        }
        // unknownType is returned i.e. if node.expression is identifier whose name cannot be resolved
        // in this case error about missing name is already reported - do not report extra one
        if (!isTypeAssignableToKind(rightType, 16777216 /* NonPrimitive */ | 540672 /* TypeVariable */)) {
            error(node.expression, ts.Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter);
        }
        checkSourceElement(node.statement);
        if (node.locals) {
            registerForUnusedIdentifiersCheck(node);
        }
    }
    function checkForInOrForOfVariableDeclaration(iterationStatement) {
        let variableDeclarationList = iterationStatement.initializer;
        // checkGrammarForInOrForOfStatement will check that there is exactly one declaration.
        if (variableDeclarationList.declarations.length >= 1) {
            let decl = variableDeclarationList.declarations[0];
            checkVariableDeclaration(decl);
        }
    }
    function checkRightHandSideOfForOf(rhsExpression, awaitModifier) {
        let expressionType = checkNonNullExpression(rhsExpression);
        return checkIteratedTypeOrElementType(expressionType, rhsExpression, /*allowStringInput*/ true, awaitModifier !== undefined);
    }
    function checkIteratedTypeOrElementType(inputType, errorNode, allowStringInput, allowAsyncIterables) {
        if (isTypeAny(inputType)) {
            return inputType;
        }
        return getIteratedTypeOrElementType(inputType, errorNode, allowStringInput, allowAsyncIterables, /*checkAssignability*/ true) || anyType;
    }
    /**
     * When consuming an iterable type in a for..of, spread, or iterator destructuring assignment
     * we want to get the iterated type of an iterable for ES2015 or later, or the iterated type
     * of a iterable (if defined globally) or element type of an array like for ES2015 or earlier.
     */
    function getIteratedTypeOrElementType(inputType, errorNode, allowStringInput, allowAsyncIterables, checkAssignability) {
        let uplevelIteration = languageVersion >= 2 /* ES2015 */;
        let downlevelIteration = !uplevelIteration && compilerOptions.downlevelIteration;
        // Get the iterated type of an `Iterable<T>` or `IterableIterator<T>` only in ES2015
        // or higher, when inside of an async generator or for-await-if, or when
        // downlevelIteration is requested.
        if (uplevelIteration || downlevelIteration || allowAsyncIterables) {
            // We only report errors for an invalid iterable type in ES2015 or higher.
            let iteratedType = getIteratedTypeOfIterable(inputType, uplevelIteration ? errorNode : undefined, allowAsyncIterables, /*allowSyncIterables*/ true, checkAssignability);
            if (iteratedType || uplevelIteration) {
                return iteratedType;
            }
        }
        let arrayType = inputType;
        let reportedError = false;
        let hasStringConstituent = false;
        // If strings are permitted, remove any string-like constituents from the array type.
        // This allows us to find other non-string element types from an array unioned with
        // a string.
        if (allowStringInput) {
            if (arrayType.flags & 65536 /* Union */) {
                // After we remove all types that are StringLike, we will know if there was a string constituent
                // based on whether the result of filter is a new array.
                let arrayTypes = inputType.types;
                let filteredTypes = ts.filter(arrayTypes, function (t) { return !(t.flags & 262178 /* StringLike */); });
                if (filteredTypes !== arrayTypes) {
                    arrayType = getUnionType(filteredTypes, /*subtypeReduction*/ true);
                }
            }
            else if (arrayType.flags & 262178 /* StringLike */) {
                arrayType = neverType;
            }
            hasStringConstituent = arrayType !== inputType;
            if (hasStringConstituent) {
                if (languageVersion < 1 /* ES5 */) {
                    if (errorNode) {
                        error(errorNode, ts.Diagnostics.Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher);
                        reportedError = true;
                    }
                }
                // Now that we've removed all the StringLike types, if no constituents remain, then the entire
                // arrayOrStringType was a string.
                if (arrayType.flags & 8192 /* Never */) {
                    return stringType;
                }
            }
        }
        if (!isArrayLikeType(arrayType)) {
            if (errorNode && !reportedError) {
                // Which error we report depends on whether we allow strings or if there was a
                // string constituent. For example, if the input type is number | string, we
                // want to say that number is not an array type. But if the input was just
                // number and string input is allowed, we want to say that number is not an
                // array type or a string type.
                let diagnostic = !allowStringInput || hasStringConstituent
                    ? downlevelIteration
                        ? ts.Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator
                        : ts.Diagnostics.Type_0_is_not_an_array_type
                    : downlevelIteration
                        ? ts.Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator
                        : ts.Diagnostics.Type_0_is_not_an_array_type_or_a_string_type;
                error(errorNode, diagnostic, typeToString(arrayType));
            }
            return hasStringConstituent ? stringType : undefined;
        }
        let arrayElementType = getIndexTypeOfType(arrayType, 1 /* Number */);
        if (hasStringConstituent && arrayElementType) {
            // This is just an optimization for the case where arrayOrStringType is string | string[]
            if (arrayElementType.flags & 262178 /* StringLike */) {
                return stringType;
            }
            return getUnionType([arrayElementType, stringType], /*subtypeReduction*/ true);
        }
        return arrayElementType;
    }
    /**
     * We want to treat type as an iterable, and get the type it is an iterable of. The iterable
     * must have the following structure (annotated with the names of the variables below):
     *
     *     { // iterable
     *         [Symbol.iterator]: { // iteratorMethod
     *             (): Iterator<T>
     *         }
     *     }
     *
     * For an async iterable, we expect the following structure:
     *
     *     { // iterable
     *         [Symbol.asyncIterator]: { // iteratorMethod
     *             (): AsyncIterator<T>
     *         }
     *     }
     *
     * T is the type we are after. At every level that involves analyzing return types
     * of signatures, we union the return types of all the signatures.
     *
     * Another thing to note is that at any step of this process, we could run into a dead end,
     * meaning either the property is missing, or we run into the anyType. If either of these things
     * happens, we return undefined to signal that we could not find the iterated type. If a property
     * is missing, and the previous step did not result in 'any', then we also give an error if the
     * caller requested it. Then the caller can decide what to do in the case where there is no iterated
     * type. This is different from returning anyType, because that would signify that we have matched the
     * whole pattern and that T (above) is 'any'.
     *
     * For a **for-of** statement, `yield*` (in a normal generator), spread, array
     * destructuring, or normal generator we will only ever look for a `[Symbol.iterator]()`
     * method.
     *
     * For an async generator we will only ever look at the `[Symbol.asyncIterator]()` method.
     *
     * For a **for-await-of** statement or a `yield*` in an async generator we will look for
     * the `[Symbol.asyncIterator]()` method first, and then the `[Symbol.iterator]()` method.
     */
    function getIteratedTypeOfIterable(type, errorNode, allowAsyncIterables, allowSyncIterables, checkAssignability) {
        if (isTypeAny(type)) {
            return undefined;
        }
        return mapType(type, getIteratedType);
        function getIteratedType(type) {
            let typeAsIterable = type;
            if (allowAsyncIterables) {
                if (typeAsIterable.iteratedTypeOfAsyncIterable) {
                    return typeAsIterable.iteratedTypeOfAsyncIterable;
                }
                // As an optimization, if the type is an instantiation of the global `AsyncIterable<T>`
                // or the global `AsyncIterableIterator<T>` then just grab its type argument.
                if (isReferenceToType(type, getGlobalAsyncIterableType(/*reportErrors*/ false)) ||
                    isReferenceToType(type, getGlobalAsyncIterableIteratorType(/*reportErrors*/ false))) {
                    return typeAsIterable.iteratedTypeOfAsyncIterable = type.typeArguments[0];
                }
            }
            if (allowSyncIterables) {
                if (typeAsIterable.iteratedTypeOfIterable) {
                    return typeAsIterable.iteratedTypeOfIterable;
                }
                // As an optimization, if the type is an instantiation of the global `Iterable<T>` or
                // `IterableIterator<T>` then just grab its type argument.
                if (isReferenceToType(type, getGlobalIterableType(/*reportErrors*/ false)) ||
                    isReferenceToType(type, getGlobalIterableIteratorType(/*reportErrors*/ false))) {
                    return typeAsIterable.iteratedTypeOfIterable = type.typeArguments[0];
                }
            }
            let asyncMethodType = allowAsyncIterables && getTypeOfPropertyOfType(type, ts.getPropertyNameForKnownSymbolName("asyncIterator"));
            let methodType = asyncMethodType || (allowSyncIterables && getTypeOfPropertyOfType(type, ts.getPropertyNameForKnownSymbolName("iterator")));
            if (isTypeAny(methodType)) {
                return undefined;
            }
            let signatures = methodType && getSignaturesOfType(methodType, 0 /* Call */);
            if (!ts.some(signatures)) {
                if (errorNode) {
                    error(errorNode, allowAsyncIterables
                        ? ts.Diagnostics.Type_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator
                        : ts.Diagnostics.Type_must_have_a_Symbol_iterator_method_that_returns_an_iterator);
                    // only report on the first error
                    errorNode = undefined;
                }
                return undefined;
            }
            let returnType = getUnionType(ts.map(signatures, getReturnTypeOfSignature), /*subtypeReduction*/ true);
            let iteratedType = getIteratedTypeOfIterator(returnType, errorNode, /*isAsyncIterator*/ !!asyncMethodType);
            if (checkAssignability && errorNode && iteratedType) {
                // If `checkAssignability` was specified, we were called from
                // `checkIteratedTypeOrElementType`. As such, we need to validate that
                // the type passed in is actually an Iterable.
                checkTypeAssignableTo(type, asyncMethodType
                    ? createAsyncIterableType(iteratedType)
                    : createIterableType(iteratedType), errorNode);
            }
            return asyncMethodType
                ? typeAsIterable.iteratedTypeOfAsyncIterable = iteratedType
                : typeAsIterable.iteratedTypeOfIterable = iteratedType;
        }
    }
    /**
     * This function has very similar logic as getIteratedTypeOfIterable, except that it operates on
     * Iterators instead of Iterables. Here is the structure:
     *
     *  { // iterator
     *      next: { // nextMethod
     *          (): { // nextResult
     *              value: T // nextValue
     *          }
     *      }
     *  }
     *
     * For an async iterator, we expect the following structure:
     *
     *  { // iterator
     *      next: { // nextMethod
     *          (): PromiseLike<{ // nextResult
     *              value: T // nextValue
     *          }>
     *      }
     *  }
     */
    function getIteratedTypeOfIterator(type, errorNode, isAsyncIterator) {
        if (isTypeAny(type)) {
            return undefined;
        }
        let typeAsIterator = type;
        if (isAsyncIterator ? typeAsIterator.iteratedTypeOfAsyncIterator : typeAsIterator.iteratedTypeOfIterator) {
            return isAsyncIterator ? typeAsIterator.iteratedTypeOfAsyncIterator : typeAsIterator.iteratedTypeOfIterator;
        }
        // As an optimization, if the type is an instantiation of the global `Iterator<T>` (for
        // a non-async iterator) or the global `AsyncIterator<T>` (for an async-iterator) then
        // just grab its type argument.
        let getIteratorType = isAsyncIterator ? getGlobalAsyncIteratorType : getGlobalIteratorType;
        if (isReferenceToType(type, getIteratorType(/*reportErrors*/ false))) {
            return isAsyncIterator
                ? typeAsIterator.iteratedTypeOfAsyncIterator = type.typeArguments[0]
                : typeAsIterator.iteratedTypeOfIterator = type.typeArguments[0];
        }
        // Both async and non-async iterators must have a `next` method.
        let nextMethod = getTypeOfPropertyOfType(type, "next");
        if (isTypeAny(nextMethod)) {
            return undefined;
        }
        let nextMethodSignatures = nextMethod ? getSignaturesOfType(nextMethod, 0 /* Call */) : ts.emptyArray;
        if (nextMethodSignatures.length === 0) {
            if (errorNode) {
                error(errorNode, isAsyncIterator
                    ? ts.Diagnostics.An_async_iterator_must_have_a_next_method
                    : ts.Diagnostics.An_iterator_must_have_a_next_method);
            }
            return undefined;
        }
        let nextResult = getUnionType(ts.map(nextMethodSignatures, getReturnTypeOfSignature), /*subtypeReduction*/ true);
        if (isTypeAny(nextResult)) {
            return undefined;
        }
        // For an async iterator, we must get the awaited type of the return type.
        if (isAsyncIterator) {
            nextResult = getAwaitedTypeOfPromise(nextResult, errorNode, ts.Diagnostics.The_type_returned_by_the_next_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property);
            if (isTypeAny(nextResult)) {
                return undefined;
            }
        }
        let nextValue = nextResult && getTypeOfPropertyOfType(nextResult, "value");
        if (!nextValue) {
            if (errorNode) {
                error(errorNode, isAsyncIterator
                    ? ts.Diagnostics.The_type_returned_by_the_next_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property
                    : ts.Diagnostics.The_type_returned_by_the_next_method_of_an_iterator_must_have_a_value_property);
            }
            return undefined;
        }
        return isAsyncIterator
            ? typeAsIterator.iteratedTypeOfAsyncIterator = nextValue
            : typeAsIterator.iteratedTypeOfIterator = nextValue;
    }
    /**
     * A generator may have a return type of `Iterator<T>`, `Iterable<T>`, or
     * `IterableIterator<T>`. An async generator may have a return type of `AsyncIterator<T>`,
     * `AsyncIterable<T>`, or `AsyncIterableIterator<T>`. This function can be used to extract
     * the iterated type from this return type for contextual typing and verifying signatures.
     */
    function getIteratedTypeOfGenerator(returnType, isAsyncGenerator) {
        if (isTypeAny(returnType)) {
            return undefined;
        }
        return getIteratedTypeOfIterable(returnType, /*errorNode*/ undefined, /*allowAsyncIterables*/ isAsyncGenerator, /*allowSyncIterables*/ !isAsyncGenerator, /*checkAssignability*/ false)
            || getIteratedTypeOfIterator(returnType, /*errorNode*/ undefined, isAsyncGenerator);
    }
    function checkBreakOrContinueStatement(node) {
        // Grammar checking
        checkGrammarStatementInAmbientContext(node) || checkGrammarBreakOrContinueStatement(node);
        // TODO: Check that target label is valid
    }
    function isGetAccessorWithAnnotatedSetAccessor(node) {
        return node.kind === 153 /* GetAccessor */
            && ts.getEffectiveSetAccessorTypeAnnotationNode(ts.getDeclarationOfKind(node.symbol, 154 /* SetAccessor */)) !== undefined;
    }
    function isUnwrappedReturnTypeVoidOrAny(func, returnType) {
        let unwrappedReturnType = (ts.getFunctionFlags(func) & 3 /* AsyncGenerator */) === 2 /* Async */
            ? getPromisedTypeOfPromise(returnType) // Async function
            : returnType; // AsyncGenerator function, Generator function, or normal function
        return unwrappedReturnType && maybeTypeOfKind(unwrappedReturnType, 1024 /* Void */ | 1 /* Any */);
    }
    function checkReturnStatement(node) {
        // Grammar checking
        if (!checkGrammarStatementInAmbientContext(node)) {
            let functionBlock = ts.getContainingFunction(node);
            if (!functionBlock) {
                grammarErrorOnFirstToken(node, ts.Diagnostics.A_return_statement_can_only_be_used_within_a_function_body);
            }
        }
        let func = ts.getContainingFunction(node);
        if (func) {
            let signature = getSignatureFromDeclaration(func);
            let returnType = getReturnTypeOfSignature(signature);
            if (strictNullChecks || node.expression || returnType.flags & 8192 /* Never */) {
                let exprType = node.expression ? checkExpressionCached(node.expression) : undefinedType;
                let functionFlags = ts.getFunctionFlags(func);
                if (functionFlags & 1 /* Generator */) {
                    // A generator does not need its return expressions checked against its return type.
                    // Instead, the yield expressions are checked against the element type.
                    // TODO: Check return expressions of generators when return type tracking is added
                    // for generators.
                    return;
                }
                if (func.kind === 154 /* SetAccessor */) {
                    if (node.expression) {
                        error(node, ts.Diagnostics.Setters_cannot_return_a_value);
                    }
                }
                else if (func.kind === 152 /* Constructor */) {
                    if (node.expression && !checkTypeAssignableTo(exprType, returnType, node)) {
                        error(node, ts.Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class);
                    }
                }
                else if (ts.getEffectiveReturnTypeNode(func) || isGetAccessorWithAnnotatedSetAccessor(func)) {
                    if (functionFlags & 2 /* Async */) {
                        let promisedType = getPromisedTypeOfPromise(returnType);
                        let awaitedType = checkAwaitedType(exprType, node, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
                        if (promisedType) {
                            // If the function has a return type, but promisedType is
                            // undefined, an error will be reported in checkAsyncFunctionReturnType
                            // so we don't need to report one here.
                            checkTypeAssignableTo(awaitedType, promisedType, node);
                        }
                    }
                    else {
                        checkTypeAssignableTo(exprType, returnType, node);
                    }
                }
            }
            else if (func.kind !== 152 /* Constructor */ && compilerOptions.noImplicitReturns && !isUnwrappedReturnTypeVoidOrAny(func, returnType)) {
                // The function has a return type, but the return statement doesn't have an expression.
                error(node, ts.Diagnostics.Not_all_code_paths_return_a_value);
            }
        }
    }
    function checkWithStatement(node) {
        // Grammar checking for withStatement
        if (!checkGrammarStatementInAmbientContext(node)) {
            if (node.flags & 16384 /* AwaitContext */) {
                grammarErrorOnFirstToken(node, ts.Diagnostics.with_statements_are_not_allowed_in_an_async_function_block);
            }
        }
        checkExpression(node.expression);
        let sourceFile = ts.getSourceFileOfNode(node);
        if (!hasParseDiagnostics(sourceFile)) {
            let start = ts.getSpanOfTokenAtPosition(sourceFile, node.pos).start;
            let end = node.statement.pos;
            grammarErrorAtPos(sourceFile, start, end - start, ts.Diagnostics.The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any);
        }
    }
    function checkSwitchStatement(node) {
        // Grammar checking
        checkGrammarStatementInAmbientContext(node);
        let firstDefaultClause;
        let hasDuplicateDefaultClause = false;
        let expressionType = checkExpression(node.expression);
        let expressionIsLiteral = isLiteralType(expressionType);
        ts.forEach(node.caseBlock.clauses, function (clause) {
            // Grammar check for duplicate default clauses, skip if we already report duplicate default clause
            if (clause.kind === 261 /* DefaultClause */ && !hasDuplicateDefaultClause) {
                if (firstDefaultClause === undefined) {
                    firstDefaultClause = clause;
                }
                else {
                    let sourceFile = ts.getSourceFileOfNode(node);
                    let start = ts.skipTrivia(sourceFile.text, clause.pos);
                    let end = clause.statements.length > 0 ? clause.statements[0].pos : clause.end;
                    grammarErrorAtPos(sourceFile, start, end - start, ts.Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement);
                    hasDuplicateDefaultClause = true;
                }
            }
            if (produceDiagnostics && clause.kind === 260 /* CaseClause */) {
                let caseClause = clause;
                // TypeScript 1.0 spec (April 2014): 5.9
                // In a 'switch' statement, each 'case' expression must be of a type that is comparable
                // to or from the type of the 'switch' expression.
                let caseType = checkExpression(caseClause.expression);
                let caseIsLiteral = isLiteralType(caseType);
                let comparedExpressionType = expressionType;
                if (!caseIsLiteral || !expressionIsLiteral) {
                    caseType = caseIsLiteral ? getBaseTypeOfLiteralType(caseType) : caseType;
                    comparedExpressionType = getBaseTypeOfLiteralType(expressionType);
                }
                if (!isTypeEqualityComparableTo(comparedExpressionType, caseType)) {
                    // expressionType is not comparable to caseType, try the reversed check and report errors if it fails
                    checkTypeComparableTo(caseType, comparedExpressionType, caseClause.expression, /*headMessage*/ undefined);
                }
            }
            ts.forEach(clause.statements, checkSourceElement);
        });
        if (node.caseBlock.locals) {
            registerForUnusedIdentifiersCheck(node.caseBlock);
        }
    }
    function checkLabeledStatement(node) {
        // Grammar checking
        if (!checkGrammarStatementInAmbientContext(node)) {
            ts.findAncestor(node.parent, function (current) {
                if (ts.isFunctionLike(current)) {
                    return "quit";
                }
                if (current.kind === 222 /* LabeledStatement */ && current.label.escapedText === node.label.escapedText) {
                    let sourceFile = ts.getSourceFileOfNode(node);
                    grammarErrorOnNode(node.label, ts.Diagnostics.Duplicate_label_0, ts.getTextOfNodeFromSourceText(sourceFile.text, node.label));
                    return true;
                }
            });
        }
        // ensure that label is unique
        checkSourceElement(node.statement);
    }
    function checkThrowStatement(node) {
        // Grammar checking
        if (!checkGrammarStatementInAmbientContext(node)) {
            if (node.expression === undefined) {
                grammarErrorAfterFirstToken(node, ts.Diagnostics.Line_break_not_permitted_here);
            }
        }
        if (node.expression) {
            checkExpression(node.expression);
        }
    }
    function checkTryStatement(node) {
        // Grammar checking
        checkGrammarStatementInAmbientContext(node);
        checkBlock(node.tryBlock);
        let catchClause = node.catchClause;
        if (catchClause) {
            // Grammar checking
            if (catchClause.variableDeclaration) {
                if (catchClause.variableDeclaration.type) {
                    grammarErrorOnFirstToken(catchClause.variableDeclaration.type, ts.Diagnostics.Catch_clause_variable_cannot_have_a_type_annotation);
                }
                else if (catchClause.variableDeclaration.initializer) {
                    grammarErrorOnFirstToken(catchClause.variableDeclaration.initializer, ts.Diagnostics.Catch_clause_variable_cannot_have_an_initializer);
                }
                else {
                    let blockLocals_1 = catchClause.block.locals;
                    if (blockLocals_1) {
                        ts.forEachKey(catchClause.locals, function (caughtName) {
                            let blockLocal = blockLocals_1.get(caughtName);
                            if (blockLocal && (blockLocal.flags & SymbolFlags.BlockScopedVariable) !== 0) {
                                grammarErrorOnNode(blockLocal.valueDeclaration, ts.Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause, caughtName);
                            }
                        });
                    }
                }
            }
            checkBlock(catchClause.block);
        }
        if (node.finallyBlock) {
            checkBlock(node.finallyBlock);
        }
    }
    function checkIndexConstraints(type) {
        let declaredNumberIndexer = getIndexDeclarationOfSymbol(type.symbol, 1 /* Number */);
        let declaredStringIndexer = getIndexDeclarationOfSymbol(type.symbol, 0 /* String */);
        let stringIndexType = getIndexTypeOfType(type, 0 /* String */);
        let numberIndexType = getIndexTypeOfType(type, 1 /* Number */);
        if (stringIndexType || numberIndexType) {
            ts.forEach(getPropertiesOfObjectType(type), function (prop) {
                let propType = getTypeOfSymbol(prop);
                checkIndexConstraintForProperty(prop, propType, type, declaredStringIndexer, stringIndexType, 0 /* String */);
                checkIndexConstraintForProperty(prop, propType, type, declaredNumberIndexer, numberIndexType, 1 /* Number */);
            });
            if (getObjectFlags(type) & 1 /* Class */ && ts.isClassLike(type.symbol.valueDeclaration)) {
                let classDeclaration = type.symbol.valueDeclaration;
                for (let _i = 0, _a = classDeclaration.members; _i < _a.length; _i++) {
                    let member = _a[_i];
                    // Only process instance properties with computed names here.
                    // Static properties cannot be in conflict with indexers,
                    // and properties with literal names were already checked.
                    if (!ts.hasModifier(member, ModifierFlags.Static) && ts.hasDynamicName(member)) {
                        let propType = getTypeOfSymbol(member.symbol);
                        checkIndexConstraintForProperty(member.symbol, propType, type, declaredStringIndexer, stringIndexType, 0 /* String */);
                        checkIndexConstraintForProperty(member.symbol, propType, type, declaredNumberIndexer, numberIndexType, 1 /* Number */);
                    }
                }
            }
        }
        let errorNode;
        if (stringIndexType && numberIndexType) {
            errorNode = declaredNumberIndexer || declaredStringIndexer;
            // condition 'errorNode === undefined' may appear if types does not declare nor string neither number indexer
            if (!errorNode && (getObjectFlags(type) & 2 /* Interface */)) {
                let someBaseTypeHasBothIndexers = ts.forEach(getBaseTypes(type), function (base) { return getIndexTypeOfType(base, 0 /* String */) && getIndexTypeOfType(base, 1 /* Number */); });
                errorNode = someBaseTypeHasBothIndexers ? undefined : type.symbol.declarations[0];
            }
        }
        if (errorNode && !isTypeAssignableTo(numberIndexType, stringIndexType)) {
            error(errorNode, ts.Diagnostics.Numeric_index_type_0_is_not_assignable_to_string_index_type_1, typeToString(numberIndexType), typeToString(stringIndexType));
        }
        function checkIndexConstraintForProperty(prop, propertyType, containingType, indexDeclaration, indexType, indexKind) {
            if (!indexType) {
                return;
            }
            let propDeclaration = prop.valueDeclaration;
            // index is numeric and property name is not valid numeric literal
            if (indexKind === 1 /* Number */ && !(propDeclaration ? isNumericName(ts.getNameOfDeclaration(propDeclaration)) : isNumericLiteralName(prop.escapedName))) {
                return;
            }
            // perform property check if property or indexer is declared in 'type'
            // this allows us to rule out cases when both property and indexer are inherited from the base class
            let errorNode;
            if (propDeclaration &&
                (propDeclaration.kind === 194 /* BinaryExpression */ ||
                    ts.getNameOfDeclaration(propDeclaration).kind === 144 /* ComputedPropertyName */ ||
                    prop.parent === containingType.symbol)) {
                errorNode = propDeclaration;
            }
            else if (indexDeclaration) {
                errorNode = indexDeclaration;
            }
            else if (getObjectFlags(containingType) & 2 /* Interface */) {
                // for interfaces property and indexer might be inherited from different bases
                // check if any base class already has both property and indexer.
                // check should be performed only if 'type' is the first type that brings property\indexer together
                let someBaseClassHasBothPropertyAndIndexer = ts.forEach(getBaseTypes(containingType), function (base) { return getPropertyOfObjectType(base, prop.escapedName) && getIndexTypeOfType(base, indexKind); });
                errorNode = someBaseClassHasBothPropertyAndIndexer ? undefined : containingType.symbol.declarations[0];
            }
            if (errorNode && !isTypeAssignableTo(propertyType, indexType)) {
                let errorMessage = indexKind === 0 /* String */
                    ? ts.Diagnostics.Property_0_of_type_1_is_not_assignable_to_string_index_type_2
                    : ts.Diagnostics.Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2;
                error(errorNode, errorMessage, symbolToString(prop), typeToString(propertyType), typeToString(indexType));
            }
        }
    }
    function checkTypeNameIsReserved(name, message) {
        // TS 1.0 spec (April 2014): 3.6.1
        // The predefined type keywords are reserved and cannot be used as names of user defined types.
        switch (name.escapedText) {
            case "any":
            case "number":
            case "boolean":
            case "string":
            case "symbol":
            case "void":
            case "object":
                error(name, message, name.escapedText);
        }
    }
    /**
     * Check each type parameter and check that type parameters have no duplicate type parameter declarations
     */
    function checkTypeParameters(typeParameterDeclarations) {
        if (typeParameterDeclarations) {
            let seenDefault = false;
            for (let i = 0; i < typeParameterDeclarations.length; i++) {
                let node = typeParameterDeclarations[i];
                checkTypeParameter(node);
                if (produceDiagnostics) {
                    if (node.default) {
                        seenDefault = true;
                    }
                    else if (seenDefault) {
                        error(node, ts.Diagnostics.Required_type_parameters_may_not_follow_optional_type_parameters);
                    }
                    for (let j = 0; j < i; j++) {
                        if (typeParameterDeclarations[j].symbol === node.symbol) {
                            error(node.name, ts.Diagnostics.Duplicate_identifier_0, ts.declarationNameToString(node.name));
                        }
                    }
                }
            }
        }
    }
    /** Check that type parameter lists are identical across multiple declarations */
    function checkTypeParameterListsIdentical(symbol) {
        if (symbol.declarations.length === 1) {
            return;
        }
        let links = getSymbolLinks(symbol);
        if (!links.typeParametersChecked) {
            links.typeParametersChecked = true;
            let declarations = getClassOrInterfaceDeclarationsOfSymbol(symbol);
            if (declarations.length <= 1) {
                return;
            }
            let type = getDeclaredTypeOfSymbol(symbol);
            if (!areTypeParametersIdentical(declarations, type.localTypeParameters)) {
                // Report an error on every conflicting declaration.
                let name = symbolToString(symbol);
                for (let _i = 0, declarations_5 = declarations; _i < declarations_5.length; _i++) {
                    let declaration = declarations_5[_i];
                    error(declaration.name, ts.Diagnostics.All_declarations_of_0_must_have_identical_type_parameters, name);
                }
            }
        }
    }
    function areTypeParametersIdentical(declarations, typeParameters) {
        let maxTypeArgumentCount = ts.length(typeParameters);
        let minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
        for (let _i = 0, declarations_6 = declarations; _i < declarations_6.length; _i++) {
            let declaration = declarations_6[_i];
            // If this declaration has too few or too many type parameters, we report an error
            let numTypeParameters = ts.length(declaration.typeParameters);
            if (numTypeParameters < minTypeArgumentCount || numTypeParameters > maxTypeArgumentCount) {
                return false;
            }
            for (let i = 0; i < numTypeParameters; i++) {
                let source = declaration.typeParameters[i];
                let target = typeParameters[i];
                // If the type parameter node does not have the same as the resolved type
                // parameter at this position, we report an error.
                if (source.name.escapedText !== target.symbol.escapedName) {
                    return false;
                }
                // If the type parameter node does not have an identical constraint as the resolved
                // type parameter at this position, we report an error.
                let sourceConstraint = source.constraint && getTypeFromTypeNode(source.constraint);
                let targetConstraint = getConstraintFromTypeParameter(target);
                if ((sourceConstraint || targetConstraint) &&
                    (!sourceConstraint || !targetConstraint || !isTypeIdenticalTo(sourceConstraint, targetConstraint))) {
                    return false;
                }
                // If the type parameter node has a default and it is not identical to the default
                // for the type parameter at this position, we report an error.
                let sourceDefault = source.default && getTypeFromTypeNode(source.default);
                let targetDefault = getDefaultFromTypeParameter(target);
                if (sourceDefault && targetDefault && !isTypeIdenticalTo(sourceDefault, targetDefault)) {
                    return false;
                }
            }
        }
        return true;
    }
    function checkClassExpression(node) {
        checkClassLikeDeclaration(node);
        checkNodeDeferred(node);
        return getTypeOfSymbol(getSymbolOfNode(node));
    }
    function checkClassExpressionDeferred(node) {
        ts.forEach(node.members, checkSourceElement);
        registerForUnusedIdentifiersCheck(node);
    }
    function checkClassDeclaration(node) {
        if (!node.name && !ts.hasModifier(node, 512 /* Default */)) {
            grammarErrorOnFirstToken(node, ts.Diagnostics.A_class_declaration_without_the_default_modifier_must_have_a_name);
        }
        checkClassLikeDeclaration(node);
        ts.forEach(node.members, checkSourceElement);
        registerForUnusedIdentifiersCheck(node);
    }
    function checkClassLikeDeclaration(node) {
        checkGrammarClassLikeDeclaration(node);
        checkDecorators(node);
        if (node.name) {
            checkTypeNameIsReserved(node.name, ts.Diagnostics.Class_name_cannot_be_0);
            checkCollisionWithCapturedThisVariable(node, node.name);
            checkCollisionWithCapturedNewTargetVariable(node, node.name);
            checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
            checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name);
        }
        checkTypeParameters(node.typeParameters);
        checkExportsOnMergedDeclarations(node);
        let symbol = getSymbolOfNode(node);
        let type = getDeclaredTypeOfSymbol(symbol);
        let typeWithThis = getTypeWithThisArgument(type);
        let staticType = getTypeOfSymbol(symbol);
        checkTypeParameterListsIdentical(symbol);
        checkClassForDuplicateDeclarations(node);
        // Only check for reserved static identifiers on non-ambient context.
        if (!ts.isInAmbientContext(node)) {
            checkClassForStaticPropertyNameConflicts(node);
        }
        let baseTypeNode = ts.getClassExtendsHeritageClauseElement(node);
        if (baseTypeNode) {
            if (languageVersion < 2 /* ES2015 */) {
                checkExternalEmitHelpers(baseTypeNode.parent, 1 /* Extends */);
            }
            let baseTypes = getBaseTypes(type);
            if (baseTypes.length && produceDiagnostics) {
                let baseType_1 = baseTypes[0];
                let baseConstructorType = getBaseConstructorTypeOfClass(type);
                let staticBaseType = getApparentType(baseConstructorType);
                checkBaseTypeAccessibility(staticBaseType, baseTypeNode);
                checkSourceElement(baseTypeNode.expression);
                if (ts.some(baseTypeNode.typeArguments)) {
                    ts.forEach(baseTypeNode.typeArguments, checkSourceElement);
                    for (let _i = 0, _a = getConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode); _i < _a.length; _i++) {
                        let constructor = _a[_i];
                        if (!checkTypeArgumentConstraints(constructor.typeParameters, baseTypeNode.typeArguments)) {
                            break;
                        }
                    }
                }
                checkTypeAssignableTo(typeWithThis, getTypeWithThisArgument(baseType_1, type.thisType), node.name || node, ts.Diagnostics.Class_0_incorrectly_extends_base_class_1);
                checkTypeAssignableTo(staticType, getTypeWithoutSignatures(staticBaseType), node.name || node, ts.Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1);
                if (baseConstructorType.flags & 540672 /* TypeVariable */ && !isMixinConstructorType(staticType)) {
                    error(node.name || node, ts.Diagnostics.A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any);
                }
                if (!(staticBaseType.symbol && staticBaseType.symbol.flags & 32 /* Class */) && !(baseConstructorType.flags & 540672 /* TypeVariable */)) {
                    // When the static base type is a "class-like" constructor function (but not actually a class), we verify
                    // that all instantiated base constructor signatures return the same type. We can simply compare the type
                    // references (as opposed to checking the structure of the types) because elsewhere we have already checked
                    // that the base type is a class or interface type (and not, for example, an anonymous object type).
                    let constructors = getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode);
                    if (ts.forEach(constructors, function (sig) { return getReturnTypeOfSignature(sig) !== baseType_1; })) {
                        error(baseTypeNode.expression, ts.Diagnostics.Base_constructors_must_all_have_the_same_return_type);
                    }
                }
                checkKindsOfPropertyMemberOverrides(type, baseType_1);
            }
        }
        let implementedTypeNodes = ts.getClassImplementsHeritageClauseElements(node);
        if (implementedTypeNodes) {
            for (let _b = 0, implementedTypeNodes_1 = implementedTypeNodes; _b < implementedTypeNodes_1.length; _b++) {
                let typeRefNode = implementedTypeNodes_1[_b];
                if (!ts.isEntityNameExpression(typeRefNode.expression)) {
                    error(typeRefNode.expression, ts.Diagnostics.A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments);
                }
                checkTypeReferenceNode(typeRefNode);
                if (produceDiagnostics) {
                    let t = getTypeFromTypeNode(typeRefNode);
                    if (t !== unknownType) {
                        if (isValidBaseType(t)) {
                            checkTypeAssignableTo(typeWithThis, getTypeWithThisArgument(t, type.thisType), node.name || node, ts.Diagnostics.Class_0_incorrectly_implements_interface_1);
                        }
                        else {
                            error(typeRefNode, ts.Diagnostics.A_class_may_only_implement_another_class_or_interface);
                        }
                    }
                }
            }
        }
        if (produceDiagnostics) {
            checkIndexConstraints(type);
            checkTypeForDuplicateIndexSignatures(node);
        }
    }
    function checkBaseTypeAccessibility(type, node) {
        let signatures = getSignaturesOfType(type, 1 /* Construct */);
        if (signatures.length) {
            let declaration = signatures[0].declaration;
            if (declaration && ts.hasModifier(declaration, 8 /* Private */)) {
                let typeClassDeclaration = getClassLikeDeclarationOfSymbol(type.symbol);
                if (!isNodeWithinClass(node, typeClassDeclaration)) {
                    error(node, ts.Diagnostics.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private, getFullyQualifiedName(type.symbol));
                }
            }
        }
    }
    function getTargetSymbol(s) {
        // if symbol is instantiated its flags are not copied from the 'target'
        // so we'll need to get back original 'target' symbol to work with correct set of flags
        return ts.getCheckFlags(s) & CheckFlags.Instantiated ? s.target : s;
    }
    function getClassLikeDeclarationOfSymbol(symbol) {
        return ts.forEach(symbol.declarations, function (d) { return ts.isClassLike(d) ? d : undefined; });
    }
    function getClassOrInterfaceDeclarationsOfSymbol(symbol) {
        return ts.filter(symbol.declarations, function (d) {
            return d.kind === SyntaxKind.ClassDeclaration || d.kind === SyntaxKind.InterfaceDeclaration;
        });
    }
    function checkKindsOfPropertyMemberOverrides(type, baseType) {
        // TypeScript 1.0 spec (April 2014): 8.2.3
        // A derived class inherits all members from its base class it doesn't override.
        // Inheritance means that a derived class implicitly contains all non - overridden members of the base class.
        // Both public and private property members are inherited, but only public property members can be overridden.
        // A property member in a derived class is said to override a property member in a base class
        // when the derived class property member has the same name and kind(instance or static)
        // as the base class property member.
        // The type of an overriding property member must be assignable(section 3.8.4)
        // to the type of the overridden property member, or otherwise a compile - time error occurs.
        // Base class instance member functions can be overridden by derived class instance member functions,
        // but not by other kinds of members.
        // Base class instance member variables and accessors can be overridden by
        // derived class instance member variables and accessors, but not by other kinds of members.
        // NOTE: assignability is checked in checkClassDeclaration
        let baseProperties = getPropertiesOfType(baseType);
        for (let _i = 0, baseProperties_1 = baseProperties; _i < baseProperties_1.length; _i++) {
            let baseProperty = baseProperties_1[_i];
            let base = getTargetSymbol(baseProperty);
            if (base.flags & 4194304 /* Prototype */) {
                continue;
            }
            let derived = getTargetSymbol(getPropertyOfObjectType(type, base.escapedName));
            let baseDeclarationFlags = ts.getDeclarationModifierFlagsFromSymbol(base);
            ts.Debug.assert(!!derived, "derived should point to something, even if it is the base class' declaration.");
            if (derived) {
                // In order to resolve whether the inherited method was overridden in the base class or not,
                // we compare the Symbols obtained. Since getTargetSymbol returns the symbol on the *uninstantiated*
                // type declaration, derived and base resolve to the same symbol even in the case of generic classes.
                if (derived === base) {
                    // derived class inherits base without override/redeclaration
                    let derivedClassDecl = getClassLikeDeclarationOfSymbol(type.symbol);
                    // It is an error to inherit an abstract member without implementing it or being declared abstract.
                    // If there is no declaration for the derived class (as in the case of class expressions),
                    // then the class cannot be declared abstract.
                    if (baseDeclarationFlags & 128 /* Abstract */ && (!derivedClassDecl || !ts.hasModifier(derivedClassDecl, 128 /* Abstract */))) {
                        if (derivedClassDecl.kind === SyntaxKind.ClassExpression) {
                            error(derivedClassDecl, ts.Diagnostics.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1, symbolToString(baseProperty), typeToString(baseType));
                        }
                        else {
                            error(derivedClassDecl, ts.Diagnostics.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2, typeToString(type), symbolToString(baseProperty), typeToString(baseType));
                        }
                    }
                }
                else {
                    // derived overrides base.
                    let derivedDeclarationFlags = ts.getDeclarationModifierFlagsFromSymbol(derived);
                    if (baseDeclarationFlags & 8 /* Private */ || derivedDeclarationFlags & 8 /* Private */) {
                        // either base or derived property is private - not override, skip it
                        continue;
                    }
                    if (isMethodLike(base) && isMethodLike(derived) || base.flags & 98308 /* PropertyOrAccessor */ && derived.flags & 98308 /* PropertyOrAccessor */) {
                        // method is overridden with method or property/accessor is overridden with property/accessor - correct case
                        continue;
                    }
                    let errorMessage = void 0;
                    if (isMethodLike(base)) {
                        if (derived.flags & 98304 /* Accessor */) {
                            errorMessage = ts.Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;
                        }
                        else {
                            errorMessage = ts.Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property;
                        }
                    }
                    else if (base.flags & SymbolFlags.Property) {
                        errorMessage = ts.Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;
                    }
                    else {
                        errorMessage = ts.Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;
                    }
                    error(ts.getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, typeToString(baseType), symbolToString(base), typeToString(type));
                }
            }
        }
    }
    function checkInheritedPropertiesAreIdentical(type, typeNode) {
        let baseTypes = getBaseTypes(type);
        if (baseTypes.length < 2) {
            return true;
        }
        let seen = ts.createUnderscoreEscapedMap();
        ts.forEach(resolveDeclaredMembers(type).declaredProperties, function (p) { seen.set(p.escapedName, { prop: p, containingType: type }); });
        let ok = true;
        for (let _i = 0, baseTypes_2 = baseTypes; _i < baseTypes_2.length; _i++) {
            let base = baseTypes_2[_i];
            let properties = getPropertiesOfType(getTypeWithThisArgument(base, type.thisType));
            for (let _a = 0, properties_8 = properties; _a < properties_8.length; _a++) {
                let prop = properties_8[_a];
                let existing = seen.get(prop.escapedName);
                if (!existing) {
                    seen.set(prop.escapedName, { prop: prop, containingType: base });
                }
                else {
                    let isInheritedProperty = existing.containingType !== type;
                    if (isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop)) {
                        ok = false;
                        let typeName1 = typeToString(existing.containingType);
                        let typeName2 = typeToString(base);
                        let errorInfo = ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Named_property_0_of_types_1_and_2_are_not_identical, symbolToString(prop), typeName1, typeName2);
                        errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2, typeToString(type), typeName1, typeName2);
                        diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(typeNode, errorInfo));
                    }
                }
            }
        }
        return ok;
    }
    function checkInterfaceDeclaration(node) {
        // Grammar checking
        checkGrammarDecorators(node) || checkGrammarModifiers(node) || checkGrammarInterfaceDeclaration(node);
        checkTypeParameters(node.typeParameters);
        if (produceDiagnostics) {
            checkTypeNameIsReserved(node.name, ts.Diagnostics.Interface_name_cannot_be_0);
            checkExportsOnMergedDeclarations(node);
            let symbol = getSymbolOfNode(node);
            checkTypeParameterListsIdentical(symbol);
            // Only check this symbol once
            let firstInterfaceDecl = ts.getDeclarationOfKind(symbol, SyntaxKind.InterfaceDeclaration);
            if (node === firstInterfaceDecl) {
                let type = getDeclaredTypeOfSymbol(symbol);
                let typeWithThis = getTypeWithThisArgument(type);
                // run subsequent checks only if first set succeeded
                if (checkInheritedPropertiesAreIdentical(type, node.name)) {
                    for (let _i = 0, _a = getBaseTypes(type); _i < _a.length; _i++) {
                        let baseType = _a[_i];
                        checkTypeAssignableTo(typeWithThis, getTypeWithThisArgument(baseType, type.thisType), node.name, ts.Diagnostics.Interface_0_incorrectly_extends_interface_1);
                    }
                    checkIndexConstraints(type);
                }
            }
            checkObjectTypeForDuplicateDeclarations(node);
        }
        ts.forEach(ts.getInterfaceBaseTypeNodes(node), function (heritageElement) {
            if (!ts.isEntityNameExpression(heritageElement.expression)) {
                error(heritageElement.expression, ts.Diagnostics.An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments);
            }
            checkTypeReferenceNode(heritageElement);
        });
        ts.forEach(node.members, checkSourceElement);
        if (produceDiagnostics) {
            checkTypeForDuplicateIndexSignatures(node);
            registerForUnusedIdentifiersCheck(node);
        }
    }
    function checkTypeAliasDeclaration(node) {
        // Grammar checking
        checkGrammarDecorators(node) || checkGrammarModifiers(node);
        checkTypeNameIsReserved(node.name, ts.Diagnostics.Type_alias_name_cannot_be_0);
        checkTypeParameters(node.typeParameters);
        checkSourceElement(node.type);
        registerForUnusedIdentifiersCheck(node);
    }
    function computeEnumMemberValues(node) {
        let nodeLinks = getNodeLinks(node);
        if (!(nodeLinks.flags & 16384 /* EnumValuesComputed */)) {
            nodeLinks.flags |= 16384 /* EnumValuesComputed */;
            let autoValue = 0;
            for (let _i = 0, _a = node.members; _i < _a.length; _i++) {
                let member = _a[_i];
                let value = computeMemberValue(member, autoValue);
                getNodeLinks(member).enumMemberValue = value;
                autoValue = typeof value === "number" ? value + 1 : undefined;
            }
        }
    }
    function computeMemberValue(member, autoValue) {
        if (isComputedNonLiteralName(member.name)) {
            error(member.name, ts.Diagnostics.Computed_property_names_are_not_allowed_in_enums);
        }
        else {
            let text = ts.getTextOfPropertyName(member.name);
            if (isNumericLiteralName(text) && !isInfinityOrNaNString(text)) {
                error(member.name, ts.Diagnostics.An_enum_member_cannot_have_a_numeric_name);
            }
        }
        if (member.initializer) {
            return computeConstantValue(member);
        }
        // In ambient enum declarations that specify no const modifier, enum member declarations that omit
        // a value are considered computed members (as opposed to having auto-incremented values).
        if (ts.isInAmbientContext(member.parent) && !ts.isConst(member.parent)) {
            return undefined;
        }
        // If the member declaration specifies no value, the member is considered a constant enum member.
        // If the member is the first member in the enum declaration, it is assigned the value zero.
        // Otherwise, it is assigned the value of the immediately preceding member plus one, and an error
        // occurs if the immediately preceding member is not a constant enum member.
        if (autoValue !== undefined) {
            return autoValue;
        }
        error(member.name, ts.Diagnostics.Enum_member_must_have_initializer);
        return undefined;
    }
    function computeConstantValue(member) {
        let enumKind = getEnumKind(getSymbolOfNode(member.parent));
        let isConstEnum = ts.isConst(member.parent);
        let initializer = member.initializer;
        let value = enumKind === 1 /* Literal */ && !isLiteralEnumMember(member) ? undefined : evaluate(initializer);
        if (value !== undefined) {
            if (isConstEnum && typeof value === "number" && !isFinite(value)) {
                error(initializer, isNaN(value) ?
                    ts.Diagnostics.const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN :
                    ts.Diagnostics.const_enum_member_initializer_was_evaluated_to_a_non_finite_value);
            }
        }
        else if (enumKind === 1 /* Literal */) {
            error(initializer, ts.Diagnostics.Computed_values_are_not_permitted_in_an_enum_with_string_valued_members);
            return 0;
        }
        else if (isConstEnum) {
            error(initializer, ts.Diagnostics.In_const_enum_declarations_member_initializer_must_be_constant_expression);
        }
        else if (ts.isInAmbientContext(member.parent)) {
            error(initializer, ts.Diagnostics.In_ambient_enum_declarations_member_initializer_must_be_constant_expression);
        }
        else {
            // Only here do we need to check that the initializer is assignable to the enum type.
            checkTypeAssignableTo(checkExpression(initializer), getDeclaredTypeOfSymbol(getSymbolOfNode(member.parent)), initializer, /*headMessage*/ undefined);
        }
        return value;
        function evaluate(expr) {
            switch (expr.kind) {
                case 192 /* PrefixUnaryExpression */:
                    let value_1 = evaluate(expr.operand);
                    if (typeof value_1 === "number") {
                        switch (expr.operator) {
                            case 37 /* PlusToken */: return value_1;
                            case 38 /* MinusToken */: return -value_1;
                            case 52 /* TildeToken */: return ~value_1;
                        }
                    }
                    break;
                case 194 /* BinaryExpression */:
                    let left = evaluate(expr.left);
                    let right = evaluate(expr.right);
                    if (typeof left === "number" && typeof right === "number") {
                        switch (expr.operatorToken.kind) {
                            case 49 /* BarToken */: return left | right;
                            case 48 /* AmpersandToken */: return left & right;
                            case 46 /* GreaterThanGreaterThanToken */: return left >> right;
                            case 47 /* GreaterThanGreaterThanGreaterThanToken */: return left >>> right;
                            case 45 /* LessThanLessThanToken */: return left << right;
                            case 50 /* CaretToken */: return left ^ right;
                            case 39 /* AsteriskToken */: return left * right;
                            case 41 /* SlashToken */: return left / right;
                            case 37 /* PlusToken */: return left + right;
                            case 38 /* MinusToken */: return left - right;
                            case 42 /* PercentToken */: return left % right;
                        }
                    }
                    break;
                case 9 /* StringLiteral */:
                    return expr.text;
                case 8 /* NumericLiteral */:
                    checkGrammarNumericLiteral(expr);
                    return +expr.text;
                case 185 /* ParenthesizedExpression */:
                    return evaluate(expr.expression);
                case 71 /* Identifier */:
                    return ts.nodeIsMissing(expr) ? 0 : evaluateEnumMember(expr, getSymbolOfNode(member.parent), expr.escapedText);
                case 180 /* ElementAccessExpression */:
                case 179 /* PropertyAccessExpression */:
                    let ex = expr;
                    if (isConstantMemberAccess(ex)) {
                        let type = getTypeOfExpression(ex.expression);
                        if (type.symbol && type.symbol.flags & 384 /* Enum */) {
                            let name = void 0;
                            if (ex.kind === 179 /* PropertyAccessExpression */) {
                                name = ex.name.escapedText;
                            }
                            else {
                                let argument = ex.argumentExpression;
                                ts.Debug.assert(ts.isLiteralExpression(argument));
                                name = ts.escapeLeadingUnderscores(argument.text);
                            }
                            return evaluateEnumMember(expr, type.symbol, name);
                        }
                    }
                    break;
            }
            return undefined;
        }
        function evaluateEnumMember(expr, enumSymbol, name) {
            let memberSymbol = enumSymbol.exports.get(name);
            if (memberSymbol) {
                let declaration = memberSymbol.valueDeclaration;
                if (declaration !== member) {
                    if (isBlockScopedNameDeclaredBeforeUse(declaration, member)) {
                        return getEnumMemberValue(declaration);
                    }
                    error(expr, ts.Diagnostics.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums);
                    return 0;
                }
            }
            return undefined;
        }
    }
    function isConstantMemberAccess(node) {
        return node.kind === 71 /* Identifier */ ||
            node.kind === 179 /* PropertyAccessExpression */ && isConstantMemberAccess(node.expression) ||
            node.kind === 180 /* ElementAccessExpression */ && isConstantMemberAccess(node.expression) &&
            node.argumentExpression.kind === 9 /* StringLiteral */;
    }
    function checkEnumDeclaration(node) {
        if (!produceDiagnostics) {
            return;
        }
        // Grammar checking
        checkGrammarDecorators(node) || checkGrammarModifiers(node);
        checkTypeNameIsReserved(node.name, ts.Diagnostics.Enum_name_cannot_be_0);
        checkCollisionWithCapturedThisVariable(node, node.name);
        checkCollisionWithCapturedNewTargetVariable(node, node.name);
        checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
        checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name);
        checkExportsOnMergedDeclarations(node);
        computeEnumMemberValues(node);
        let enumIsConst = ts.isConst(node);
        if (compilerOptions.isolatedModules && enumIsConst && ts.isInAmbientContext(node)) {
            error(node.name, ts.Diagnostics.Ambient_const_enums_are_not_allowed_when_the_isolatedModules_flag_is_provided);
        }
        // Spec 2014 - Section 9.3:
        // It isn't possible for one enum declaration to continue the automatic numbering sequence of another,
        // and when an enum type has multiple declarations, only one declaration is permitted to omit a value
        // for the first member.
        //
        // Only perform this check once per symbol
        let enumSymbol = getSymbolOfNode(node);
        let firstDeclaration = ts.getDeclarationOfKind(enumSymbol, node.kind);
        if (node === firstDeclaration) {
            if (enumSymbol.declarations.length > 1) {
                // check that const is placed\omitted on all enum declarations
                ts.forEach(enumSymbol.declarations, function (decl) {
                    if (ts.isConstEnumDeclaration(decl) !== enumIsConst) {
                        error(ts.getNameOfDeclaration(decl), ts.Diagnostics.Enum_declarations_must_all_be_const_or_non_const);
                    }
                });
            }
            let seenEnumMissingInitialInitializer_1 = false;
            ts.forEach(enumSymbol.declarations, function (declaration) {
                // return true if we hit a violation of the rule, false otherwise
                if (declaration.kind !== SyntaxKind.EnumDeclaration) {
                    return false;
                }
                let enumDeclaration = declaration;
                if (!enumDeclaration.members.length) {
                    return false;
                }
                let firstEnumMember = enumDeclaration.members[0];
                if (!firstEnumMember.initializer) {
                    if (seenEnumMissingInitialInitializer_1) {
                        error(firstEnumMember.name, ts.Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element);
                    }
                    else {
                        seenEnumMissingInitialInitializer_1 = true;
                    }
                }
            });
        }
    }
    function getFirstNonAmbientClassOrFunctionDeclaration(symbol) {
        let declarations = symbol.declarations;
        for (let _i = 0, declarations_7 = declarations; _i < declarations_7.length; _i++) {
            let declaration = declarations_7[_i];
            if ((declaration.kind === SyntaxKind.ClassDeclaration ||
                (declaration.kind === 228 /* FunctionDeclaration */ && ts.nodeIsPresent(declaration.body))) &&
                !ts.isInAmbientContext(declaration)) {
                return declaration;
            }
        }
        return undefined;
    }
    function inSameLexicalScope(node1, node2) {
        let container1 = ts.getEnclosingBlockScopeContainer(node1);
        let container2 = ts.getEnclosingBlockScopeContainer(node2);
        if (isGlobalSourceFile(container1)) {
            return isGlobalSourceFile(container2);
        }
        else if (isGlobalSourceFile(container2)) {
            return false;
        }
        else {
            return container1 === container2;
        }
    }
    function checkModuleDeclaration(node) {
        if (produceDiagnostics) {
            // Grammar checking
            let isGlobalAugmentation = ts.isGlobalScopeAugmentation(node);
            let inAmbientContext = ts.isInAmbientContext(node);
            if (isGlobalAugmentation && !inAmbientContext) {
                error(node.name, ts.Diagnostics.Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context);
            }
            let isAmbientExternalModule = ts.isAmbientModule(node);
            let contextErrorMessage = isAmbientExternalModule
                ? ts.Diagnostics.An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file
                : ts.Diagnostics.A_namespace_declaration_is_only_allowed_in_a_namespace_or_module;
            if (checkGrammarModuleElementContext(node, contextErrorMessage)) {
                // If we hit a module declaration in an illegal context, just bail out to avoid cascading errors.
                return;
            }
            if (!checkGrammarDecorators(node) && !checkGrammarModifiers(node)) {
                if (!inAmbientContext && node.name.kind === 9 /* StringLiteral */) {
                    grammarErrorOnNode(node.name, ts.Diagnostics.Only_ambient_modules_can_use_quoted_names);
                }
            }
            if (ts.isIdentifier(node.name)) {
                checkCollisionWithCapturedThisVariable(node, node.name);
                checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
                checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name);
            }
            checkExportsOnMergedDeclarations(node);
            let symbol = getSymbolOfNode(node);
            // The following checks only apply on a non-ambient instantiated module declaration.
            if (symbol.flags & 512 /* ValueModule */
                && symbol.declarations.length > 1
                && !inAmbientContext
                && isInstantiatedModule(node, compilerOptions.preserveConstEnums || compilerOptions.isolatedModules)) {
                let firstNonAmbientClassOrFunc = getFirstNonAmbientClassOrFunctionDeclaration(symbol);
                if (firstNonAmbientClassOrFunc) {
                    if (ts.getSourceFileOfNode(node) !== ts.getSourceFileOfNode(firstNonAmbientClassOrFunc)) {
                        error(node.name, ts.Diagnostics.A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged);
                    }
                    else if (node.pos < firstNonAmbientClassOrFunc.pos) {
                        error(node.name, ts.Diagnostics.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged);
                    }
                }
                // if the module merges with a class declaration in the same lexical scope,
                // we need to track this to ensure the correct emit.
                let mergedClass = ts.getDeclarationOfKind(symbol, SyntaxKind.ClassDeclaration);
                if (mergedClass &&
                    inSameLexicalScope(node, mergedClass)) {
                    getNodeLinks(node).flags |= 32768 /* LexicalModuleMergesWithClass */;
                }
            }
            if (isAmbientExternalModule) {
                if (ts.isExternalModuleAugmentation(node)) {
                    // body of the augmentation should be checked for consistency only if augmentation was applied to its target (either global scope or module)
                    // otherwise we'll be swamped in cascading errors.
                    // We can detect if augmentation was applied using following rules:
                    // - augmentation for a global scope is always applied
                    // - augmentation for some external module is applied if symbol for augmentation is merged (it was combined with target module).
                    let checkBody = isGlobalAugmentation || (getSymbolOfNode(node).flags & SymbolFlags.Transient);
                    if (checkBody && node.body) {
                        // body of ambient external module is always a module block
                        for (let _i = 0, _a = node.body.statements; _i < _a.length; _i++) {
                            let statement = _a[_i];
                            checkModuleAugmentationElement(statement, isGlobalAugmentation);
                        }
                    }
                }
                else if (isGlobalSourceFile(node.parent)) {
                    if (isGlobalAugmentation) {
                        error(node.name, ts.Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations);
                    }
                    else if (ts.isExternalModuleNameRelative(ts.getTextOfIdentifierOrLiteral(node.name))) {
                        error(node.name, ts.Diagnostics.Ambient_module_declaration_cannot_specify_relative_module_name);
                    }
                }
                else {
                    if (isGlobalAugmentation) {
                        error(node.name, ts.Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations);
                    }
                    else {
                        // Node is not an augmentation and is not located on the script level.
                        // This means that this is declaration of ambient module that is located in other module or namespace which is prohibited.
                        error(node.name, ts.Diagnostics.Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces);
                    }
                }
            }
        }
        if (node.body) {
            checkSourceElement(node.body);
            if (!ts.isGlobalScopeAugmentation(node)) {
                registerForUnusedIdentifiersCheck(node);
            }
        }
    }
    function checkModuleAugmentationElement(node, isGlobalAugmentation) {
        switch (node.kind) {
            case SyntaxKind.VariableStatement:
                // error each individual name in variable statement instead of marking the entire variable statement
                for (let _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
                    let decl = _a[_i];
                    checkModuleAugmentationElement(decl, isGlobalAugmentation);
                }
                break;
            case SyntaxKind.ExportAssignment:
            case 244 /* ExportDeclaration */:
                grammarErrorOnFirstToken(node, ts.Diagnostics.Exports_and_export_assignments_are_not_permitted_in_module_augmentations);
                break;
            case 237 /* ImportEqualsDeclaration */:
            case 238 /* ImportDeclaration */:
                grammarErrorOnFirstToken(node, ts.Diagnostics.Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module);
                break;
            case 176 /* BindingElement */:
            case SyntaxKind.VariableDeclaration:
                let name = node.name;
                if (ts.isBindingPattern(name)) {
                    for (let _b = 0, _c = name.elements; _b < _c.length; _b++) {
                        let el = _c[_b];
                        // mark individual names in binding pattern
                        checkModuleAugmentationElement(el, isGlobalAugmentation);
                    }
                    break;
                }
            // falls through
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.EnumDeclaration:
            case 228 /* FunctionDeclaration */:
            case SyntaxKind.InterfaceDeclaration:
            case SyntaxKind.ModuleDeclaration:
            case 231 /* TypeAliasDeclaration */:
                if (isGlobalAugmentation) {
                    return;
                }
                let symbol = getSymbolOfNode(node);
                if (symbol) {
                    // module augmentations cannot introduce new names on the top level scope of the module
                    // this is done it two steps
                    // 1. quick check - if symbol for node is not merged - this is local symbol to this augmentation - report error
                    // 2. main check - report error if value declaration of the parent symbol is module augmentation)
                    let reportError = !(symbol.flags & SymbolFlags.Transient);
                    if (!reportError) {
                        // symbol should not originate in augmentation
                        reportError = ts.isExternalModuleAugmentation(symbol.parent.declarations[0]);
                    }
                }
                break;
        }
    }
    function getFirstIdentifier(node) {
        switch (node.kind) {
            case 71 /* Identifier */:
                return node;
            case 143 /* QualifiedName */:
                do {
                    node = node.left;
                } while (node.kind !== 71 /* Identifier */);
                return node;
            case 179 /* PropertyAccessExpression */:
                do {
                    node = node.expression;
                } while (node.kind !== 71 /* Identifier */);
                return node;
        }
    }
    function checkExternalImportOrExportDeclaration(node) {
        let moduleName = ts.getExternalModuleName(node);
        if (!ts.nodeIsMissing(moduleName) && moduleName.kind !== 9 /* StringLiteral */) {
            error(moduleName, ts.Diagnostics.String_literal_expected);
            return false;
        }
        let inAmbientExternalModule = node.parent.kind === 234 /* ModuleBlock */ && ts.isAmbientModule(node.parent.parent);
        if (node.parent.kind !== SyntaxKind.SourceFile && !inAmbientExternalModule) {
            error(moduleName, node.kind === 244 /* ExportDeclaration */ ?
                ts.Diagnostics.Export_declarations_are_not_permitted_in_a_namespace :
                ts.Diagnostics.Import_declarations_in_a_namespace_cannot_reference_a_module);
            return false;
        }
        if (inAmbientExternalModule && ts.isExternalModuleNameRelative(ts.getTextOfIdentifierOrLiteral(moduleName))) {
            // we have already reported errors on top level imports\exports in external module augmentations in checkModuleDeclaration
            // no need to do this again.
            if (!isTopLevelInExternalModuleAugmentation(node)) {
                // TypeScript 1.0 spec (April 2013): 12.1.6
                // An ExternalImportDeclaration in an AmbientExternalModuleDeclaration may reference
                // other external modules only through top - level external module names.
                // Relative external module names are not permitted.
                error(node, ts.Diagnostics.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name);
                return false;
            }
        }
        return true;
    }
    function checkAliasSymbol(node) {
        let symbol = getSymbolOfNode(node);
        let target = resolveAlias(symbol);
        if (target !== unknownSymbol) {
            // For external modules symbol represent local symbol for an alias.
            // This local symbol will merge any other local declarations (excluding other aliases)
            // and symbol.flags will contains combined representation for all merged declaration.
            // Based on symbol.flags we can compute a set of excluded meanings (meaning that resolved alias should not have,
            // otherwise it will conflict with some local declaration). Note that in addition to normal flags we include matching SymbolFlags.Export*
            // in order to prevent collisions with declarations that were exported from the current module (they still contribute to local names).
            let excludedMeanings = (symbol.flags & (SymbolFlags.Value | 1048576 /* ExportValue */) ? SymbolFlags.Value : 0) |
                (symbol.flags & SymbolFlags.Type ? SymbolFlags.Type : 0) |
                (symbol.flags & SymbolFlags.Namespace ? SymbolFlags.Namespace : 0);
            if (target.flags & excludedMeanings) {
                let message = node.kind === SyntaxKind.ExportSpecifier ?
                    ts.Diagnostics.Export_declaration_conflicts_with_exported_declaration_of_0 :
                    ts.Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0;
                error(node, message, symbolToString(symbol));
            }
            // Don't allow to re-export something with no value side when `--isolatedModules` is set.
            if (compilerOptions.isolatedModules
                && node.kind === SyntaxKind.ExportSpecifier
                && !(target.flags & SymbolFlags.Value)
                && !ts.isInAmbientContext(node)) {
                error(node, ts.Diagnostics.Cannot_re_export_a_type_when_the_isolatedModules_flag_is_provided);
            }
        }
    }
    function checkImportBinding(node) {
        checkCollisionWithCapturedThisVariable(node, node.name);
        checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
        checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name);
        checkAliasSymbol(node);
    }
    function checkImportDeclaration(node) {
        if (checkGrammarModuleElementContext(node, ts.Diagnostics.An_import_declaration_can_only_be_used_in_a_namespace_or_module)) {
            // If we hit an import declaration in an illegal context, just bail out to avoid cascading errors.
            return;
        }
        if (!checkGrammarDecorators(node) && !checkGrammarModifiers(node) && ts.hasModifiers(node)) {
            grammarErrorOnFirstToken(node, ts.Diagnostics.An_import_declaration_cannot_have_modifiers);
        }
        if (checkExternalImportOrExportDeclaration(node)) {
            let importClause = node.importClause;
            if (importClause) {
                if (importClause.name) {
                    checkImportBinding(importClause);
                }
                if (importClause.namedBindings) {
                    if (importClause.namedBindings.kind === 240 /* NamespaceImport */) {
                        checkImportBinding(importClause.namedBindings);
                    }
                    else {
                        ts.forEach(importClause.namedBindings.elements, checkImportBinding);
                    }
                }
            }
        }
    }
    function checkImportEqualsDeclaration(node) {
        if (checkGrammarModuleElementContext(node, ts.Diagnostics.An_import_declaration_can_only_be_used_in_a_namespace_or_module)) {
            // If we hit an import declaration in an illegal context, just bail out to avoid cascading errors.
            return;
        }
        checkGrammarDecorators(node) || checkGrammarModifiers(node);
        if (ts.isInternalModuleImportEqualsDeclaration(node) || checkExternalImportOrExportDeclaration(node)) {
            checkImportBinding(node);
            if (ts.hasModifier(node, 1 /* Export */)) {
                markExportAsReferenced(node);
            }
            if (ts.isInternalModuleImportEqualsDeclaration(node)) {
                let target = resolveAlias(getSymbolOfNode(node));
                if (target !== unknownSymbol) {
                    if (target.flags & SymbolFlags.Value) {
                        // Target is a value symbol, check that it is not hidden by a local declaration with the same name
                        let moduleName = getFirstIdentifier(node.moduleReference);
                        if (!(resolveEntityName(moduleName, SymbolFlags.Value | SymbolFlags.Namespace).flags & SymbolFlags.Namespace)) {
                            error(moduleName, ts.Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, ts.declarationNameToString(moduleName));
                        }
                    }
                    if (target.flags & SymbolFlags.Type) {
                        checkTypeNameIsReserved(node.name, ts.Diagnostics.Import_name_cannot_be_0);
                    }
                }
            }
            else {
                if (modulekind >= ts.ModuleKind.ES2015 && !ts.isInAmbientContext(node)) {
                    // Import equals declaration is deprecated in es6 or above
                    grammarErrorOnNode(node, ts.Diagnostics.Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead);
                }
            }
        }
    }
    function checkExportDeclaration(node) {
        if (checkGrammarModuleElementContext(node, ts.Diagnostics.An_export_declaration_can_only_be_used_in_a_module)) {
            // If we hit an export in an illegal context, just bail out to avoid cascading errors.
            return;
        }
        if (!checkGrammarDecorators(node) && !checkGrammarModifiers(node) && ts.hasModifiers(node)) {
            grammarErrorOnFirstToken(node, ts.Diagnostics.An_export_declaration_cannot_have_modifiers);
        }
        if (!node.moduleSpecifier || checkExternalImportOrExportDeclaration(node)) {
            if (node.exportClause) {
                // export { x, y }
                // export { x, y } from "foo"
                ts.forEach(node.exportClause.elements, checkExportSpecifier);
                let inAmbientExternalModule = node.parent.kind === 234 /* ModuleBlock */ && ts.isAmbientModule(node.parent.parent);
                let inAmbientNamespaceDeclaration = !inAmbientExternalModule && node.parent.kind === 234 /* ModuleBlock */ &&
                    !node.moduleSpecifier && ts.isInAmbientContext(node);
                if (node.parent.kind !== SyntaxKind.SourceFile && !inAmbientExternalModule && !inAmbientNamespaceDeclaration) {
                    error(node, ts.Diagnostics.Export_declarations_are_not_permitted_in_a_namespace);
                }
            }
            else {
                // export * from "foo"
                let moduleSymbol = resolveExternalModuleName(node, node.moduleSpecifier);
                if (moduleSymbol && hasExportAssignmentSymbol(moduleSymbol)) {
                    error(node.moduleSpecifier, ts.Diagnostics.Module_0_uses_export_and_cannot_be_used_with_export_Asterisk, symbolToString(moduleSymbol));
                }
                if (modulekind !== ts.ModuleKind.System && modulekind !== ts.ModuleKind.ES2015 && modulekind !== ts.ModuleKind.ESNext) {
                    checkExternalEmitHelpers(node, 32768 /* ExportStar */);
                }
            }
        }
    }
    function checkGrammarModuleElementContext(node, errorMessage) {
        let isInAppropriateContext = node.parent.kind === SyntaxKind.SourceFile || node.parent.kind === 234 /* ModuleBlock */ || node.parent.kind === SyntaxKind.ModuleDeclaration;
        if (!isInAppropriateContext) {
            grammarErrorOnFirstToken(node, errorMessage);
        }
        return !isInAppropriateContext;
    }
    function checkExportSpecifier(node) {
        checkAliasSymbol(node);
        if (!node.parent.parent.moduleSpecifier) {
            let exportedName = node.propertyName || node.name;
            // find immediate value referenced by exported name (SymbolFlags.Alias is set so we don't chase down aliases)
            let symbol = resolveName(exportedName, exportedName.escapedText, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias,
            /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ true);
            if (symbol && (symbol === undefinedSymbol || isGlobalSourceFile(getDeclarationContainer(symbol.declarations[0])))) {
                error(exportedName, ts.Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, ts.idText(exportedName));
            }
            else {
                markExportAsReferenced(node);
            }
        }
    }
    function checkExportAssignment(node) {
        if (checkGrammarModuleElementContext(node, ts.Diagnostics.An_export_assignment_can_only_be_used_in_a_module)) {
            // If we hit an export assignment in an illegal context, just bail out to avoid cascading errors.
            return;
        }
        let container = node.parent.kind === SyntaxKind.SourceFile ? node.parent : node.parent.parent;
        if (container.kind === SyntaxKind.ModuleDeclaration && !ts.isAmbientModule(container)) {
            if (node.isExportEquals) {
                error(node, ts.Diagnostics.An_export_assignment_cannot_be_used_in_a_namespace);
            }
            else {
                error(node, ts.Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module);
            }
            return;
        }
        // Grammar checking
        if (!checkGrammarDecorators(node) && !checkGrammarModifiers(node) && ts.hasModifiers(node)) {
            grammarErrorOnFirstToken(node, ts.Diagnostics.An_export_assignment_cannot_have_modifiers);
        }
        if (node.expression.kind === 71 /* Identifier */) {
            markExportAsReferenced(node);
        }
        else {
            checkExpressionCached(node.expression);
        }
        checkExternalModuleExports(container);
        if (ts.isInAmbientContext(node) && !ts.isEntityNameExpression(node.expression)) {
            grammarErrorOnNode(node.expression, ts.Diagnostics.The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context);
        }
        if (node.isExportEquals && !ts.isInAmbientContext(node)) {
            if (modulekind >= ts.ModuleKind.ES2015) {
                // export assignment is not supported in es6 modules
                grammarErrorOnNode(node, ts.Diagnostics.Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead);
            }
            else if (modulekind === ts.ModuleKind.System) {
                // system modules does not support export assignment
                grammarErrorOnNode(node, ts.Diagnostics.Export_assignment_is_not_supported_when_module_flag_is_system);
            }
        }
    }
    function hasExportedMembers(moduleSymbol) {
        return ts.forEachEntry(moduleSymbol.exports, function (_, id) { return id !== "export="; });
    }
    function checkExternalModuleExports(node) {
        let moduleSymbol = getSymbolOfNode(node);
        let links = getSymbolLinks(moduleSymbol);
        if (!links.exportsChecked) {
            let exportEqualsSymbol = moduleSymbol.exports.get("export=");
            if (exportEqualsSymbol && hasExportedMembers(moduleSymbol)) {
                let declaration = getDeclarationOfAliasSymbol(exportEqualsSymbol) || exportEqualsSymbol.valueDeclaration;
                if (!isTopLevelInExternalModuleAugmentation(declaration)) {
                    error(declaration, ts.Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements);
                }
            }
            // Checks for export * conflicts
            let exports = getExportsOfModule(moduleSymbol);
            exports && exports.forEach(function (_a, id) {
                let declarations = _a.declarations, flags = _a.flags;
                if (id === "__export") {
                    return;
                }
                // ECMA262: 15.2.1.1 It is a Syntax Error if the ExportedNames of ModuleItemList contains any duplicate entries.
                // (TS Exceptions: namespaces, function overloads, enums, and interfaces)
                if (flags & (SymbolFlags.Namespace | 64 /* Interface */ | 384 /* Enum */)) {
                    return;
                }
                let exportedDeclarationsCount = ts.countWhere(declarations, isNotOverloadAndNotAccessor);
                if (flags & 524288 /* TypeAlias */ && exportedDeclarationsCount <= 2) {
                    // it is legal to merge type alias with other values
                    // so count should be either 1 (just type alias) or 2 (type alias + merged value)
                    return;
                }
                if (exportedDeclarationsCount > 1) {
                    for (let _i = 0, declarations_8 = declarations; _i < declarations_8.length; _i++) {
                        let declaration = declarations_8[_i];
                        if (isNotOverload(declaration)) {
                            diagnostics.add(ts.createDiagnosticForNode(declaration, ts.Diagnostics.Cannot_redeclare_exported_variable_0, ts.unescapeLeadingUnderscores(id)));
                        }
                    }
                }
            });
            links.exportsChecked = true;
        }
    }
    function isNotAccessor(declaration) {
        // Accessors check for their own matching duplicates, and in contexts where they are valid, there are already duplicate identifier checks
        return !ts.isAccessor(declaration);
    }
    function isNotOverload(declaration) {
        return (declaration.kind !== 228 /* FunctionDeclaration */ && declaration.kind !== SyntaxKind.MethodDeclaration) ||
            !!declaration.body;
    }
    function checkSourceElement(node) {
        if (!node) {
            return;
        }
        if (ts.isInJavaScriptFile(node) && node.jsDoc) {
            for (let _i = 0, _a = node.jsDoc; _i < _a.length; _i++) {
                let tags = _a[_i].tags;
                ts.forEach(tags, checkSourceElement);
            }
        }
        let kind = node.kind;
        if (cancellationToken) {
            // Only bother checking on a few construct kinds.  We don't want to be excessively
            // hitting the cancellation token on every node we check.
            switch (kind) {
                case SyntaxKind.ModuleDeclaration:
                case SyntaxKind.ClassDeclaration:
                case SyntaxKind.InterfaceDeclaration:
                case 228 /* FunctionDeclaration */:
                    cancellationToken.throwIfCancellationRequested();
            }
        }
        switch (kind) {
            case SyntaxKind.TypeParameter:
                return checkTypeParameter(node);
            case SyntaxKind.Parameter:
                return checkParameter(node);
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.PropertySignature:
                return checkPropertyDeclaration(node);
            case 160 /* FunctionType */:
            case 161 /* ConstructorType */:
            case 155 /* CallSignature */:
            case 156 /* ConstructSignature */:
                return checkSignatureDeclaration(node);
            case 157 /* IndexSignature */:
                return checkSignatureDeclaration(node);
            case SyntaxKind.MethodDeclaration:
            case 150 /* MethodSignature */:
                return checkMethodDeclaration(node);
            case 152 /* Constructor */:
                return checkConstructorDeclaration(node);
            case 153 /* GetAccessor */:
            case 154 /* SetAccessor */:
                return checkAccessorDeclaration(node);
            case 159 /* TypeReference */:
                return checkTypeReferenceNode(node);
            case 158 /* TypePredicate */:
                return checkTypePredicate(node);
            case 162 /* TypeQuery */:
                return checkTypeQuery(node);
            case 163 /* TypeLiteral */:
                return checkTypeLiteral(node);
            case 164 /* ArrayType */:
                return checkArrayType(node);
            case 165 /* TupleType */:
                return checkTupleType(node);
            case 166 /* UnionType */:
            case 167 /* IntersectionType */:
                return checkUnionOrIntersectionType(node);
            case 168 /* ParenthesizedType */:
            case 170 /* TypeOperator */:
                return checkSourceElement(node.type);
            case 280 /* JSDocAugmentsTag */:
                return checkJSDocAugmentsTag(node);
            case 286 /* JSDocTypedefTag */:
                return checkJSDocTypedefTag(node);
            case 282 /* JSDocParameterTag */:
                return checkJSDocParameterTag(node);
            case 276 /* JSDocFunctionType */:
                checkSignatureDeclaration(node);
            // falls through
            case 277 /* JSDocVariadicType */:
            case 274 /* JSDocNonNullableType */:
            case 273 /* JSDocNullableType */:
            case 271 /* JSDocAllType */:
            case 272 /* JSDocUnknownType */:
                if (!ts.isInJavaScriptFile(node) && !ts.isInJSDoc(node)) {
                    grammarErrorOnNode(node, ts.Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments);
                }
                return;
            case 270 /* JSDocTypeExpression */:
                return checkSourceElement(node.type);
            case 171 /* IndexedAccessType */:
                return checkIndexedAccessType(node);
            case 172 /* MappedType */:
                return checkMappedType(node);
            case 228 /* FunctionDeclaration */:
                return checkFunctionDeclaration(node);
            case 207 /* Block */:
            case 234 /* ModuleBlock */:
                return checkBlock(node);
            case SyntaxKind.VariableStatement:
                return checkVariableStatement(node);
            case 210 /* ExpressionStatement */:
                return checkExpressionStatement(node);
            case 211 /* IfStatement */:
                return checkIfStatement(node);
            case 212 /* DoStatement */:
                return checkDoStatement(node);
            case 213 /* WhileStatement */:
                return checkWhileStatement(node);
            case SyntaxKind.ForStatement:
                return checkForStatement(node);
            case 215 /* ForInStatement */:
                return checkForInStatement(node);
            case SyntaxKind.ForOfStatement:
                return checkForOfStatement(node);
            case 217 /* ContinueStatement */:
            case 218 /* BreakStatement */:
                return checkBreakOrContinueStatement(node);
            case 219 /* ReturnStatement */:
                return checkReturnStatement(node);
            case 220 /* WithStatement */:
                return checkWithStatement(node);
            case 221 /* SwitchStatement */:
                return checkSwitchStatement(node);
            case 222 /* LabeledStatement */:
                return checkLabeledStatement(node);
            case 223 /* ThrowStatement */:
                return checkThrowStatement(node);
            case 224 /* TryStatement */:
                return checkTryStatement(node);
            case SyntaxKind.VariableDeclaration:
                return checkVariableDeclaration(node);
            case 176 /* BindingElement */:
                return checkBindingElement(node);
            case SyntaxKind.ClassDeclaration:
                return checkClassDeclaration(node);
            case SyntaxKind.InterfaceDeclaration:
                return checkInterfaceDeclaration(node);
            case 231 /* TypeAliasDeclaration */:
                return checkTypeAliasDeclaration(node);
            case SyntaxKind.EnumDeclaration:
                return checkEnumDeclaration(node);
            case SyntaxKind.ModuleDeclaration:
                return checkModuleDeclaration(node);
            case 238 /* ImportDeclaration */:
                return checkImportDeclaration(node);
            case 237 /* ImportEqualsDeclaration */:
                return checkImportEqualsDeclaration(node);
            case 244 /* ExportDeclaration */:
                return checkExportDeclaration(node);
            case SyntaxKind.ExportAssignment:
                return checkExportAssignment(node);
            case 209 /* EmptyStatement */:
                checkGrammarStatementInAmbientContext(node);
                return;
            case 225 /* DebuggerStatement */:
                checkGrammarStatementInAmbientContext(node);
                return;
            case 247 /* MissingDeclaration */:
                return checkMissingDeclaration(node);
        }
    }
    // Function and class expression bodies are checked after all statements in the enclosing body. This is
    // to ensure constructs like the following are permitted:
    //     const foo = function () {
    //        const s = foo();
    //        return "hello";
    //     }
    // Here, performing a full type check of the body of the function expression whilst in the process of
    // determining the type of foo would cause foo to be given type any because of the recursive reference.
    // Delaying the type check of the body ensures foo has been assigned a type.
    function checkNodeDeferred(node) {
        if (deferredNodes) {
            deferredNodes.push(node);
        }
    }
    function checkDeferredNodes() {
        for (let _i = 0, deferredNodes_1 = deferredNodes; _i < deferredNodes_1.length; _i++) {
            let node = deferredNodes_1[_i];
            switch (node.kind) {
                case 186 /* FunctionExpression */:
                case 187 /* ArrowFunction */:
                case SyntaxKind.MethodDeclaration:
                case 150 /* MethodSignature */:
                    checkFunctionExpressionOrObjectLiteralMethodDeferred(node);
                    break;
                case 153 /* GetAccessor */:
                case 154 /* SetAccessor */:
                    checkAccessorDeclaration(node);
                    break;
                case SyntaxKind.ClassExpression:
                    checkClassExpressionDeferred(node);
                    break;
            }
        }
    }
    function checkSourceFile(node) {
        ts.performance.mark("beforeCheck");
        checkSourceFileWorker(node);
        ts.performance.mark("afterCheck");
        ts.performance.measure("Check", "beforeCheck", "afterCheck");
    }
    // Fully type check a source file and collect the relevant diagnostics.
    function checkSourceFileWorker(node) {
        let links = getNodeLinks(node);
        if (!(links.flags & 1 /* TypeChecked */)) {
            // If skipLibCheck is enabled, skip type checking if file is a declaration file.
            // If skipDefaultLibCheck is enabled, skip type checking if file contains a
            // '/// <reference no-default-lib="true"/>' directive.
            if (compilerOptions.skipLibCheck && node.isDeclarationFile || compilerOptions.skipDefaultLibCheck && node.hasNoDefaultLib) {
                return;
            }
            // Grammar checking
            checkGrammarSourceFile(node);
            ts.clear(potentialThisCollisions);
            ts.clear(potentialNewTargetCollisions);
            deferredNodes = [];
            deferredUnusedIdentifierNodes = produceDiagnostics && noUnusedIdentifiers ? [] : undefined;
            flowAnalysisDisabled = false;
            ts.forEach(node.statements, checkSourceElement);
            checkDeferredNodes();
            if (ts.isExternalModule(node)) {
                registerForUnusedIdentifiersCheck(node);
            }
            if (!node.isDeclarationFile) {
                checkUnusedIdentifiers();
            }
            deferredNodes = undefined;
            deferredUnusedIdentifierNodes = undefined;
            if (ts.isExternalOrCommonJsModule(node)) {
                checkExternalModuleExports(node);
            }
            if (potentialThisCollisions.length) {
                ts.forEach(potentialThisCollisions, checkIfThisIsCapturedInEnclosingScope);
                ts.clear(potentialThisCollisions);
            }
            if (potentialNewTargetCollisions.length) {
                ts.forEach(potentialNewTargetCollisions, checkIfNewTargetIsCapturedInEnclosingScope);
                ts.clear(potentialNewTargetCollisions);
            }
            links.flags |= 1 /* TypeChecked */;
        }
    }
    function getDiagnostics(sourceFile, ct) {
        try {
            // Record the cancellation token so it can be checked later on during checkSourceElement.
            // Do this in a finally block so we can ensure that it gets reset back to nothing after
            // this call is done.
            cancellationToken = ct;
            return getDiagnosticsWorker(sourceFile);
        }
        finally {
            cancellationToken = undefined;
        }
    }
    function getDiagnosticsWorker(sourceFile) {
        throwIfNonDiagnosticsProducing();
        if (sourceFile) {
            // Some global diagnostics are deferred until they are needed and
            // may not be reported in the firt call to getGlobalDiagnostics.
            // We should catch these changes and report them.
            let previousGlobalDiagnostics = diagnostics.getGlobalDiagnostics();
            let previousGlobalDiagnosticsSize = previousGlobalDiagnostics.length;
            checkSourceFile(sourceFile);
            let semanticDiagnostics = diagnostics.getDiagnostics(sourceFile.fileName);
            let currentGlobalDiagnostics = diagnostics.getGlobalDiagnostics();
            if (currentGlobalDiagnostics !== previousGlobalDiagnostics) {
                // If the arrays are not the same reference, new diagnostics were added.
                let deferredGlobalDiagnostics = ts.relativeComplement(previousGlobalDiagnostics, currentGlobalDiagnostics, ts.compareDiagnostics);
                return ts.concatenate(deferredGlobalDiagnostics, semanticDiagnostics);
            }
            else if (previousGlobalDiagnosticsSize === 0 && currentGlobalDiagnostics.length > 0) {
                // If the arrays are the same reference, but the length has changed, a single
                // new diagnostic was added as DiagnosticCollection attempts to reuse the
                // same array.
                return ts.concatenate(currentGlobalDiagnostics, semanticDiagnostics);
            }
            return semanticDiagnostics;
        }
        // Global diagnostics are always added when a file is not provided to
        // getDiagnostics
        ts.forEach(thing.getSourceFiles(), checkSourceFile);
        return diagnostics.getDiagnostics();
    }
    function getGlobalDiagnostics() {
        throwIfNonDiagnosticsProducing();
        return diagnostics.getGlobalDiagnostics();
    }
    function throwIfNonDiagnosticsProducing() {
        if (!produceDiagnostics) {
            throw new Error("Trying to get diagnostics from a type checker that does not produce them.");
        }
    }
    // Language service support
    function isInsideWithStatementBody(node) {
        if (node) {
            while (node.parent) {
                if (node.parent.kind === 220 /* WithStatement */ && node.parent.statement === node) {
                    return true;
                }
                node = node.parent;
            }
        }
        return false;
    }
    function getSymbolsInScope(location, meaning) {
        if (isInsideWithStatementBody(location)) {
            // We cannot answer semantic questions within a with block, do not proceed any further
            return [];
        }
        let symbols = ts.createSymbolTable();
        let isStatic = false;
        populateSymbols();
        return symbolsToArray(symbols);
        function populateSymbols() {
            while (location) {
                if (location.locals && !isGlobalSourceFile(location)) {
                    copySymbols(location.locals, meaning);
                }
                switch (location.kind) {
                    case SyntaxKind.ModuleDeclaration:
                        copySymbols(getSymbolOfNode(location).exports, meaning & 2623475 /* ModuleMember */);
                        break;
                    case SyntaxKind.EnumDeclaration:
                        copySymbols(getSymbolOfNode(location).exports, meaning & 8 /* EnumMember */);
                        break;
                    case SyntaxKind.ClassExpression:
                        let className = location.name;
                        if (className) {
                            copySymbol(location.symbol, meaning);
                        }
                    // falls through
                    // this fall-through is necessary because we would like to handle
                    // type parameter inside class expression similar to how we handle it in classDeclaration and interface Declaration
                    case SyntaxKind.ClassDeclaration:
                    case SyntaxKind.InterfaceDeclaration:
                        // If we didn't come from static member of class or interface,
                        // add the type parameters into the symbol table
                        // (type parameters of classDeclaration/classExpression and interface are in member property of the symbol.
                        // Note: that the memberFlags come from previous iteration.
                        if (!isStatic) {
                            copySymbols(getSymbolOfNode(location).members, meaning & SymbolFlags.Type);
                        }
                        break;
                    case 186 /* FunctionExpression */:
                        let funcName = location.name;
                        if (funcName) {
                            copySymbol(location.symbol, meaning);
                        }
                        break;
                }
                if (ts.introducesArgumentsExoticObject(location)) {
                    copySymbol(argumentsSymbol, meaning);
                }
                isStatic = ts.hasModifier(location, ModifierFlags.Static);
                location = location.parent;
            }
            copySymbols(globals, meaning);
        }
        /**
         * Copy the given symbol into symbol tables if the symbol has the given meaning
         * and it doesn't already existed in the symbol table
         * @param key a key for storing in symbol table; if undefined, use symbol.name
         * @param symbol the symbol to be added into symbol table
         * @param meaning meaning of symbol to filter by before adding to symbol table
         */
        function copySymbol(symbol, meaning) {
            if (ts.getCombinedLocalAndExportSymbolFlags(symbol) & meaning) {
                let id = symbol.escapedName;
                // We will copy all symbol regardless of its reserved name because
                // symbolsToArray will check whether the key is a reserved name and
                // it will not copy symbol with reserved name to the array
                if (!symbols.has(id)) {
                    symbols.set(id, symbol);
                }
            }
        }
        function copySymbols(source, meaning) {
            if (meaning) {
                source.forEach(function (symbol) {
                    copySymbol(symbol, meaning);
                });
            }
        }
    }
    function isTypeDeclarationName(name) {
        return name.kind === 71 /* Identifier */ &&
            isTypeDeclaration(name.parent) &&
            name.parent.name === name;
    }
    function isTypeDeclaration(node) {
        switch (node.kind) {
            case SyntaxKind.TypeParameter:
            case SyntaxKind.ClassDeclaration:
            case SyntaxKind.InterfaceDeclaration:
            case 231 /* TypeAliasDeclaration */:
            case SyntaxKind.EnumDeclaration:
                return true;
        }
    }
    // True if the given identifier is part of a type reference
    function isTypeReferenceIdentifier(entityName) {
        let node = entityName;
        while (node.parent && node.parent.kind === 143 /* QualifiedName */) {
            node = node.parent;
        }
        return node.parent && node.parent.kind === 159 /* TypeReference */;
    }
    function isHeritageClauseElementIdentifier(entityName) {
        let node = entityName;
        while (node.parent && node.parent.kind === 179 /* PropertyAccessExpression */) {
            node = node.parent;
        }
        return node.parent && node.parent.kind === 201 /* ExpressionWithTypeArguments */;
    }
    function forEachEnclosingClass(node, callback) {
        let result;
        while (true) {
            node = ts.getContainingClass(node);
            if (!node)
                break;
            if (result = callback(node))
                break;
        }
        return result;
    }
    function isNodeWithinClass(node, classDeclaration) {
        return !!forEachEnclosingClass(node, function (n) { return n === classDeclaration; });
    }
    function getLeftSideOfImportEqualsOrExportAssignment(nodeOnRightSide) {
        while (nodeOnRightSide.parent.kind === 143 /* QualifiedName */) {
            nodeOnRightSide = nodeOnRightSide.parent;
        }
        if (nodeOnRightSide.parent.kind === 237 /* ImportEqualsDeclaration */) {
            return nodeOnRightSide.parent.moduleReference === nodeOnRightSide && nodeOnRightSide.parent;
        }
        if (nodeOnRightSide.parent.kind === SyntaxKind.ExportAssignment) {
            return nodeOnRightSide.parent.expression === nodeOnRightSide && nodeOnRightSide.parent;
        }
        return undefined;
    }
    function isInRightSideOfImportOrExportAssignment(node) {
        return getLeftSideOfImportEqualsOrExportAssignment(node) !== undefined;
    }
    function getSpecialPropertyAssignmentSymbolFromEntityName(entityName) {
        let specialPropertyAssignmentKind = ts.getSpecialPropertyAssignmentKind(entityName.parent.parent);
        switch (specialPropertyAssignmentKind) {
            case 1 /* ExportsProperty */:
            case 3 /* PrototypeProperty */:
                return getSymbolOfNode(entityName.parent);
            case 4 /* ThisProperty */:
            case 2 /* ModuleExports */:
            case 5 /* Property */:
                return getSymbolOfNode(entityName.parent.parent);
        }
    }
    function getSymbolOfEntityNameOrPropertyAccessExpression(entityName) {
        if (ts.isDeclarationName(entityName)) {
            return getSymbolOfNode(entityName.parent);
        }
        if (ts.isInJavaScriptFile(entityName) &&
            entityName.parent.kind === 179 /* PropertyAccessExpression */ &&
            entityName.parent === entityName.parent.parent.left) {
            // Check if this is a special property assignment
            let specialPropertyAssignmentSymbol = getSpecialPropertyAssignmentSymbolFromEntityName(entityName);
            if (specialPropertyAssignmentSymbol) {
                return specialPropertyAssignmentSymbol;
            }
        }
        if (entityName.parent.kind === SyntaxKind.ExportAssignment && ts.isEntityNameExpression(entityName)) {
            return resolveEntityName(entityName,
            /*all meanings*/ SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias);
        }
        if (entityName.kind !== 179 /* PropertyAccessExpression */ && isInRightSideOfImportOrExportAssignment(entityName)) {
            // Since we already checked for ExportAssignment, this really could only be an Import
            let importEqualsDeclaration = ts.getAncestor(entityName, 237 /* ImportEqualsDeclaration */);
            ts.Debug.assert(importEqualsDeclaration !== undefined);
            return getSymbolOfPartOfRightHandSideOfImportEquals(entityName, /*dontResolveAlias*/ true);
        }
        if (ts.isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {
            entityName = entityName.parent;
        }
        if (isHeritageClauseElementIdentifier(entityName)) {
            let meaning = 0 /* None */;
            // In an interface or class, we're definitely interested in a type.
            if (entityName.parent.kind === 201 /* ExpressionWithTypeArguments */) {
                meaning = SymbolFlags.Type;
                // In a class 'extends' clause we are also looking for a value.
                if (ts.isExpressionWithTypeArgumentsInClassExtendsClause(entityName.parent)) {
                    meaning |= SymbolFlags.Value;
                }
            }
            else {
                meaning = SymbolFlags.Namespace;
            }
            meaning |= SymbolFlags.Alias;
            let entityNameSymbol = resolveEntityName(entityName, meaning);
            if (entityNameSymbol) {
                return entityNameSymbol;
            }
        }
        if (entityName.parent.kind === 282 /* JSDocParameterTag */) {
            return ts.getParameterSymbolFromJSDoc(entityName.parent);
        }
        if (entityName.parent.kind === SyntaxKind.TypeParameter && entityName.parent.parent.kind === 285 /* JSDocTemplateTag */) {
            ts.Debug.assert(!ts.isInJavaScriptFile(entityName)); // Otherwise `isDeclarationName` would have been true.
            let typeParameter = ts.getTypeParameterFromJsDoc(entityName.parent);
            return typeParameter && typeParameter.symbol;
        }
        if (ts.isPartOfExpression(entityName)) {
            if (ts.nodeIsMissing(entityName)) {
                // Missing entity name.
                return undefined;
            }
            if (entityName.kind === 71 /* Identifier */) {
                if (ts.isJSXTagName(entityName) && isJsxIntrinsicIdentifier(entityName)) {
                    return getIntrinsicTagSymbol(entityName.parent);
                }
                return resolveEntityName(entityName, SymbolFlags.Value, /*ignoreErrors*/ false, /*dontResolveAlias*/ true);
            }
            else if (entityName.kind === 179 /* PropertyAccessExpression */ || entityName.kind === 143 /* QualifiedName */) {
                let links = getNodeLinks(entityName);
                if (links.resolvedSymbol) {
                    return links.resolvedSymbol;
                }
                if (entityName.kind === 179 /* PropertyAccessExpression */) {
                    checkPropertyAccessExpression(entityName);
                }
                else {
                    checkQualifiedName(entityName);
                }
                return links.resolvedSymbol;
            }
        }
        else if (isTypeReferenceIdentifier(entityName)) {
            let meaning = entityName.parent.kind === 159 /* TypeReference */ ? SymbolFlags.Type : SymbolFlags.Namespace;
            return resolveEntityName(entityName, meaning, /*ignoreErrors*/ false, /*dontResolveAlias*/ true);
        }
        else if (entityName.parent.kind === 256 /* JsxAttribute */) {
            return getJsxAttributePropertySymbol(entityName.parent);
        }
        if (entityName.parent.kind === 158 /* TypePredicate */) {
            return resolveEntityName(entityName, /*meaning*/ 1 /* FunctionScopedVariable */);
        }
        // Do we want to return undefined here?
        return undefined;
    }
    function getSymbolAtLocation(node) {
        if (node.kind === SyntaxKind.SourceFile) {
            return ts.isExternalModule(node) ? getMergedSymbol(node.symbol) : undefined;
        }
        if (isInsideWithStatementBody(node)) {
            // We cannot answer semantic questions within a with block, do not proceed any further
            return undefined;
        }
        if (isDeclarationNameOrImportPropertyName(node)) {
            // This is a declaration, call getSymbolOfNode
            return getSymbolOfNode(node.parent);
        }
        else if (ts.isLiteralComputedPropertyDeclarationName(node)) {
            return getSymbolOfNode(node.parent.parent);
        }
        if (node.kind === 71 /* Identifier */) {
            if (isInRightSideOfImportOrExportAssignment(node)) {
                return getSymbolOfEntityNameOrPropertyAccessExpression(node);
            }
            else if (node.parent.kind === 176 /* BindingElement */ &&
                node.parent.parent.kind === 174 /* ObjectBindingPattern */ &&
                node === node.parent.propertyName) {
                let typeOfPattern = getTypeOfNode(node.parent.parent);
                let propertyDeclaration = typeOfPattern && getPropertyOfType(typeOfPattern, node.escapedText);
                if (propertyDeclaration) {
                    return propertyDeclaration;
                }
            }
        }
        switch (node.kind) {
            case 71 /* Identifier */:
            case 179 /* PropertyAccessExpression */:
            case 143 /* QualifiedName */:
                return getSymbolOfEntityNameOrPropertyAccessExpression(node);
            case 99 /* ThisKeyword */:
                let container = ts.getThisContainer(node, /*includeArrowFunctions*/ false);
                if (ts.isFunctionLike(container)) {
                    let sig = getSignatureFromDeclaration(container);
                    if (sig.thisParameter) {
                        return sig.thisParameter;
                    }
                }
                if (ts.isInExpressionContext(node)) {
                    return checkExpression(node).symbol;
                }
            // falls through
            case 169 /* ThisType */:
                return getTypeFromThisTypeNode(node).symbol;
            case 97 /* SuperKeyword */:
                return checkExpression(node).symbol;
            case 123 /* ConstructorKeyword */:
                // constructor keyword for an overload, should take us to the definition if it exist
                let constructorDeclaration = node.parent;
                if (constructorDeclaration && constructorDeclaration.kind === 152 /* Constructor */) {
                    return constructorDeclaration.parent.symbol;
                }
                return undefined;
            case 9 /* StringLiteral */:
                // 1). import x = require("./mo/*gotToDefinitionHere*/d")
                // 2). External module name in an import declaration
                // 3). Dynamic import call or require in javascript
                if ((ts.isExternalModuleImportEqualsDeclaration(node.parent.parent) && ts.getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) === node) ||
                    ((node.parent.kind === 238 /* ImportDeclaration */ || node.parent.kind === 244 /* ExportDeclaration */) && node.parent.moduleSpecifier === node) ||
                    ((ts.isInJavaScriptFile(node) && ts.isRequireCall(node.parent, /*checkArgumentIsStringLiteral*/ false)) || ts.isImportCall(node.parent))) {
                    return resolveExternalModuleName(node, node);
                }
            // falls through
            case 8 /* NumericLiteral */:
                // index access
                let objectType = ts.isElementAccessExpression(node.parent)
                    ? node.parent.argumentExpression === node ? getTypeOfExpression(node.parent.expression) : undefined
                    : ts.isLiteralTypeNode(node.parent) && ts.isIndexedAccessTypeNode(node.parent.parent)
                        ? getTypeFromTypeNode(node.parent.parent.objectType)
                        : undefined;
                return objectType && getPropertyOfType(objectType, ts.escapeLeadingUnderscores(node.text));
            case 79 /* DefaultKeyword */:
                return getSymbolOfNode(node.parent);
            default:
                return undefined;
        }
    }
    function getShorthandAssignmentValueSymbol(location) {
        // The function returns a value symbol of an identifier in the short-hand property assignment.
        // This is necessary as an identifier in short-hand property assignment can contains two meaning:
        // property name and property value.
        if (location && location.kind === 265 /* ShorthandPropertyAssignment */) {
            return resolveEntityName(location.name, SymbolFlags.Value | SymbolFlags.Alias);
        }
        return undefined;
    }
    /** Returns the target of an export specifier without following aliases */
    function getExportSpecifierLocalTargetSymbol(node) {
        return node.parent.parent.moduleSpecifier ?
            getExternalModuleMember(node.parent.parent, node) :
            resolveEntityName(node.propertyName || node.name, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias);
    }
    function getTypeOfNode(node) {
        if (isInsideWithStatementBody(node)) {
            // We cannot answer semantic questions within a with block, do not proceed any further
            return unknownType;
        }
        if (ts.isPartOfTypeNode(node)) {
            let typeFromTypeNode = getTypeFromTypeNode(node);
            if (typeFromTypeNode && ts.isExpressionWithTypeArgumentsInClassImplementsClause(node)) {
                let containingClass = ts.getContainingClass(node);
                let classType = getTypeOfNode(containingClass);
                typeFromTypeNode = getTypeWithThisArgument(typeFromTypeNode, classType.thisType);
            }
            return typeFromTypeNode;
        }
        if (ts.isPartOfExpression(node)) {
            return getRegularTypeOfExpression(node);
        }
        if (ts.isExpressionWithTypeArgumentsInClassExtendsClause(node)) {
            // A SyntaxKind.ExpressionWithTypeArguments is considered a type node, except when it occurs in the
            // extends clause of a class. We handle that case here.
            let classNode = ts.getContainingClass(node);
            let classType = getDeclaredTypeOfSymbol(getSymbolOfNode(classNode));
            let baseType = getBaseTypes(classType)[0];
            return baseType && getTypeWithThisArgument(baseType, classType.thisType);
        }
        if (isTypeDeclaration(node)) {
            // In this case, we call getSymbolOfNode instead of getSymbolAtLocation because it is a declaration
            let symbol = getSymbolOfNode(node);
            return getDeclaredTypeOfSymbol(symbol);
        }
        if (isTypeDeclarationName(node)) {
            let symbol = getSymbolAtLocation(node);
            return symbol && getDeclaredTypeOfSymbol(symbol);
        }
        if (ts.isDeclaration(node)) {
            // In this case, we call getSymbolOfNode instead of getSymbolAtLocation because it is a declaration
            let symbol = getSymbolOfNode(node);
            return getTypeOfSymbol(symbol);
        }
        if (isDeclarationNameOrImportPropertyName(node)) {
            let symbol = getSymbolAtLocation(node);
            return symbol && getTypeOfSymbol(symbol);
        }
        if (ts.isBindingPattern(node)) {
            return getTypeForVariableLikeDeclaration(node.parent, /*includeOptionality*/ true);
        }
        if (isInRightSideOfImportOrExportAssignment(node)) {
            let symbol = getSymbolAtLocation(node);
            let declaredType = symbol && getDeclaredTypeOfSymbol(symbol);
            return declaredType !== unknownType ? declaredType : getTypeOfSymbol(symbol);
        }
        return unknownType;
    }
    // Gets the type of object literal or array literal of destructuring assignment.
    // { a } from
    //     for ( { a } of elems) {
    //     }
    // [ a ] from
    //     [a] = [ some array ...]
    function getTypeOfArrayLiteralOrObjectLiteralDestructuringAssignment(expr) {
        ts.Debug.assert(expr.kind === 178 /* ObjectLiteralExpression */ || expr.kind === 177 /* ArrayLiteralExpression */);
        // If this is from "for of"
        //     for ( { a } of elems) {
        //     }
        if (expr.parent.kind === SyntaxKind.ForOfStatement) {
            let iteratedType = checkRightHandSideOfForOf(expr.parent.expression, expr.parent.awaitModifier);
            return checkDestructuringAssignment(expr, iteratedType || unknownType);
        }
        // If this is from "for" initializer
        //     for ({a } = elems[0];.....) { }
        if (expr.parent.kind === 194 /* BinaryExpression */) {
            let iteratedType = getTypeOfExpression(expr.parent.right);
            return checkDestructuringAssignment(expr, iteratedType || unknownType);
        }
        // If this is from nested object binding pattern
        //     for ({ skills: { primary, secondary } } = multiRobot, i = 0; i < 1; i++) {
        if (expr.parent.kind === 264 /* PropertyAssignment */) {
            let typeOfParentObjectLiteral = getTypeOfArrayLiteralOrObjectLiteralDestructuringAssignment(expr.parent.parent);
            return checkObjectLiteralDestructuringPropertyAssignment(typeOfParentObjectLiteral || unknownType, expr.parent);
        }
        // Array literal assignment - array destructuring pattern
        ts.Debug.assert(expr.parent.kind === 177 /* ArrayLiteralExpression */);
        //    [{ property1: p1, property2 }] = elems;
        let typeOfArrayLiteral = getTypeOfArrayLiteralOrObjectLiteralDestructuringAssignment(expr.parent);
        let elementType = checkIteratedTypeOrElementType(typeOfArrayLiteral || unknownType, expr.parent, /*allowStringInput*/ false, /*allowAsyncIterables*/ false) || unknownType;
        return checkArrayLiteralDestructuringElementAssignment(expr.parent, typeOfArrayLiteral, ts.indexOf(expr.parent.elements, expr), elementType || unknownType);
    }
    // Gets the property symbol corresponding to the property in destructuring assignment
    // 'property1' from
    //     for ( { property1: a } of elems) {
    //     }
    // 'property1' at location 'a' from:
    //     [a] = [ property1, property2 ]
    function getPropertySymbolOfDestructuringAssignment(location) {
        // Get the type of the object or array literal and then look for property of given name in the type
        let typeOfObjectLiteral = getTypeOfArrayLiteralOrObjectLiteralDestructuringAssignment(location.parent.parent);
        return typeOfObjectLiteral && getPropertyOfType(typeOfObjectLiteral, location.escapedText);
    }
    function getRegularTypeOfExpression(expr) {
        if (ts.isRightSideOfQualifiedNameOrPropertyAccess(expr)) {
            expr = expr.parent;
        }
        return getRegularTypeOfLiteralType(getTypeOfExpression(expr));
    }
    /**
     * Gets either the static or instance type of a class element, based on
     * whether the element is declared as "static".
     */
    function getParentTypeOfClassElement(node) {
        let classSymbol = getSymbolOfNode(node.parent);
        return ts.hasModifier(node, ModifierFlags.Static)
            ? getTypeOfSymbol(classSymbol)
            : getDeclaredTypeOfSymbol(classSymbol);
    }
    // Return the list of properties of the given type, augmented with properties from Function
    // if the type has call or construct signatures
    function getAugmentedPropertiesOfType(type) {
        type = getApparentType(type);
        let propsByName = ts.createSymbolTable(getPropertiesOfType(type));
        if (getSignaturesOfType(type, 0 /* Call */).length || getSignaturesOfType(type, 1 /* Construct */).length) {
            ts.forEach(getPropertiesOfType(globalFunctionType), function (p) {
                if (!propsByName.has(p.escapedName)) {
                    propsByName.set(p.escapedName, p);
                }
            });
        }
        return getNamedMembers(propsByName);
    }
    function getRootSymbols(symbol) {
        if (ts.getCheckFlags(symbol) & 6 /* Synthetic */) {
            let symbols_4 = [];
            let name_3 = symbol.escapedName;
            ts.forEach(getSymbolLinks(symbol).containingType.types, function (t) {
                let symbol = getPropertyOfType(t, name_3);
                if (symbol) {
                    symbols_4.push(symbol);
                }
            });
            return symbols_4;
        }
        else if (symbol.flags & SymbolFlags.Transient) {
            let transient = symbol;
            if (transient.leftSpread) {
                return getRootSymbols(transient.leftSpread).concat(getRootSymbols(transient.rightSpread));
            }
            if (transient.syntheticOrigin) {
                return getRootSymbols(transient.syntheticOrigin);
            }
            let target = void 0;
            let next = symbol;
            while (next = getSymbolLinks(next).target) {
                target = next;
            }
            if (target) {
                return [target];
            }
        }
        return [symbol];
    }
    // Emitter support
    function isArgumentsLocalBinding(node) {
        if (!ts.isGeneratedIdentifier(node)) {
            node = ts.getParseTreeNode(node, ts.isIdentifier);
            if (node) {
                let isPropertyName_1 = node.parent.kind === 179 /* PropertyAccessExpression */ && node.parent.name === node;
                return !isPropertyName_1 && getReferencedValueSymbol(node) === argumentsSymbol;
            }
        }
        return false;
    }
    function moduleExportsSomeValue(moduleReferenceExpression) {
        let moduleSymbol = resolveExternalModuleName(moduleReferenceExpression.parent, moduleReferenceExpression);
        if (!moduleSymbol || ts.isShorthandAmbientModuleSymbol(moduleSymbol)) {
            // If the module is not found or is shorthand, assume that it may export a value.
            return true;
        }
        let hasExportAssignment = hasExportAssignmentSymbol(moduleSymbol);
        // if module has export assignment then 'resolveExternalModuleSymbol' will return resolved symbol for export assignment
        // otherwise it will return moduleSymbol itself
        moduleSymbol = resolveExternalModuleSymbol(moduleSymbol);
        let symbolLinks = getSymbolLinks(moduleSymbol);
        if (symbolLinks.exportsSomeValue === undefined) {
            // for export assignments - check if resolved symbol for RHS is itself a value
            // otherwise - check if at least one export is value
            symbolLinks.exportsSomeValue = hasExportAssignment
                ? !!(moduleSymbol.flags & SymbolFlags.Value)
                : ts.forEachEntry(getExportsOfModule(moduleSymbol), isValue);
        }
        return symbolLinks.exportsSomeValue;
        function isValue(s) {
            s = resolveSymbol(s);
            return s && !!(s.flags & SymbolFlags.Value);
        }
    }
    function isNameOfModuleOrEnumDeclaration(node) {
        let parent = node.parent;
        return parent && ts.isModuleOrEnumDeclaration(parent) && node === parent.name;
    }
    // When resolved as an expression identifier, if the given node references an exported entity, return the declaration
    // node of the exported entity's container. Otherwise, return undefined.
    function getReferencedExportContainer(node, prefixLocals) {
        node = ts.getParseTreeNode(node, ts.isIdentifier);
        if (node) {
            // When resolving the export container for the name of a module or enum
            // declaration, we need to start resolution at the declaration's container.
            // Otherwise, we could incorrectly resolve the export container as the
            // declaration if it contains an exported member with the same name.
            let symbol = getReferencedValueSymbol(node, /*startInDeclarationContainer*/ isNameOfModuleOrEnumDeclaration(node));
            if (symbol) {
                if (symbol.flags & 1048576 /* ExportValue */) {
                    // If we reference an exported entity within the same module declaration, then whether
                    // we prefix depends on the kind of entity. SymbolFlags.ExportHasLocal encompasses all the
                    // kinds that we do NOT prefix.
                    let exportSymbol = getMergedSymbol(symbol.exportSymbol);
                    if (!prefixLocals && exportSymbol.flags & 944 /* ExportHasLocal */) {
                        return undefined;
                    }
                    symbol = exportSymbol;
                }
                let parentSymbol_1 = getParentOfSymbol(symbol);
                if (parentSymbol_1) {
                    if (parentSymbol_1.flags & 512 /* ValueModule */ && parentSymbol_1.valueDeclaration.kind === SyntaxKind.SourceFile) {
                        let symbolFile = parentSymbol_1.valueDeclaration;
                        let referenceFile = ts.getSourceFileOfNode(node);
                        // If `node` accesses an export and that export isn't in the same file, then symbol is a namespace export, so return undefined.
                        let symbolIsUmdExport = symbolFile !== referenceFile;
                        return symbolIsUmdExport ? undefined : symbolFile;
                    }
                    return ts.findAncestor(node.parent, function (n) { return ts.isModuleOrEnumDeclaration(n) && getSymbolOfNode(n) === parentSymbol_1; });
                }
            }
        }
    }
    // When resolved as an expression identifier, if the given node references an import, return the declaration of
    // that import. Otherwise, return undefined.
    function getReferencedImportDeclaration(node) {
        node = ts.getParseTreeNode(node, ts.isIdentifier);
        if (node) {
            let symbol = getReferencedValueSymbol(node);
            // We should only get the declaration of an alias if there isn't a local value
            // declaration for the symbol
            if (isNonLocalAlias(symbol, /*excludes*/ SymbolFlags.Value)) {
                return getDeclarationOfAliasSymbol(symbol);
            }
        }
        return undefined;
    }
    function isSymbolOfDeclarationWithCollidingName(symbol) {
        if (symbol.flags & 418 /* BlockScoped */) {
            let links = getSymbolLinks(symbol);
            if (links.isDeclarationWithCollidingName === undefined) {
                let container = ts.getEnclosingBlockScopeContainer(symbol.valueDeclaration);
                if (ts.isStatementWithLocals(container)) {
                    let nodeLinks_1 = getNodeLinks(symbol.valueDeclaration);
                    if (resolveName(container.parent, symbol.escapedName, SymbolFlags.Value, /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ false)) {
                        // redeclaration - always should be renamed
                        links.isDeclarationWithCollidingName = true;
                    }
                    else if (nodeLinks_1.flags & 131072 /* CapturedBlockScopedBinding */) {
                        // binding is captured in the function
                        // should be renamed if:
                        // - binding is not top level - top level bindings never collide with anything
                        // AND
                        //   - binding is not declared in loop, should be renamed to avoid name reuse across siblings
                        //     let a, b
                        //     { let x = 1; a = () => x;  }
                        //     { let x = 100; b = () => x; }
                        //     console.log(a()); // should print '1'
                        //     console.log(b()); // should print '100'
                        //     OR
                        //   - binding is declared inside loop but not in inside initializer of iteration statement or directly inside loop body
                        //     * variables from initializer are passed to rewritten loop body as parameters so they are not captured directly
                        //     * variables that are declared immediately in loop body will become top level variable after loop is rewritten and thus
                        //       they will not collide with anything
                        let isDeclaredInLoop = nodeLinks_1.flags & 262144 /* BlockScopedBindingInLoop */;
                        let inLoopInitializer = ts.isIterationStatement(container, /*lookInLabeledStatements*/ false);
                        let inLoopBodyBlock = container.kind === 207 /* Block */ && ts.isIterationStatement(container.parent, /*lookInLabeledStatements*/ false);
                        links.isDeclarationWithCollidingName = !ts.isBlockScopedContainerTopLevel(container) && (!isDeclaredInLoop || (!inLoopInitializer && !inLoopBodyBlock));
                    }
                    else {
                        links.isDeclarationWithCollidingName = false;
                    }
                }
            }
            return links.isDeclarationWithCollidingName;
        }
        return false;
    }
    // When resolved as an expression identifier, if the given node references a nested block scoped entity with
    // a name that either hides an existing name or might hide it when compiled downlevel,
    // return the declaration of that entity. Otherwise, return undefined.
    function getReferencedDeclarationWithCollidingName(node) {
        if (!ts.isGeneratedIdentifier(node)) {
            node = ts.getParseTreeNode(node, ts.isIdentifier);
            if (node) {
                let symbol = getReferencedValueSymbol(node);
                if (symbol && isSymbolOfDeclarationWithCollidingName(symbol)) {
                    return symbol.valueDeclaration;
                }
            }
        }
        return undefined;
    }
    // Return true if the given node is a declaration of a nested block scoped entity with a name that either hides an
    // existing name or might hide a name when compiled downlevel
    function isDeclarationWithCollidingName(node) {
        node = ts.getParseTreeNode(node, ts.isDeclaration);
        if (node) {
            let symbol = getSymbolOfNode(node);
            if (symbol) {
                return isSymbolOfDeclarationWithCollidingName(symbol);
            }
        }
        return false;
    }
    function isValueAliasDeclaration(node) {
        switch (node.kind) {
            case 237 /* ImportEqualsDeclaration */:
            case 239 /* ImportClause */:
            case 240 /* NamespaceImport */:
            case 242 /* ImportSpecifier */:
            case SyntaxKind.ExportSpecifier:
                return isAliasResolvedToValue(getSymbolOfNode(node) || unknownSymbol);
            case 244 /* ExportDeclaration */:
                let exportClause = node.exportClause;
                return exportClause && ts.forEach(exportClause.elements, isValueAliasDeclaration);
            case SyntaxKind.ExportAssignment:
                return node.expression
                    && node.expression.kind === 71 /* Identifier */
                    ? isAliasResolvedToValue(getSymbolOfNode(node) || unknownSymbol)
                    : true;
        }
        return false;
    }
    function isTopLevelValueImportEqualsWithEntityName(node) {
        node = ts.getParseTreeNode(node, ts.isImportEqualsDeclaration);
        if (node === undefined || node.parent.kind !== SyntaxKind.SourceFile || !ts.isInternalModuleImportEqualsDeclaration(node)) {
            // parent is not source file or it is not reference to internal module
            return false;
        }
        let isValue = isAliasResolvedToValue(getSymbolOfNode(node));
        return isValue && node.moduleReference && !ts.nodeIsMissing(node.moduleReference);
    }
    function isAliasResolvedToValue(symbol) {
        let target = resolveAlias(symbol);
        if (target === unknownSymbol) {
            return true;
        }
        // const enums and modules that contain only const enums are not considered values from the emit perspective
        // unless 'preserveConstEnums' option is set to true
        return target.flags & SymbolFlags.Value &&
            (compilerOptions.preserveConstEnums || !isConstEnumOrConstEnumOnlyModule(target));
    }
    function isConstEnumOrConstEnumOnlyModule(s) {
        return isConstEnumSymbol(s) || s.constEnumOnlyModule;
    }
    function isReferencedAliasDeclaration(node, checkChildren) {
        if (ts.isAliasSymbolDeclaration(node)) {
            let symbol = getSymbolOfNode(node);
            if (symbol && getSymbolLinks(symbol).referenced) {
                return true;
            }
        }
        if (checkChildren) {
            return ts.forEachChild(node, function (node) { return isReferencedAliasDeclaration(node, checkChildren); });
        }
        return false;
    }
    function isImplementationOfOverload(node) {
        if (ts.nodeIsPresent(node.body)) {
            let symbol = getSymbolOfNode(node);
            let signaturesOfSymbol = getSignaturesOfSymbol(symbol);
            // If this function body corresponds to function with multiple signature, it is implementation of overload
            // e.g.: function foo(a: string): string;
            //       function foo(a: number): number;
            //       function foo(a: any) { // This is implementation of the overloads
            //           return a;
            //       }
            return signaturesOfSymbol.length > 1 ||
                // If there is single signature for the symbol, it is overload if that signature isn't coming from the node
                // e.g.: function foo(a: string): string;
                //       function foo(a: any) { // This is implementation of the overloads
                //           return a;
                //       }
                (signaturesOfSymbol.length === 1 && signaturesOfSymbol[0].declaration !== node);
        }
        return false;
    }
    function isRequiredInitializedParameter(parameter) {
        return strictNullChecks &&
            !isOptionalParameter(parameter) &&
            parameter.initializer &&
            !ts.hasModifier(parameter, 92 /* ParameterPropertyModifier */);
    }
    function isOptionalUninitializedParameterProperty(parameter) {
        return strictNullChecks &&
            isOptionalParameter(parameter) &&
            !parameter.initializer &&
            ts.hasModifier(parameter, 92 /* ParameterPropertyModifier */);
    }
    function getNodeCheckFlags(node) {
        return getNodeLinks(node).flags;
    }
    function getEnumMemberValue(node) {
        computeEnumMemberValues(node.parent);
        return getNodeLinks(node).enumMemberValue;
    }
    function canHaveConstantValue(node) {
        switch (node.kind) {
            case 267 /* EnumMember */:
            case 179 /* PropertyAccessExpression */:
            case 180 /* ElementAccessExpression */:
                return true;
        }
        return false;
    }
    function getConstantValue(node) {
        if (node.kind === 267 /* EnumMember */) {
            return getEnumMemberValue(node);
        }
        let symbol = getNodeLinks(node).resolvedSymbol;
        if (symbol && (symbol.flags & 8 /* EnumMember */)) {
            // inline property\index accesses only for const enums
            if (ts.isConstEnumDeclaration(symbol.valueDeclaration.parent)) {
                return getEnumMemberValue(symbol.valueDeclaration);
            }
        }
        return undefined;
    }
    function isFunctionType(type) {
        return type.flags & TypeFlags.Object && getSignaturesOfType(type, 0 /* Call */).length > 0;
    }
    function getTypeReferenceSerializationKind(typeName, location) {
        // ensure both `typeName` and `location` are parse tree nodes.
        typeName = ts.getParseTreeNode(typeName, ts.isEntityName);
        if (!typeName)
            return ts.TypeReferenceSerializationKind.Unknown;
        if (location) {
            location = ts.getParseTreeNode(location);
            if (!location)
                return ts.TypeReferenceSerializationKind.Unknown;
        }
        // Resolve the symbol as a value to ensure the type can be reached at runtime during emit.
        let valueSymbol = resolveEntityName(typeName, SymbolFlags.Value, /*ignoreErrors*/ true, /*dontResolveAlias*/ false, location);
        // Resolve the symbol as a type so that we can provide a more useful hint for the type serializer.
        let typeSymbol = resolveEntityName(typeName, SymbolFlags.Type, /*ignoreErrors*/ true, /*dontResolveAlias*/ false, location);
        if (valueSymbol && valueSymbol === typeSymbol) {
            let globalPromiseSymbol = getGlobalPromiseConstructorSymbol(/*reportErrors*/ false);
            if (globalPromiseSymbol && valueSymbol === globalPromiseSymbol) {
                return ts.TypeReferenceSerializationKind.Promise;
            }
            let constructorType = getTypeOfSymbol(valueSymbol);
            if (constructorType && isConstructorType(constructorType)) {
                return ts.TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue;
            }
        }
        // We might not be able to resolve type symbol so use unknown type in that case (eg error case)
        if (!typeSymbol) {
            return ts.TypeReferenceSerializationKind.ObjectType;
        }
        let type = getDeclaredTypeOfSymbol(typeSymbol);
        if (type === unknownType) {
            return ts.TypeReferenceSerializationKind.Unknown;
        }
        else if (type.flags & 1 /* Any */) {
            return ts.TypeReferenceSerializationKind.ObjectType;
        }
        else if (isTypeAssignableToKind(type, 1024 /* Void */ | 6144 /* Nullable */ | 8192 /* Never */)) {
            return ts.TypeReferenceSerializationKind.VoidNullableOrNeverType;
        }
        else if (isTypeAssignableToKind(type, 136 /* BooleanLike */)) {
            return ts.TypeReferenceSerializationKind.BooleanType;
        }
        else if (isTypeAssignableToKind(type, 84 /* NumberLike */)) {
            return ts.TypeReferenceSerializationKind.NumberLikeType;
        }
        else if (isTypeAssignableToKind(type, 262178 /* StringLike */)) {
            return ts.TypeReferenceSerializationKind.StringLikeType;
        }
        else if (isTupleType(type)) {
            return ts.TypeReferenceSerializationKind.ArrayLikeType;
        }
        else if (isTypeAssignableToKind(type, 512 /* ESSymbol */)) {
            return ts.TypeReferenceSerializationKind.ESSymbolType;
        }
        else if (isFunctionType(type)) {
            return ts.TypeReferenceSerializationKind.TypeWithCallSignature;
        }
        else if (isArrayType(type)) {
            return ts.TypeReferenceSerializationKind.ArrayLikeType;
        }
        else {
            return ts.TypeReferenceSerializationKind.ObjectType;
        }
    }
    function writeTypeOfDeclaration(declaration, enclosingDeclaration, flags, writer) {
        // Get type of the symbol if this is the valid symbol otherwise get type at location
        let symbol = getSymbolOfNode(declaration);
        let type = symbol && !(symbol.flags & (2048 /* TypeLiteral */ | 131072 /* Signature */))
            ? getWidenedLiteralType(getTypeOfSymbol(symbol))
            : unknownType;
        if (flags & 8192 /* AddUndefined */) {
            type = getNullableType(type, 2048 /* Undefined */);
        }
        getSymbolDisplayBuilder().buildTypeDisplay(type, writer, enclosingDeclaration, flags);
    }
    function writeReturnTypeOfSignatureDeclaration(signatureDeclaration, enclosingDeclaration, flags, writer) {
        let signature = getSignatureFromDeclaration(signatureDeclaration);
        getSymbolDisplayBuilder().buildTypeDisplay(getReturnTypeOfSignature(signature), writer, enclosingDeclaration, flags);
    }
    function writeTypeOfExpression(expr, enclosingDeclaration, flags, writer) {
        let type = getWidenedType(getRegularTypeOfExpression(expr));
        getSymbolDisplayBuilder().buildTypeDisplay(type, writer, enclosingDeclaration, flags);
    }
    function hasGlobalName(name) {
        return globals.has(ts.escapeLeadingUnderscores(name));
    }
    function getReferencedValueSymbol(reference, startInDeclarationContainer) {
        let resolvedSymbol = getNodeLinks(reference).resolvedSymbol;
        if (resolvedSymbol) {
            return resolvedSymbol;
        }
        let location = reference;
        if (startInDeclarationContainer) {
            // When resolving the name of a declaration as a value, we need to start resolution
            // at a point outside of the declaration.
            let parent = reference.parent;
            if (ts.isDeclaration(parent) && reference === parent.name) {
                location = getDeclarationContainer(parent);
            }
        }
        return resolveName(location, reference.escapedText, SymbolFlags.Value | 1048576 /* ExportValue */ | SymbolFlags.Alias, /*nodeNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ true);
    }
    function getReferencedValueDeclaration(reference) {
        if (!ts.isGeneratedIdentifier(reference)) {
            reference = ts.getParseTreeNode(reference, ts.isIdentifier);
            if (reference) {
                let symbol = getReferencedValueSymbol(reference);
                if (symbol) {
                    return getExportSymbolOfValueSymbolIfExported(symbol).valueDeclaration;
                }
            }
        }
        return undefined;
    }
    function isLiteralConstDeclaration(node) {
        if (ts.isConst(node)) {
            let type = getTypeOfSymbol(getSymbolOfNode(node));
            return !!(type.flags & 96 /* StringOrNumberLiteral */ && type.flags & 1048576 /* FreshLiteral */);
        }
        return false;
    }
    function writeLiteralConstValue(node, writer) {
        let type = getTypeOfSymbol(getSymbolOfNode(node));
        writer.writeStringLiteral(literalTypeToString(type));
    }
    function createResolver() {
        // this variable and functions that use it are deliberately moved here from the outer scope
        // to avoid scope pollution
        let resolvedTypeReferenceDirectives = host.getResolvedTypeReferenceDirectives();
        let fileToDirective;
        if (resolvedTypeReferenceDirectives) {
            // populate reverse mapping: file path -> type reference directive that was resolved to this file
            fileToDirective = ts.createMap();
            resolvedTypeReferenceDirectives.forEach(function (resolvedDirective, key) {
                if (!resolvedDirective) {
                    return;
                }
                let file = thing.getSourceFile(resolvedDirective.resolvedFileName);
                fileToDirective.set(file.path, key);
            });
        }
        return {
            getReferencedExportContainer: getReferencedExportContainer,
            getReferencedImportDeclaration: getReferencedImportDeclaration,
            getReferencedDeclarationWithCollidingName: getReferencedDeclarationWithCollidingName,
            isDeclarationWithCollidingName: isDeclarationWithCollidingName,
            isValueAliasDeclaration: function (node) {
                node = ts.getParseTreeNode(node);
                // Synthesized nodes are always treated like values.
                return node ? isValueAliasDeclaration(node) : true;
            },
            hasGlobalName: hasGlobalName,
            isReferencedAliasDeclaration: function (node, checkChildren) {
                node = ts.getParseTreeNode(node);
                // Synthesized nodes are always treated as referenced.
                return node ? isReferencedAliasDeclaration(node, checkChildren) : true;
            },
            getNodeCheckFlags: function (node) {
                node = ts.getParseTreeNode(node);
                return node ? getNodeCheckFlags(node) : undefined;
            },
            isTopLevelValueImportEqualsWithEntityName: isTopLevelValueImportEqualsWithEntityName,
            isDeclarationVisible: isDeclarationVisible,
            isImplementationOfOverload: isImplementationOfOverload,
            isRequiredInitializedParameter: isRequiredInitializedParameter,
            isOptionalUninitializedParameterProperty: isOptionalUninitializedParameterProperty,
            writeTypeOfDeclaration: writeTypeOfDeclaration,
            writeReturnTypeOfSignatureDeclaration: writeReturnTypeOfSignatureDeclaration,
            writeTypeOfExpression: writeTypeOfExpression,
            isSymbolAccessible: isSymbolAccessible,
            isEntityNameVisible: isEntityNameVisible,
            getConstantValue: function (node) {
                node = ts.getParseTreeNode(node, canHaveConstantValue);
                return node ? getConstantValue(node) : undefined;
            },
            collectLinkedAliases: collectLinkedAliases,
            getReferencedValueDeclaration: getReferencedValueDeclaration,
            getTypeReferenceSerializationKind: getTypeReferenceSerializationKind,
            isOptionalParameter: isOptionalParameter,
            moduleExportsSomeValue: moduleExportsSomeValue,
            isArgumentsLocalBinding: isArgumentsLocalBinding,
            getExternalModuleFileFromDeclaration: getExternalModuleFileFromDeclaration,
            getTypeReferenceDirectivesForEntityName: getTypeReferenceDirectivesForEntityName,
            getTypeReferenceDirectivesForSymbol: getTypeReferenceDirectivesForSymbol,
            isLiteralConstDeclaration: isLiteralConstDeclaration,
            writeLiteralConstValue: writeLiteralConstValue,
            getJsxFactoryEntity: function () { return _jsxFactoryEntity; }
        };
        // defined here to avoid outer scope pollution
        function getTypeReferenceDirectivesForEntityName(node) {
            // program does not have any files with type reference directives - bail out
            if (!fileToDirective) {
                return undefined;
            }
            // property access can only be used as values
            // qualified names can only be used as types\namespaces
            // identifiers are treated as values only if they appear in type queries
            let meaning = (node.kind === 179 /* PropertyAccessExpression */) || (node.kind === 71 /* Identifier */ && isInTypeQuery(node))
                ? SymbolFlags.Value | 1048576 /* ExportValue */
                : SymbolFlags.Type | SymbolFlags.Namespace;
            let symbol = resolveEntityName(node, meaning, /*ignoreErrors*/ true);
            return symbol && symbol !== unknownSymbol ? getTypeReferenceDirectivesForSymbol(symbol, meaning) : undefined;
        }
        // defined here to avoid outer scope pollution
        function getTypeReferenceDirectivesForSymbol(symbol, meaning) {
            // program does not have any files with type reference directives - bail out
            if (!fileToDirective) {
                return undefined;
            }
            if (!isSymbolFromTypeDeclarationFile(symbol)) {
                return undefined;
            }
            // check what declarations in the symbol can contribute to the target meaning
            let typeReferenceDirectives;
            for (let _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                let decl = _a[_i];
                // check meaning of the local symbol to see if declaration needs to be analyzed further
                if (decl.symbol && decl.symbol.flags & meaning) {
                    let file = ts.getSourceFileOfNode(decl);
                    let typeReferenceDirective = fileToDirective.get(file.path);
                    if (typeReferenceDirective) {
                        (typeReferenceDirectives || (typeReferenceDirectives = [])).push(typeReferenceDirective);
                    }
                    else {
                        // found at least one entry that does not originate from type reference directive
                        return undefined;
                    }
                }
            }
            return typeReferenceDirectives;
        }
        function isSymbolFromTypeDeclarationFile(symbol) {
            // bail out if symbol does not have associated declarations (i.e. this is transient symbol created for property in binding pattern)
            if (!symbol.declarations) {
                return false;
            }
            // walk the parent chain for symbols to make sure that top level parent symbol is in the global scope
            // external modules cannot define or contribute to type declaration files
            let current = symbol;
            while (true) {
                let parent = getParentOfSymbol(current);
                if (parent) {
                    current = parent;
                }
                else {
                    break;
                }
            }
            if (current.valueDeclaration && current.valueDeclaration.kind === SyntaxKind.SourceFile && current.flags & 512 /* ValueModule */) {
                return false;
            }
            // check that at least one declaration of top level symbol originates from type declaration file
            for (let _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                let decl = _a[_i];
                let file = ts.getSourceFileOfNode(decl);
                if (fileToDirective.has(file.path)) {
                    return true;
                }
            }
            return false;
        }
    }
    function getExternalModuleFileFromDeclaration(declaration) {
        let specifier = ts.getExternalModuleName(declaration);
        let moduleSymbol = resolveExternalModuleNameWorker(specifier, specifier, /*moduleNotFoundError*/ undefined);
        if (!moduleSymbol) {
            return undefined;
        }
        return ts.getDeclarationOfKind(moduleSymbol, SyntaxKind.SourceFile);
    }
    function initializeTypeChecker() {
        // Bind all source files and propagate errors
        for (let _i = 0, _a = thing.getSourceFiles(); _i < _a.length; _i++) {
            let file = _a[_i];
            ts.bindSourceFile(file, compilerOptions);
        }
        // Initialize global symbol table
        let augmentations;
        for (let _b = 0, _c = thing.getSourceFiles(); _b < _c.length; _b++) {
            let file = _c[_b];
            if (!ts.isExternalOrCommonJsModule(file)) {
                mergeSymbolTable(globals, file.locals);
            }
            if (file.patternAmbientModules && file.patternAmbientModules.length) {
                patternAmbientModules = ts.concatenate(patternAmbientModules, file.patternAmbientModules);
            }
            if (file.moduleAugmentations.length) {
                (augmentations || (augmentations = [])).push(file.moduleAugmentations);
            }
            if (file.symbol && file.symbol.globalExports) {
                // Merge in UMD exports with first-in-wins semantics (see #9771)
                let source = file.symbol.globalExports;
                source.forEach(function (sourceSymbol, id) {
                    if (!globals.has(id)) {
                        globals.set(id, sourceSymbol);
                    }
                });
            }
        }
        if (augmentations) {
            // merge module augmentations.
            // this needs to be done after global symbol table is initialized to make sure that all ambient modules are indexed
            for (let _d = 0, augmentations_1 = augmentations; _d < augmentations_1.length; _d++) {
                let list = augmentations_1[_d];
                for (let _e = 0, list_1 = list; _e < list_1.length; _e++) {
                    let augmentation = list_1[_e];
                    mergeModuleAugmentation(augmentation);
                }
            }
        }
        // Setup global builtins
        addToSymbolTable(globals, builtinGlobals, ts.Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0);
        getSymbolLinks(undefinedSymbol).type = undefinedWideningType;
        getSymbolLinks(argumentsSymbol).type = getGlobalType("IArguments", /*arity*/ 0, /*reportErrors*/ true);
        getSymbolLinks(unknownSymbol).type = unknownType;
        // Initialize special types
        globalArrayType = getGlobalType("Array", /*arity*/ 1, /*reportErrors*/ true);
        globalObjectType = getGlobalType("Object", /*arity*/ 0, /*reportErrors*/ true);
        globalFunctionType = getGlobalType("Function", /*arity*/ 0, /*reportErrors*/ true);
        globalStringType = getGlobalType("String", /*arity*/ 0, /*reportErrors*/ true);
        globalNumberType = getGlobalType("Number", /*arity*/ 0, /*reportErrors*/ true);
        globalBooleanType = getGlobalType("Boolean", /*arity*/ 0, /*reportErrors*/ true);
        globalRegExpType = getGlobalType("RegExp", /*arity*/ 0, /*reportErrors*/ true);
        anyArrayType = createArrayType(anyType);
        autoArrayType = createArrayType(autoType);
        globalReadonlyArrayType = getGlobalTypeOrUndefined("ReadonlyArray", /*arity*/ 1);
        anyReadonlyArrayType = globalReadonlyArrayType ? createTypeFromGenericGlobalType(globalReadonlyArrayType, [anyType]) : anyArrayType;
        globalThisType = getGlobalTypeOrUndefined("ThisType", /*arity*/ 1);
    }
    function checkExternalEmitHelpers(location, helpers) {
        if ((requestedExternalEmitHelpers & helpers) !== helpers && compilerOptions.importHelpers) {
            let sourceFile = ts.getSourceFileOfNode(location);
            if (ts.isEffectiveExternalModule(sourceFile, compilerOptions) && !ts.isInAmbientContext(location)) {
                let helpersModule = resolveHelpersModule(sourceFile, location);
                if (helpersModule !== unknownSymbol) {
                    let uncheckedHelpers = helpers & ~requestedExternalEmitHelpers;
                    for (let helper = 1 /* FirstEmitHelper */; helper <= 65536 /* LastEmitHelper */; helper <<= 1) {
                        if (uncheckedHelpers & helper) {
                            let name = getHelperName(helper);
                            let symbol = getSymbol(helpersModule.exports, ts.escapeLeadingUnderscores(name), SymbolFlags.Value);
                            if (!symbol) {
                                error(location, ts.Diagnostics.This_syntax_requires_an_imported_helper_named_1_but_module_0_has_no_exported_member_1, ts.externalHelpersModuleNameText, name);
                            }
                        }
                    }
                }
                requestedExternalEmitHelpers |= helpers;
            }
        }
    }
    function getHelperName(helper) {
        switch (helper) {
            case 1 /* Extends */: return "__extends";
            case 2 /* Assign */: return "__assign";
            case 4 /* Rest */: return "__rest";
            case 8 /* Decorate */: return "__decorate";
            case 16 /* Metadata */: return "__metadata";
            case 32 /* Param */: return "__param";
            case 64 /* Awaiter */: return "__awaiter";
            case 128 /* Generator */: return "__generator";
            case 256 /* Values */: return "__values";
            case 512 /* Read */: return "__read";
            case 1024 /* Spread */: return "__spread";
            case 2048 /* Await */: return "__await";
            case 4096 /* AsyncGenerator */: return "__asyncGenerator";
            case 8192 /* AsyncDelegator */: return "__asyncDelegator";
            case 16384 /* AsyncValues */: return "__asyncValues";
            case 32768 /* ExportStar */: return "__exportStar";
            case 65536 /* MakeTemplateObject */: return "__makeTemplateObject";
            default: ts.Debug.fail("Unrecognized helper");
        }
    }
    function resolveHelpersModule(node, errorNode) {
        if (!externalHelpersModule) {
            externalHelpersModule = resolveExternalModule(node, ts.externalHelpersModuleNameText, ts.Diagnostics.This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found, errorNode) || unknownSymbol;
        }
        return externalHelpersModule;
    }
    // GRAMMAR CHECKING
    function checkGrammarDecorators(node) {
        if (!node.decorators) {
            return false;
        }
        if (!ts.nodeCanBeDecorated(node)) {
            if (node.kind === SyntaxKind.MethodDeclaration && !ts.nodeIsPresent(node.body)) {
                return grammarErrorOnFirstToken(node, ts.Diagnostics.A_decorator_can_only_decorate_a_method_implementation_not_an_overload);
            }
            else {
                return grammarErrorOnFirstToken(node, ts.Diagnostics.Decorators_are_not_valid_here);
            }
        }
        else if (node.kind === 153 /* GetAccessor */ || node.kind === 154 /* SetAccessor */) {
            let accessors = ts.getAllAccessorDeclarations(node.parent.members, node);
            if (accessors.firstAccessor.decorators && node === accessors.secondAccessor) {
                return grammarErrorOnFirstToken(node, ts.Diagnostics.Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name);
            }
        }
        return false;
    }
    function checkGrammarModifiers(node) {
        let quickResult = reportObviousModifierErrors(node);
        if (quickResult !== undefined) {
            return quickResult;
        }
        let lastStatic, lastDeclare, lastAsync, lastReadonly;
        let flags = 0 /* None */;
        for (let _i = 0, _a = node.modifiers; _i < _a.length; _i++) {
            let modifier = _a[_i];
            if (modifier.kind !== 131 /* ReadonlyKeyword */) {
                if (node.kind === SyntaxKind.PropertySignature || node.kind === 150 /* MethodSignature */) {
                    return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_type_member, ts.tokenToString(modifier.kind));
                }
                if (node.kind === 157 /* IndexSignature */) {
                    return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_an_index_signature, ts.tokenToString(modifier.kind));
                }
            }
            switch (modifier.kind) {
                case 76 /* ConstKeyword */:
                    if (node.kind !== SyntaxKind.EnumDeclaration && node.parent.kind === SyntaxKind.ClassDeclaration) {
                        return grammarErrorOnNode(node, ts.Diagnostics.A_class_member_cannot_have_the_0_keyword, ts.tokenToString(76 /* ConstKeyword */));
                    }
                    break;
                case 114 /* PublicKeyword */:
                case 113 /* ProtectedKeyword */:
                case 112 /* PrivateKeyword */:
                    let text = visibilityToString(ts.modifierToFlag(modifier.kind));
                    if (flags & 28 /* AccessibilityModifier */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics.Accessibility_modifier_already_seen);
                    }
                    else if (flags & ModifierFlags.Static) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "static");
                    }
                    else if (flags & 64 /* Readonly */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "readonly");
                    }
                    else if (flags & 256 /* Async */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "async");
                    }
                    else if (node.parent.kind === 234 /* ModuleBlock */ || node.parent.kind === SyntaxKind.SourceFile) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, text);
                    }
                    else if (flags & 128 /* Abstract */) {
                        if (modifier.kind === 112 /* PrivateKeyword */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, text, "abstract");
                        }
                        else {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "abstract");
                        }
                    }
                    flags |= ts.modifierToFlag(modifier.kind);
                    break;
                case 115 /* StaticKeyword */:
                    if (flags & ModifierFlags.Static) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "static");
                    }
                    else if (flags & 64 /* Readonly */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "static", "readonly");
                    }
                    else if (flags & 256 /* Async */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "static", "async");
                    }
                    else if (node.parent.kind === 234 /* ModuleBlock */ || node.parent.kind === SyntaxKind.SourceFile) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, "static");
                    }
                    else if (node.kind === SyntaxKind.Parameter) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "static");
                    }
                    else if (flags & 128 /* Abstract */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");
                    }
                    flags |= ModifierFlags.Static;
                    lastStatic = modifier;
                    break;
                case 131 /* ReadonlyKeyword */:
                    if (flags & 64 /* Readonly */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "readonly");
                    }
                    else if (node.kind !== SyntaxKind.PropertyDeclaration && node.kind !== SyntaxKind.PropertySignature && node.kind !== 157 /* IndexSignature */ && node.kind !== SyntaxKind.Parameter) {
                        // If node.kind === SyntaxKind.Parameter, checkParameter report an error if it's not a parameter property.
                        return grammarErrorOnNode(modifier, ts.Diagnostics.readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature);
                    }
                    flags |= 64 /* Readonly */;
                    lastReadonly = modifier;
                    break;
                case 84 /* ExportKeyword */:
                    if (flags & 1 /* Export */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "export");
                    }
                    else if (flags & 2 /* Ambient */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "export", "declare");
                    }
                    else if (flags & 128 /* Abstract */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "export", "abstract");
                    }
                    else if (flags & 256 /* Async */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "export", "async");
                    }
                    else if (node.parent.kind === SyntaxKind.ClassDeclaration) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_class_element, "export");
                    }
                    else if (node.kind === SyntaxKind.Parameter) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "export");
                    }
                    flags |= 1 /* Export */;
                    break;
                case 79 /* DefaultKeyword */:
                    let container = node.parent.kind === SyntaxKind.SourceFile ? node.parent : node.parent.parent;
                    if (container.kind === SyntaxKind.ModuleDeclaration && !ts.isAmbientModule(container)) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module);
                    }
                    flags |= 512 /* Default */;
                    break;
                case 124 /* DeclareKeyword */:
                    if (flags & 2 /* Ambient */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "declare");
                    }
                    else if (flags & 256 /* Async */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");
                    }
                    else if (node.parent.kind === SyntaxKind.ClassDeclaration) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_class_element, "declare");
                    }
                    else if (node.kind === SyntaxKind.Parameter) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "declare");
                    }
                    else if (ts.isInAmbientContext(node.parent) && node.parent.kind === 234 /* ModuleBlock */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);
                    }
                    flags |= 2 /* Ambient */;
                    lastDeclare = modifier;
                    break;
                case 117 /* AbstractKeyword */:
                    if (flags & 128 /* Abstract */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "abstract");
                    }
                    if (node.kind !== SyntaxKind.ClassDeclaration) {
                        if (node.kind !== SyntaxKind.MethodDeclaration &&
                            node.kind !== SyntaxKind.PropertyDeclaration &&
                            node.kind !== 153 /* GetAccessor */ &&
                            node.kind !== 154 /* SetAccessor */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics.abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration);
                        }
                        if (!(node.parent.kind === SyntaxKind.ClassDeclaration && ts.hasModifier(node.parent, 128 /* Abstract */))) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics.Abstract_methods_can_only_appear_within_an_abstract_class);
                        }
                        if (flags & ModifierFlags.Static) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");
                        }
                        if (flags & 8 /* Private */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "private", "abstract");
                        }
                    }
                    flags |= 128 /* Abstract */;
                    break;
                case 120 /* AsyncKeyword */:
                    if (flags & 256 /* Async */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "async");
                    }
                    else if (flags & 2 /* Ambient */ || ts.isInAmbientContext(node.parent)) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");
                    }
                    else if (node.kind === SyntaxKind.Parameter) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "async");
                    }
                    flags |= 256 /* Async */;
                    lastAsync = modifier;
                    break;
            }
        }
        if (node.kind === 152 /* Constructor */) {
            if (flags & ModifierFlags.Static) {
                return grammarErrorOnNode(lastStatic, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "static");
            }
            if (flags & 128 /* Abstract */) {
                return grammarErrorOnNode(lastStatic, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "abstract");
            }
            else if (flags & 256 /* Async */) {
                return grammarErrorOnNode(lastAsync, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "async");
            }
            else if (flags & 64 /* Readonly */) {
                return grammarErrorOnNode(lastReadonly, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "readonly");
            }
            return;
        }
        else if ((node.kind === 238 /* ImportDeclaration */ || node.kind === 237 /* ImportEqualsDeclaration */) && flags & 2 /* Ambient */) {
            return grammarErrorOnNode(lastDeclare, ts.Diagnostics.A_0_modifier_cannot_be_used_with_an_import_declaration, "declare");
        }
        else if (node.kind === SyntaxKind.Parameter && (flags & 92 /* ParameterPropertyModifier */) && ts.isBindingPattern(node.name)) {
            return grammarErrorOnNode(node, ts.Diagnostics.A_parameter_property_may_not_be_declared_using_a_binding_pattern);
        }
        else if (node.kind === SyntaxKind.Parameter && (flags & 92 /* ParameterPropertyModifier */) && node.dotDotDotToken) {
            return grammarErrorOnNode(node, ts.Diagnostics.A_parameter_property_cannot_be_declared_using_a_rest_parameter);
        }
        if (flags & 256 /* Async */) {
            return checkGrammarAsyncModifier(node, lastAsync);
        }
    }
    /**
     * true | false: Early return this value from checkGrammarModifiers.
     * undefined: Need to do full checking on the modifiers.
     */
    function reportObviousModifierErrors(node) {
        return !node.modifiers
            ? false
            : shouldReportBadModifier(node)
                ? grammarErrorOnFirstToken(node, ts.Diagnostics.Modifiers_cannot_appear_here)
                : undefined;
    }
    function shouldReportBadModifier(node) {
        switch (node.kind) {
            case 153 /* GetAccessor */:
            case 154 /* SetAccessor */:
            case 152 /* Constructor */:
            case SyntaxKind.PropertyDeclaration:
            case SyntaxKind.PropertySignature:
            case SyntaxKind.MethodDeclaration:
            case 150 /* MethodSignature */:
            case 157 /* IndexSignature */:
            case SyntaxKind.ModuleDeclaration:
            case 238 /* ImportDeclaration */:
            case 237 /* ImportEqualsDeclaration */:
            case 244 /* ExportDeclaration */:
            case SyntaxKind.ExportAssignment:
            case 186 /* FunctionExpression */:
            case 187 /* ArrowFunction */:
            case SyntaxKind.Parameter:
                return false;
            default:
                if (node.parent.kind === 234 /* ModuleBlock */ || node.parent.kind === SyntaxKind.SourceFile) {
                    return false;
                }
                switch (node.kind) {
                    case 228 /* FunctionDeclaration */:
                        return nodeHasAnyModifiersExcept(node, 120 /* AsyncKeyword */);
                    case SyntaxKind.ClassDeclaration:
                        return nodeHasAnyModifiersExcept(node, 117 /* AbstractKeyword */);
                    case SyntaxKind.InterfaceDeclaration:
                    case SyntaxKind.VariableStatement:
                    case 231 /* TypeAliasDeclaration */:
                        return true;
                    case SyntaxKind.EnumDeclaration:
                        return nodeHasAnyModifiersExcept(node, 76 /* ConstKeyword */);
                    default:
                        ts.Debug.fail();
                        return false;
                }
        }
    }
    function nodeHasAnyModifiersExcept(node, allowedModifier) {
        return node.modifiers.length > 1 || node.modifiers[0].kind !== allowedModifier;
    }
    function checkGrammarAsyncModifier(node, asyncModifier) {
        switch (node.kind) {
            case SyntaxKind.MethodDeclaration:
            case 228 /* FunctionDeclaration */:
            case 186 /* FunctionExpression */:
            case 187 /* ArrowFunction */:
                return false;
        }
        return grammarErrorOnNode(asyncModifier, ts.Diagnostics._0_modifier_cannot_be_used_here, "async");
    }
    function checkGrammarForDisallowedTrailingComma(list) {
        if (list && list.hasTrailingComma) {
            let start = list.end - ",".length;
            let end = list.end;
            return grammarErrorAtPos(list[0], start, end - start, ts.Diagnostics.Trailing_comma_not_allowed);
        }
    }
    function checkGrammarTypeParameterList(typeParameters, file) {
        if (checkGrammarForDisallowedTrailingComma(typeParameters)) {
            return true;
        }
        if (typeParameters && typeParameters.length === 0) {
            let start = typeParameters.pos - "<".length;
            let end = ts.skipTrivia(file.text, typeParameters.end) + ">".length;
            return grammarErrorAtPos(file, start, end - start, ts.Diagnostics.Type_parameter_list_cannot_be_empty);
        }
    }
    function checkGrammarParameterList(parameters) {
        let seenOptionalParameter = false;
        let parameterCount = parameters.length;
        for (let i = 0; i < parameterCount; i++) {
            let parameter = parameters[i];
            if (parameter.dotDotDotToken) {
                if (i !== (parameterCount - 1)) {
                    return grammarErrorOnNode(parameter.dotDotDotToken, ts.Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);
                }
                if (ts.isBindingPattern(parameter.name)) {
                    return grammarErrorOnNode(parameter.name, ts.Diagnostics.A_rest_element_cannot_contain_a_binding_pattern);
                }
                if (parameter.questionToken) {
                    return grammarErrorOnNode(parameter.questionToken, ts.Diagnostics.A_rest_parameter_cannot_be_optional);
                }
                if (parameter.initializer) {
                    return grammarErrorOnNode(parameter.name, ts.Diagnostics.A_rest_parameter_cannot_have_an_initializer);
                }
            }
            else if (parameter.questionToken) {
                seenOptionalParameter = true;
                if (parameter.initializer) {
                    return grammarErrorOnNode(parameter.name, ts.Diagnostics.Parameter_cannot_have_question_mark_and_initializer);
                }
            }
            else if (seenOptionalParameter && !parameter.initializer) {
                return grammarErrorOnNode(parameter.name, ts.Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter);
            }
        }
    }
    function checkGrammarFunctionLikeDeclaration(node) {
        // Prevent cascading error by short-circuit
        let file = ts.getSourceFileOfNode(node);
        return checkGrammarDecorators(node) || checkGrammarModifiers(node) || checkGrammarTypeParameterList(node.typeParameters, file) ||
            checkGrammarParameterList(node.parameters) || checkGrammarArrowFunction(node, file);
    }
    function checkGrammarClassLikeDeclaration(node) {
        let file = ts.getSourceFileOfNode(node);
        return checkGrammarClassDeclarationHeritageClauses(node) || checkGrammarTypeParameterList(node.typeParameters, file);
    }
    function checkGrammarArrowFunction(node, file) {
        if (node.kind === 187 /* ArrowFunction */) {
            let arrowFunction = node;
            let startLine = ts.getLineAndCharacterOfPosition(file, arrowFunction.equalsGreaterThanToken.pos).line;
            let endLine = ts.getLineAndCharacterOfPosition(file, arrowFunction.equalsGreaterThanToken.end).line;
            if (startLine !== endLine) {
                return grammarErrorOnNode(arrowFunction.equalsGreaterThanToken, ts.Diagnostics.Line_terminator_not_permitted_before_arrow);
            }
        }
        return false;
    }
    function checkGrammarIndexSignatureParameters(node) {
        let parameter = node.parameters[0];
        if (node.parameters.length !== 1) {
            if (parameter) {
                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_must_have_exactly_one_parameter);
            }
            else {
                return grammarErrorOnNode(node, ts.Diagnostics.An_index_signature_must_have_exactly_one_parameter);
            }
        }
        if (parameter.dotDotDotToken) {
            return grammarErrorOnNode(parameter.dotDotDotToken, ts.Diagnostics.An_index_signature_cannot_have_a_rest_parameter);
        }
        if (ts.hasModifiers(parameter)) {
            return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier);
        }
        if (parameter.questionToken) {
            return grammarErrorOnNode(parameter.questionToken, ts.Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark);
        }
        if (parameter.initializer) {
            return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_an_initializer);
        }
        if (!parameter.type) {
            return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_must_have_a_type_annotation);
        }
        if (parameter.type.kind !== 136 /* StringKeyword */ && parameter.type.kind !== 133 /* NumberKeyword */) {
            return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_type_must_be_string_or_number);
        }
        if (!node.type) {
            return grammarErrorOnNode(node, ts.Diagnostics.An_index_signature_must_have_a_type_annotation);
        }
    }
    function checkGrammarIndexSignature(node) {
        // Prevent cascading error by short-circuit
        return checkGrammarDecorators(node) || checkGrammarModifiers(node) || checkGrammarIndexSignatureParameters(node);
    }
    function checkGrammarForAtLeastOneTypeArgument(node, typeArguments) {
        if (typeArguments && typeArguments.length === 0) {
            let sourceFile = ts.getSourceFileOfNode(node);
            let start = typeArguments.pos - "<".length;
            let end = ts.skipTrivia(sourceFile.text, typeArguments.end) + ">".length;
            return grammarErrorAtPos(sourceFile, start, end - start, ts.Diagnostics.Type_argument_list_cannot_be_empty);
        }
    }
    function checkGrammarTypeArguments(node, typeArguments) {
        return checkGrammarForDisallowedTrailingComma(typeArguments) ||
            checkGrammarForAtLeastOneTypeArgument(node, typeArguments);
    }
    function checkGrammarForOmittedArgument(args) {
        if (args) {
            for (let _i = 0, args_5 = args; _i < args_5.length; _i++) {
                let arg = args_5[_i];
                if (arg.kind === 200 /* OmittedExpression */) {
                    return grammarErrorAtPos(arg, arg.pos, 0, ts.Diagnostics.Argument_expression_expected);
                }
            }
        }
    }
    function checkGrammarArguments(args) {
        return checkGrammarForOmittedArgument(args);
    }
    function checkGrammarHeritageClause(node) {
        let types = node.types;
        if (checkGrammarForDisallowedTrailingComma(types)) {
            return true;
        }
        if (types && types.length === 0) {
            let listType = ts.tokenToString(node.token);
            return grammarErrorAtPos(node, types.pos, 0, ts.Diagnostics._0_list_cannot_be_empty, listType);
        }
        return ts.forEach(types, checkGrammarExpressionWithTypeArguments);
    }
    function checkGrammarExpressionWithTypeArguments(node) {
        return checkGrammarTypeArguments(node, node.typeArguments);
    }
    function checkGrammarClassDeclarationHeritageClauses(node) {
        let seenExtendsClause = false;
        let seenImplementsClause = false;
        if (!checkGrammarDecorators(node) && !checkGrammarModifiers(node) && node.heritageClauses) {
            for (let _i = 0, _a = node.heritageClauses; _i < _a.length; _i++) {
                let heritageClause = _a[_i];
                if (heritageClause.token === 85 /* ExtendsKeyword */) {
                    if (seenExtendsClause) {
                        return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.extends_clause_already_seen);
                    }
                    if (seenImplementsClause) {
                        return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.extends_clause_must_precede_implements_clause);
                    }
                    if (heritageClause.types.length > 1) {
                        return grammarErrorOnFirstToken(heritageClause.types[1], ts.Diagnostics.Classes_can_only_extend_a_single_class);
                    }
                    seenExtendsClause = true;
                }
                else {
                    ts.Debug.assert(heritageClause.token === 108 /* ImplementsKeyword */);
                    if (seenImplementsClause) {
                        return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.implements_clause_already_seen);
                    }
                    seenImplementsClause = true;
                }
                // Grammar checking heritageClause inside class declaration
                checkGrammarHeritageClause(heritageClause);
            }
        }
    }
    function checkGrammarInterfaceDeclaration(node) {
        let seenExtendsClause = false;
        if (node.heritageClauses) {
            for (let _i = 0, _a = node.heritageClauses; _i < _a.length; _i++) {
                let heritageClause = _a[_i];
                if (heritageClause.token === 85 /* ExtendsKeyword */) {
                    if (seenExtendsClause) {
                        return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.extends_clause_already_seen);
                    }
                    seenExtendsClause = true;
                }
                else {
                    ts.Debug.assert(heritageClause.token === 108 /* ImplementsKeyword */);
                    return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.Interface_declaration_cannot_have_implements_clause);
                }
                // Grammar checking heritageClause inside class declaration
                checkGrammarHeritageClause(heritageClause);
            }
        }
        return false;
    }
    function checkGrammarComputedPropertyName(node) {
        // If node is not a computedPropertyName, just skip the grammar checking
        if (node.kind !== 144 /* ComputedPropertyName */) {
            return false;
        }
        let computedPropertyName = node;
        if (computedPropertyName.expression.kind === 194 /* BinaryExpression */ && computedPropertyName.expression.operatorToken.kind === 26 /* CommaToken */) {
            return grammarErrorOnNode(computedPropertyName.expression, ts.Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name);
        }
    }
    function checkGrammarForGenerator(node) {
        if (node.asteriskToken) {
            ts.Debug.assert(node.kind === 228 /* FunctionDeclaration */ ||
                node.kind === 186 /* FunctionExpression */ ||
                node.kind === SyntaxKind.MethodDeclaration);
            if (ts.isInAmbientContext(node)) {
                return grammarErrorOnNode(node.asteriskToken, ts.Diagnostics.Generators_are_not_allowed_in_an_ambient_context);
            }
            if (!node.body) {
                return grammarErrorOnNode(node.asteriskToken, ts.Diagnostics.An_overload_signature_cannot_be_declared_as_a_generator);
            }
        }
    }
    function checkGrammarForInvalidQuestionMark(questionToken, message) {
        if (questionToken) {
            return grammarErrorOnNode(questionToken, message);
        }
    }
    function checkGrammarObjectLiteralExpression(node, inDestructuring) {
        let seen = ts.createUnderscoreEscapedMap();
        let Property = 1;
        let GetAccessor = 2;
        let SetAccessor = 4;
        let GetOrSetAccessor = GetAccessor | SetAccessor;
        for (let _i = 0, _a = node.properties; _i < _a.length; _i++) {
            let prop = _a[_i];
            if (prop.kind === 266 /* SpreadAssignment */) {
                continue;
            }
            let name = prop.name;
            if (name.kind === 144 /* ComputedPropertyName */) {
                // If the name is not a ComputedPropertyName, the grammar checking will skip it
                checkGrammarComputedPropertyName(name);
            }
            if (prop.kind === 265 /* ShorthandPropertyAssignment */ && !inDestructuring && prop.objectAssignmentInitializer) {
                // having objectAssignmentInitializer is only valid in ObjectAssignmentPattern
                // outside of destructuring it is a syntax error
                return grammarErrorOnNode(prop.equalsToken, ts.Diagnostics.can_only_be_used_in_an_object_literal_property_inside_a_destructuring_assignment);
            }
            // Modifiers are never allowed on properties except for 'async' on a method declaration
            if (prop.modifiers) {
                for (let _b = 0, _c = prop.modifiers; _b < _c.length; _b++) {
                    let mod = _c[_b];
                    if (mod.kind !== 120 /* AsyncKeyword */ || prop.kind !== SyntaxKind.MethodDeclaration) {
                        grammarErrorOnNode(mod, ts.Diagnostics._0_modifier_cannot_be_used_here, ts.getTextOfNode(mod));
                    }
                }
            }
            // ECMA-262 11.1.5 Object Initializer
            // If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true
            // a.This production is contained in strict code and IsDataDescriptor(previous) is true and
            // IsDataDescriptor(propId.descriptor) is true.
            //    b.IsDataDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true.
            //    c.IsAccessorDescriptor(previous) is true and IsDataDescriptor(propId.descriptor) is true.
            //    d.IsAccessorDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true
            // and either both previous and propId.descriptor have[[Get]] fields or both previous and propId.descriptor have[[Set]] fields
            let currentKind = void 0;
            if (prop.kind === 264 /* PropertyAssignment */ || prop.kind === 265 /* ShorthandPropertyAssignment */) {
                // Grammar checking for computedPropertyName and shorthandPropertyAssignment
                checkGrammarForInvalidQuestionMark(prop.questionToken, ts.Diagnostics.An_object_member_cannot_be_declared_optional);
                if (name.kind === 8 /* NumericLiteral */) {
                    checkGrammarNumericLiteral(name);
                }
                currentKind = Property;
            }
            else if (prop.kind === SyntaxKind.MethodDeclaration) {
                currentKind = Property;
            }
            else if (prop.kind === 153 /* GetAccessor */) {
                currentKind = GetAccessor;
            }
            else if (prop.kind === 154 /* SetAccessor */) {
                currentKind = SetAccessor;
            }
            else {
                ts.Debug.assertNever(prop, "Unexpected syntax kind:" + prop.kind);
            }
            let effectiveName = ts.getPropertyNameForPropertyNameNode(name);
            if (effectiveName === undefined) {
                continue;
            }
            let existingKind = seen.get(effectiveName);
            if (!existingKind) {
                seen.set(effectiveName, currentKind);
            }
            else {
                if (currentKind === Property && existingKind === Property) {
                    grammarErrorOnNode(name, ts.Diagnostics.Duplicate_identifier_0, ts.getTextOfNode(name));
                }
                else if ((currentKind & GetOrSetAccessor) && (existingKind & GetOrSetAccessor)) {
                    if (existingKind !== GetOrSetAccessor && currentKind !== existingKind) {
                        seen.set(effectiveName, currentKind | existingKind);
                    }
                    else {
                        return grammarErrorOnNode(name, ts.Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name);
                    }
                }
                else {
                    return grammarErrorOnNode(name, ts.Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name);
                }
            }
        }
    }
    function checkGrammarJsxElement(node) {
        let seen = ts.createUnderscoreEscapedMap();
        for (let _i = 0, _a = node.attributes.properties; _i < _a.length; _i++) {
            let attr = _a[_i];
            if (attr.kind === 258 /* JsxSpreadAttribute */) {
                continue;
            }
            let jsxAttr = attr;
            let name = jsxAttr.name;
            if (!seen.get(name.escapedText)) {
                seen.set(name.escapedText, true);
            }
            else {
                return grammarErrorOnNode(name, ts.Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name);
            }
            let initializer = jsxAttr.initializer;
            if (initializer && initializer.kind === 259 /* JsxExpression */ && !initializer.expression) {
                return grammarErrorOnNode(jsxAttr.initializer, ts.Diagnostics.JSX_attributes_must_only_be_assigned_a_non_empty_expression);
            }
        }
    }
    function checkGrammarForInOrForOfStatement(forInOrOfStatement) {
        if (checkGrammarStatementInAmbientContext(forInOrOfStatement)) {
            return true;
        }
        if (forInOrOfStatement.kind === SyntaxKind.ForOfStatement && forInOrOfStatement.awaitModifier) {
            if ((forInOrOfStatement.flags & 16384 /* AwaitContext */) === 0 /* None */) {
                return grammarErrorOnNode(forInOrOfStatement.awaitModifier, ts.Diagnostics.A_for_await_of_statement_is_only_allowed_within_an_async_function_or_async_generator);
            }
        }
        if (forInOrOfStatement.initializer.kind === 227 /* VariableDeclarationList */) {
            let variableList = forInOrOfStatement.initializer;
            if (!checkGrammarVariableDeclarationList(variableList)) {
                let declarations = variableList.declarations;
                // declarations.length can be zero if there is an error in variable declaration in for-of or for-in
                // See http://www.ecma-international.org/ecma-262/6.0/#sec-for-in-and-for-of-statements for details
                // For example:
                //      let let = 10;
                //      for (let of [1,2,3]) {} // this is invalid ES6 syntax
                //      for (let in [1,2,3]) {} // this is invalid ES6 syntax
                // We will then want to skip on grammar checking on variableList declaration
                if (!declarations.length) {
                    return false;
                }
                if (declarations.length > 1) {
                    let diagnostic = forInOrOfStatement.kind === 215 /* ForInStatement */
                        ? ts.Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement
                        : ts.Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement;
                    return grammarErrorOnFirstToken(variableList.declarations[1], diagnostic);
                }
                let firstDeclaration = declarations[0];
                if (firstDeclaration.initializer) {
                    let diagnostic = forInOrOfStatement.kind === 215 /* ForInStatement */
                        ? ts.Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer
                        : ts.Diagnostics.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer;
                    return grammarErrorOnNode(firstDeclaration.name, diagnostic);
                }
                if (firstDeclaration.type) {
                    let diagnostic = forInOrOfStatement.kind === 215 /* ForInStatement */
                        ? ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation
                        : ts.Diagnostics.The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation;
                    return grammarErrorOnNode(firstDeclaration, diagnostic);
                }
            }
        }
        return false;
    }
    function checkGrammarAccessor(accessor) {
        let kind = accessor.kind;
        if (languageVersion < 1 /* ES5 */) {
            return grammarErrorOnNode(accessor.name, ts.Diagnostics.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher);
        }
        else if (ts.isInAmbientContext(accessor)) {
            return grammarErrorOnNode(accessor.name, ts.Diagnostics.An_accessor_cannot_be_declared_in_an_ambient_context);
        }
        else if (accessor.body === undefined && !ts.hasModifier(accessor, 128 /* Abstract */)) {
            return grammarErrorAtPos(accessor, accessor.end - 1, ";".length, ts.Diagnostics._0_expected, "{");
        }
        else if (accessor.body && ts.hasModifier(accessor, 128 /* Abstract */)) {
            return grammarErrorOnNode(accessor, ts.Diagnostics.An_abstract_accessor_cannot_have_an_implementation);
        }
        else if (accessor.typeParameters) {
            return grammarErrorOnNode(accessor.name, ts.Diagnostics.An_accessor_cannot_have_type_parameters);
        }
        else if (!doesAccessorHaveCorrectParameterCount(accessor)) {
            return grammarErrorOnNode(accessor.name, kind === 153 /* GetAccessor */ ?
                ts.Diagnostics.A_get_accessor_cannot_have_parameters :
                ts.Diagnostics.A_set_accessor_must_have_exactly_one_parameter);
        }
        else if (kind === 154 /* SetAccessor */) {
            if (accessor.type) {
                return grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation);
            }
            else {
                let parameter = accessor.parameters[0];
                if (parameter.dotDotDotToken) {
                    return grammarErrorOnNode(parameter.dotDotDotToken, ts.Diagnostics.A_set_accessor_cannot_have_rest_parameter);
                }
                else if (parameter.questionToken) {
                    return grammarErrorOnNode(parameter.questionToken, ts.Diagnostics.A_set_accessor_cannot_have_an_optional_parameter);
                }
                else if (parameter.initializer) {
                    return grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer);
                }
            }
        }
    }
    /** Does the accessor have the right number of parameters?
     * A get accessor has no parameters or a single `this` parameter.
     * A set accessor has one parameter or a `this` parameter and one more parameter.
     */
    function doesAccessorHaveCorrectParameterCount(accessor) {
        return getAccessorThisParameter(accessor) || accessor.parameters.length === (accessor.kind === 153 /* GetAccessor */ ? 0 : 1);
    }
    function getAccessorThisParameter(accessor) {
        if (accessor.parameters.length === (accessor.kind === 153 /* GetAccessor */ ? 1 : 2)) {
            return ts.getThisParameter(accessor);
        }
    }
    function checkGrammarForNonSymbolComputedProperty(node, message) {
        if (ts.isDynamicName(node)) {
            return grammarErrorOnNode(node, message);
        }
    }
    function checkGrammarMethod(node) {
        if (checkGrammarDisallowedModifiersOnObjectLiteralExpressionMethod(node) ||
            checkGrammarFunctionLikeDeclaration(node) ||
            checkGrammarForGenerator(node)) {
            return true;
        }
        if (node.parent.kind === 178 /* ObjectLiteralExpression */) {
            if (checkGrammarForInvalidQuestionMark(node.questionToken, ts.Diagnostics.An_object_member_cannot_be_declared_optional)) {
                return true;
            }
            else if (node.body === undefined) {
                return grammarErrorAtPos(node, node.end - 1, ";".length, ts.Diagnostics._0_expected, "{");
            }
        }
        if (ts.isClassLike(node.parent)) {
            // Technically, computed properties in ambient contexts is disallowed
            // for property declarations and accessors too, not just methods.
            // However, property declarations disallow computed names in general,
            // and accessors are not allowed in ambient contexts in general,
            // so this error only really matters for methods.
            if (ts.isInAmbientContext(node)) {
                return checkGrammarForNonSymbolComputedProperty(node.name, ts.Diagnostics.A_computed_property_name_in_an_ambient_context_must_directly_refer_to_a_built_in_symbol);
            }
            else if (!node.body) {
                return checkGrammarForNonSymbolComputedProperty(node.name, ts.Diagnostics.A_computed_property_name_in_a_method_overload_must_directly_refer_to_a_built_in_symbol);
            }
        }
        else if (node.parent.kind === SyntaxKind.InterfaceDeclaration) {
            return checkGrammarForNonSymbolComputedProperty(node.name, ts.Diagnostics.A_computed_property_name_in_an_interface_must_directly_refer_to_a_built_in_symbol);
        }
        else if (node.parent.kind === 163 /* TypeLiteral */) {
            return checkGrammarForNonSymbolComputedProperty(node.name, ts.Diagnostics.A_computed_property_name_in_a_type_literal_must_directly_refer_to_a_built_in_symbol);
        }
    }
    function checkGrammarBreakOrContinueStatement(node) {
        let current = node;
        while (current) {
            if (ts.isFunctionLike(current)) {
                return grammarErrorOnNode(node, ts.Diagnostics.Jump_target_cannot_cross_function_boundary);
            }
            switch (current.kind) {
                case 222 /* LabeledStatement */:
                    if (node.label && current.label.escapedText === node.label.escapedText) {
                        // found matching label - verify that label usage is correct
                        // continue can only target labels that are on iteration statements
                        let isMisplacedContinueLabel = node.kind === 217 /* ContinueStatement */
                            && !ts.isIterationStatement(current.statement, /*lookInLabeledStatement*/ true);
                        if (isMisplacedContinueLabel) {
                            return grammarErrorOnNode(node, ts.Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement);
                        }
                        return false;
                    }
                    break;
                case 221 /* SwitchStatement */:
                    if (node.kind === 218 /* BreakStatement */ && !node.label) {
                        // unlabeled break within switch statement - ok
                        return false;
                    }
                    break;
                default:
                    if (ts.isIterationStatement(current, /*lookInLabeledStatement*/ false) && !node.label) {
                        // unlabeled break or continue within iteration statement - ok
                        return false;
                    }
                    break;
            }
            current = current.parent;
        }
        if (node.label) {
            let message = node.kind === 218 /* BreakStatement */
                ? ts.Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement
                : ts.Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement;
            return grammarErrorOnNode(node, message);
        }
        else {
            let message = node.kind === 218 /* BreakStatement */
                ? ts.Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement
                : ts.Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement;
            return grammarErrorOnNode(node, message);
        }
    }
    function checkGrammarBindingElement(node) {
        if (node.dotDotDotToken) {
            let elements = node.parent.elements;
            if (node !== ts.lastOrUndefined(elements)) {
                return grammarErrorOnNode(node, ts.Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern);
            }
            if (node.name.kind === 175 /* ArrayBindingPattern */ || node.name.kind === 174 /* ObjectBindingPattern */) {
                return grammarErrorOnNode(node.name, ts.Diagnostics.A_rest_element_cannot_contain_a_binding_pattern);
            }
            if (node.initializer) {
                // Error on equals token which immediately precedes the initializer
                return grammarErrorAtPos(node, node.initializer.pos - 1, 1, ts.Diagnostics.A_rest_element_cannot_have_an_initializer);
            }
        }
    }
    function isStringOrNumberLiteralExpression(expr) {
        return expr.kind === 9 /* StringLiteral */ || expr.kind === 8 /* NumericLiteral */ ||
            expr.kind === 192 /* PrefixUnaryExpression */ && expr.operator === 38 /* MinusToken */ &&
            expr.operand.kind === 8 /* NumericLiteral */;
    }
    function checkGrammarVariableDeclaration(node) {
        if (node.parent.parent.kind !== 215 /* ForInStatement */ && node.parent.parent.kind !== SyntaxKind.ForOfStatement) {
            if (ts.isInAmbientContext(node)) {
                if (node.initializer) {
                    if (ts.isConst(node) && !node.type) {
                        if (!isStringOrNumberLiteralExpression(node.initializer)) {
                            return grammarErrorOnNode(node.initializer, ts.Diagnostics.A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal);
                        }
                    }
                    else {
                        // Error on equals token which immediate precedes the initializer
                        let equalsTokenLength = "=".length;
                        return grammarErrorAtPos(node, node.initializer.pos - equalsTokenLength, equalsTokenLength, ts.Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);
                    }
                }
                if (node.initializer && !(ts.isConst(node) && isStringOrNumberLiteralExpression(node.initializer))) {
                    // Error on equals token which immediate precedes the initializer
                    let equalsTokenLength = "=".length;
                    return grammarErrorAtPos(node, node.initializer.pos - equalsTokenLength, equalsTokenLength, ts.Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);
                }
            }
            else if (!node.initializer) {
                if (ts.isBindingPattern(node.name) && !ts.isBindingPattern(node.parent)) {
                    return grammarErrorOnNode(node, ts.Diagnostics.A_destructuring_declaration_must_have_an_initializer);
                }
                if (ts.isConst(node)) {
                    return grammarErrorOnNode(node, ts.Diagnostics.const_declarations_must_be_initialized);
                }
            }
        }
        if (compilerOptions.module !== ts.ModuleKind.ES2015 && compilerOptions.module !== ts.ModuleKind.ESNext && compilerOptions.module !== ts.ModuleKind.System && !compilerOptions.noEmit &&
            !ts.isInAmbientContext(node.parent.parent) && ts.hasModifier(node.parent.parent, 1 /* Export */)) {
            checkESModuleMarker(node.name);
        }
        let checkLetConstNames = (ts.isLet(node) || ts.isConst(node));
        // 1. LexicalDeclaration : LetOrConst BindingList ;
        // It is a Syntax Error if the BoundNames of BindingList contains "let".
        // 2. ForDeclaration: ForDeclaration : LetOrConst ForBinding
        // It is a Syntax Error if the BoundNames of ForDeclaration contains "let".
        // It is a SyntaxError if a VariableDeclaration or VariableDeclarationNoIn occurs within strict code
        // and its Identifier is eval or arguments
        return checkLetConstNames && checkGrammarNameInLetOrConstDeclarations(node.name);
    }
    function checkESModuleMarker(name) {
        if (name.kind === 71 /* Identifier */) {
            if (ts.idText(name) === "__esModule") {
                return grammarErrorOnNode(name, ts.Diagnostics.Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules);
            }
        }
        else {
            let elements = name.elements;
            for (let _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
                let element = elements_1[_i];
                if (!ts.isOmittedExpression(element)) {
                    return checkESModuleMarker(element.name);
                }
            }
        }
    }
    function checkGrammarNameInLetOrConstDeclarations(name) {
        if (name.kind === 71 /* Identifier */) {
            if (name.originalKeywordKind === 110 /* LetKeyword */) {
                return grammarErrorOnNode(name, ts.Diagnostics.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations);
            }
        }
        else {
            let elements = name.elements;
            for (let _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
                let element = elements_2[_i];
                if (!ts.isOmittedExpression(element)) {
                    checkGrammarNameInLetOrConstDeclarations(element.name);
                }
            }
        }
    }
    function checkGrammarVariableDeclarationList(declarationList) {
        let declarations = declarationList.declarations;
        if (checkGrammarForDisallowedTrailingComma(declarationList.declarations)) {
            return true;
        }
        if (!declarationList.declarations.length) {
            return grammarErrorAtPos(declarationList, declarations.pos, declarations.end - declarations.pos, ts.Diagnostics.Variable_declaration_list_cannot_be_empty);
        }
    }
    function allowLetAndConstDeclarations(parent) {
        switch (parent.kind) {
            case 211 /* IfStatement */:
            case 212 /* DoStatement */:
            case 213 /* WhileStatement */:
            case 220 /* WithStatement */:
            case SyntaxKind.ForStatement:
            case 215 /* ForInStatement */:
            case SyntaxKind.ForOfStatement:
                return false;
            case 222 /* LabeledStatement */:
                return allowLetAndConstDeclarations(parent.parent);
        }
        return true;
    }
    function checkGrammarForDisallowedLetOrConstStatement(node) {
        if (!allowLetAndConstDeclarations(node.parent)) {
            if (ts.isLet(node.declarationList)) {
                return grammarErrorOnNode(node, ts.Diagnostics.let_declarations_can_only_be_declared_inside_a_block);
            }
            else if (ts.isConst(node.declarationList)) {
                return grammarErrorOnNode(node, ts.Diagnostics.const_declarations_can_only_be_declared_inside_a_block);
            }
        }
    }
    function checkGrammarMetaProperty(node) {
        if (node.keywordToken === 94 /* NewKeyword */) {
            if (node.name.escapedText !== "target") {
                return grammarErrorOnNode(node.name, ts.Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, node.name.escapedText, ts.tokenToString(node.keywordToken), "target");
            }
        }
    }
    function hasParseDiagnostics(sourceFile) {
        return sourceFile.parseDiagnostics.length > 0;
    }
    function grammarErrorOnFirstToken(node, message, arg0, arg1, arg2) {
        let sourceFile = ts.getSourceFileOfNode(node);
        if (!hasParseDiagnostics(sourceFile)) {
            let span_4 = ts.getSpanOfTokenAtPosition(sourceFile, node.pos);
            diagnostics.add(ts.createFileDiagnostic(sourceFile, span_4.start, span_4.length, message, arg0, arg1, arg2));
            return true;
        }
    }
    function grammarErrorAtPos(nodeForSourceFile, start, length, message, arg0, arg1, arg2) {
        let sourceFile = ts.getSourceFileOfNode(nodeForSourceFile);
        if (!hasParseDiagnostics(sourceFile)) {
            diagnostics.add(ts.createFileDiagnostic(sourceFile, start, length, message, arg0, arg1, arg2));
            return true;
        }
    }
    function grammarErrorOnNode(node, message, arg0, arg1, arg2) {
        let sourceFile = ts.getSourceFileOfNode(node);
        if (!hasParseDiagnostics(sourceFile)) {
            diagnostics.add(ts.createDiagnosticForNode(node, message, arg0, arg1, arg2));
            return true;
        }
    }
    function checkGrammarConstructorTypeParameters(node) {
        if (node.typeParameters) {
            return grammarErrorAtPos(node, node.typeParameters.pos, node.typeParameters.end - node.typeParameters.pos, ts.Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration);
        }
    }
    function checkGrammarConstructorTypeAnnotation(node) {
        if (node.type) {
            return grammarErrorOnNode(node.type, ts.Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration);
        }
    }
    function checkGrammarProperty(node) {
        if (ts.isClassLike(node.parent)) {
            if (checkGrammarForNonSymbolComputedProperty(node.name, ts.Diagnostics.A_computed_property_name_in_a_class_property_declaration_must_directly_refer_to_a_built_in_symbol)) {
                return true;
            }
        }
        else if (node.parent.kind === SyntaxKind.InterfaceDeclaration) {
            if (checkGrammarForNonSymbolComputedProperty(node.name, ts.Diagnostics.A_computed_property_name_in_an_interface_must_directly_refer_to_a_built_in_symbol)) {
                return true;
            }
            if (node.initializer) {
                return grammarErrorOnNode(node.initializer, ts.Diagnostics.An_interface_property_cannot_have_an_initializer);
            }
        }
        else if (node.parent.kind === 163 /* TypeLiteral */) {
            if (checkGrammarForNonSymbolComputedProperty(node.name, ts.Diagnostics.A_computed_property_name_in_a_type_literal_must_directly_refer_to_a_built_in_symbol)) {
                return true;
            }
            if (node.initializer) {
                return grammarErrorOnNode(node.initializer, ts.Diagnostics.A_type_literal_property_cannot_have_an_initializer);
            }
        }
        if (ts.isInAmbientContext(node) && node.initializer) {
            return grammarErrorOnFirstToken(node.initializer, ts.Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);
        }
    }
    function checkGrammarTopLevelElementForRequiredDeclareModifier(node) {
        // A declare modifier is required for any top level .d.ts declaration except export=, export default, export as namespace
        // interfaces and imports categories:
        //
        //  DeclarationElement:
        //     ExportAssignment
        //     export_opt   InterfaceDeclaration
        //     export_opt   TypeAliasDeclaration
        //     export_opt   ImportDeclaration
        //     export_opt   ExternalImportDeclaration
        //     export_opt   AmbientDeclaration
        //
        // TODO: The spec needs to be amended to reflect this grammar.
        if (node.kind === SyntaxKind.InterfaceDeclaration ||
            node.kind === 231 /* TypeAliasDeclaration */ ||
            node.kind === 238 /* ImportDeclaration */ ||
            node.kind === 237 /* ImportEqualsDeclaration */ ||
            node.kind === 244 /* ExportDeclaration */ ||
            node.kind === SyntaxKind.ExportAssignment ||
            node.kind === 236 /* NamespaceExportDeclaration */ ||
            ts.hasModifier(node, 2 /* Ambient */ | 1 /* Export */ | 512 /* Default */)) {
            return false;
        }
        return grammarErrorOnFirstToken(node, ts.Diagnostics.A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file);
    }
    function checkGrammarTopLevelElementsForRequiredDeclareModifier(file) {
        for (let _i = 0, _a = file.statements; _i < _a.length; _i++) {
            let decl = _a[_i];
            if (ts.isDeclaration(decl) || decl.kind === SyntaxKind.VariableStatement) {
                if (checkGrammarTopLevelElementForRequiredDeclareModifier(decl)) {
                    return true;
                }
            }
        }
    }
    function checkGrammarSourceFile(node) {
        return ts.isInAmbientContext(node) && checkGrammarTopLevelElementsForRequiredDeclareModifier(node);
    }
    function checkGrammarStatementInAmbientContext(node) {
        if (ts.isInAmbientContext(node)) {
            // An accessors is already reported about the ambient context
            if (ts.isAccessor(node.parent)) {
                return getNodeLinks(node).hasReportedStatementInAmbientContext = true;
            }
            // Find containing block which is either Block, ModuleBlock, SourceFile
            let links = getNodeLinks(node);
            if (!links.hasReportedStatementInAmbientContext && ts.isFunctionLike(node.parent)) {
                return getNodeLinks(node).hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, ts.Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts);
            }
            // We are either parented by another statement, or some sort of block.
            // If we're in a block, we only want to really report an error once
            // to prevent noisiness.  So use a bit on the block to indicate if
            // this has already been reported, and don't report if it has.
            //
            if (node.parent.kind === 207 /* Block */ || node.parent.kind === 234 /* ModuleBlock */ || node.parent.kind === SyntaxKind.SourceFile) {
                let links_1 = getNodeLinks(node.parent);
                // Check if the containing block ever report this error
                if (!links_1.hasReportedStatementInAmbientContext) {
                    return links_1.hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, ts.Diagnostics.Statements_are_not_allowed_in_ambient_contexts);
                }
            }
            else {
                // We must be parented by a statement.  If so, there's no need
                // to report the error as our parent will have already done it.
                // Debug.assert(isStatement(node.parent));
            }
        }
    }
    function checkGrammarNumericLiteral(node) {
        // Grammar checking
        if (node.numericLiteralFlags & 4 /* Octal */) {
            let diagnosticMessage = void 0;
            if (languageVersion >= 1 /* ES5 */) {
                diagnosticMessage = ts.Diagnostics.Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0;
            }
            else if (ts.isChildOfNodeWithKind(node, 173 /* LiteralType */)) {
                diagnosticMessage = ts.Diagnostics.Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0;
            }
            else if (ts.isChildOfNodeWithKind(node, 267 /* EnumMember */)) {
                diagnosticMessage = ts.Diagnostics.Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0;
            }
            if (diagnosticMessage) {
                let withMinus = ts.isPrefixUnaryExpression(node.parent) && node.parent.operator === 38 /* MinusToken */;
                let literal = (withMinus ? "-" : "") + "0o" + node.text;
                return grammarErrorOnNode(withMinus ? node.parent : node, diagnosticMessage, literal);
            }
        }
    }
    function grammarErrorAfterFirstToken(node, message, arg0, arg1, arg2) {
        let sourceFile = ts.getSourceFileOfNode(node);
        if (!hasParseDiagnostics(sourceFile)) {
            let span_5 = ts.getSpanOfTokenAtPosition(sourceFile, node.pos);
            diagnostics.add(ts.createFileDiagnostic(sourceFile, ts.textSpanEnd(span_5), /*length*/ 0, message, arg0, arg1, arg2));
            return true;
        }
    }
    function getAmbientModules() {
        if (!ambientModulesCache) {
            ambientModulesCache = [];
            globals.forEach(function (global, sym) {
                // No need to `unescapeLeadingUnderscores`, an escaped symbol is never an ambient module.
                if (ambientModuleSymbolRegex.test(sym)) {
                    ambientModulesCache.push(global);
                }
            });
        }
        return ambientModulesCache;
    }
    function checkGrammarImportCallExpression(node) {
        if (modulekind === ts.ModuleKind.ES2015) {
            return grammarErrorOnNode(node, ts.Diagnostics.Dynamic_import_cannot_be_used_when_targeting_ECMAScript_2015_modules);
        }
        if (node.typeArguments) {
            return grammarErrorOnNode(node, ts.Diagnostics.Dynamic_import_cannot_have_type_arguments);
        }
        let nodeArguments = node.arguments;
        if (nodeArguments.length !== 1) {
            return grammarErrorOnNode(node, ts.Diagnostics.Dynamic_import_must_have_one_specifier_as_an_argument);
        }
        // see: parseArgumentOrArrayLiteralElement...we use this function which parse arguments of callExpression to parse specifier for dynamic import.
        // parseArgumentOrArrayLiteralElement allows spread element to be in an argument list which is not allowed as specifier in dynamic import.
        if (ts.isSpreadElement(nodeArguments[0])) {
            return grammarErrorOnNode(nodeArguments[0], ts.Diagnostics.Specifier_of_dynamic_import_cannot_be_spread_element);
        }
    }
}